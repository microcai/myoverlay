diff -urp libpurple/protocols/qq/buddy_info.c libpurple/protocols/qq/buddy_info.c
--- libpurple/protocols/qq/buddy_info.c	2011-02-07 11:42:12.000000000 +0800
+++ libpurple/protocols/qq/buddy_info.c	2011-02-24 17:38:51.993460334 +0800
@@ -26,7 +26,6 @@
 #include "debug.h"
 #include "notify.h"
 #include "request.h"
-#include "connection.h"
 
 #include "utils.h"
 #include "packet_parse.h"
@@ -69,90 +68,99 @@ static const gchar *genders[] = {
 	N_("Female"),
 };
 
-static const gchar *genders_zh[] = {
-	"-",
-	"\xc4\xd0",
-	"\xc5\xae",
+#define QQ_PRIVACY_SETTINGS 3
+static const gchar * privacy_sets[] = {
+	N_("Open to Public"),
+	N_("Friends Only"),
+	N_("Private"),
 };
 
 #define QQ_FACES	    134
 #define QQ_ICON_PREFIX "qq_"
 #define QQ_ICON_SUFFIX ".png"
 
-enum {
-	QQ_INFO_UID = 0, QQ_INFO_NICK, QQ_INFO_COUNTRY, QQ_INFO_PROVINCE, QQ_INFO_ZIPCODE,
-	QQ_INFO_ADDR, QQ_INFO_TEL, QQ_INFO_AGE, QQ_INFO_GENDER, QQ_INFO_NAME, QQ_INFO_EMAIL,
-	QQ_INFO_PG_SN, QQ_INFO_PG_NUM, QQ_INFO_PG_SP, QQ_INFO_PG_BASE_NUM, QQ_INFO_PG_TYPE,
-	QQ_INFO_OCCU, QQ_INFO_HOME_PAGE, QQ_INFO_AUTH_TYPE, QQ_INFO_UNKNOW1, QQ_INFO_UNKNOW2,
-	QQ_INFO_FACE, QQ_INFO_MOBILE, QQ_INFO_MOBILE_TYPE, QQ_INFO_INTRO, QQ_INFO_CITY,
-	QQ_INFO_UNKNOW3, QQ_INFO_UNKNOW4, QQ_INFO_UNKNOW5,
-	QQ_INFO_IS_PUB_MOBILE, QQ_INFO_IS_PUB_CONTACT, QQ_INFO_COLLEGE, QQ_INFO_HOROSCOPE,
-	QQ_INFO_ZODIAC, QQ_INFO_BLOOD, QQ_INFO_SHOW, QQ_INFO_UNKNOW6,
-	QQ_INFO_LAST_2007, QQ_INFO_LAST
-};
+#define 	QQ_INFO_UID
+#define 	QQ_INFO_NICK						0x4E22
+#define 	QQ_INFO_ZIPCODE				0x4E25
+#define 	QQ_INFO_ADDR					0x4E25
+#define 	QQ_INFO_TEL						0x4E27
+#define 	QQ_INFO_GENDER				0x4E29
+#define 	QQ_INFO_NAME					0x4E2A
+#define 	QQ_INFO_EMAIL					0x4E2B
+#define 	QQ_INFO_OCCUPATION		0x4E2C
+#define 	QQ_INFO_HOMEPAGE		0x4E2D
+#define 	QQ_INFO_COUNTRY			0x4E2E
+#define 	QQ_INFO_FACE						0x4E2F
+#define 	QQ_INFO_MOBILE				0x4E30
+#define 	QQ_INFO_PRIVACY				0x4E31
+#define 	QQ_INFO_INTRO					0x4E33
+#define 	QQ_INFO_SCHOOL				0x4E35
+#define 	QQ_INFO_HOROSCOPE		0x4E36
+#define 	QQ_INFO_ZODIAC				0x4E37
+#define 	QQ_INFO_BLOOD					0x4E38
+#define 	QQ_INFO_BIRTH					0x4E3F
+#define 	QQ_INFO_COUNTRY_PROVINCE_CITY		0x4E40
+#define 	QQ_INFO_1STLANG				0x4E41
+#define 	QQ_INFO_2NDLANG			0x4E42
+#define 	QQ_INFO_3RDLANG			0x4E43
+#define 	QQ_INFO_AGE						0x4E45
+/*	
+#define 	QQ_INFO_VIP						0x520B
+#define 	QQ_INFO_CLIENT				0x520F
+ */
 
 enum {
 	QQ_FIELD_UNUSED = 0, QQ_FIELD_BASE, QQ_FIELD_EXT, QQ_FIELD_CONTACT, QQ_FIELD_ADDR
 };
 
 enum {
-	QQ_FIELD_LABEL = 0, QQ_FIELD_STRING, QQ_FIELD_MULTI, QQ_FIELD_BOOL, QQ_FIELD_CHOICE
+	QQ_FIELD_LABEL = 0, QQ_FIELD_STRING, QQ_FIELD_MULTI, QQ_FIELD_NUM, QQ_FIELD_BOOL, QQ_FIELD_CHOICE, QQ_FIELD_TIME
 };
 
 typedef struct {
-	int iclass;
-	int type;
+	guint iclass;
+	guint type;
 	char *id;
 	char *text;
 	const gchar **choice;
-	int choice_size;
+	guint choice_size;
 } QQ_FIELD_INFO;
 
 static const QQ_FIELD_INFO field_infos[] = {
-	{ QQ_FIELD_BASE, 	QQ_FIELD_STRING, "uid", 	N_("QQ Number"), NULL, 0 },
-	{ QQ_FIELD_BASE, 	QQ_FIELD_STRING, "nick", 	N_("Nickname"), NULL, 0 },
-	{ QQ_FIELD_ADDR, 	QQ_FIELD_STRING, "country", 	N_("Country/Region"), NULL, 0 },
-	{ QQ_FIELD_ADDR, 	QQ_FIELD_STRING, "province", 	N_("Province/State"), NULL, 0 },
+	{ QQ_FIELD_BASE, 	QQ_FIELD_NUM, "uid", 	N_("QQ Number"), NULL, 0 },
+	{ QQ_FIELD_BASE, 	QQ_FIELD_STRING, "nickname", 	N_("Nickname"), NULL, 0 },
 	{ QQ_FIELD_ADDR, 	QQ_FIELD_STRING, "zipcode", 	N_("Zipcode"), NULL, 0 },
 	{ QQ_FIELD_ADDR, 	QQ_FIELD_STRING, "address", 	N_("Address"), NULL, 0 },
 	{ QQ_FIELD_CONTACT, 	QQ_FIELD_STRING, "tel", 	N_("Phone Number"), NULL, 0 },
-	{ QQ_FIELD_BASE, 	QQ_FIELD_STRING, "age", 	N_("Age"), NULL, 0 },
 	{ QQ_FIELD_BASE, 	QQ_FIELD_CHOICE, "gender", 	N_("Gender"), genders, QQ_GENDER_SIZE },
 	{ QQ_FIELD_BASE, 	QQ_FIELD_STRING, "name", 	N_("Name"), NULL, 0 },
 	{ QQ_FIELD_CONTACT, 	QQ_FIELD_STRING, "email", 	N_("Email"), NULL, 0 },
-	{ QQ_FIELD_UNUSED, 	QQ_FIELD_STRING, "pg_sn",	"Pager Serial Num", NULL, 0 },
-	{ QQ_FIELD_UNUSED, 	QQ_FIELD_STRING, "pg_num",	"Pager Num", NULL, 0 },
-	{ QQ_FIELD_UNUSED, 	QQ_FIELD_STRING, "pg_sp",	"Pager Serivce Provider", NULL, 0 },
-	{ QQ_FIELD_UNUSED, 	QQ_FIELD_STRING, "pg_sta",	"Pager Station Num", NULL, 0 },
-	{ QQ_FIELD_UNUSED, 	QQ_FIELD_STRING, "pg_type",	"Pager Type", NULL, 0 },
 	{ QQ_FIELD_BASE, 	QQ_FIELD_STRING, "occupation", 	N_("Occupation"), NULL, 0 },
 	{ QQ_FIELD_CONTACT, 	QQ_FIELD_STRING, "homepage", 	N_("Homepage"), NULL, 0 },
-	{ QQ_FIELD_BASE, 	QQ_FIELD_BOOL, 	"auth", 	N_("Authorize adding"), NULL, 0 },
-	{ QQ_FIELD_UNUSED, 	QQ_FIELD_STRING, "unknow1",	"Unknow1", NULL, 0 },
-	{ QQ_FIELD_UNUSED, 	QQ_FIELD_STRING, "unknow2",	"Unknow2", NULL, 0 },
+	{ QQ_FIELD_ADDR, 	QQ_FIELD_NUM, "country_code", 	N_("Country/Region Code"), NULL, 0 },
 	{ QQ_FIELD_UNUSED, 	QQ_FIELD_STRING, "face",	"Face", NULL, 0 },
 	{ QQ_FIELD_CONTACT, 	QQ_FIELD_STRING, "mobile",	N_("Cellphone Number"), NULL, 0 },
-	{ QQ_FIELD_UNUSED, 	QQ_FIELD_STRING, "mobile_type", "Cellphone Type", NULL, 0 },
+	{ QQ_FIELD_CONTACT, 	QQ_FIELD_CHOICE, "privacy",	"Privacy Settings", privacy_sets, 0 },
 	{ QQ_FIELD_BASE, 	QQ_FIELD_MULTI,  "intro", 	N_("Personal Introduction"), NULL, 0 },
-	{ QQ_FIELD_ADDR, 	QQ_FIELD_STRING, "city",	N_("City/Area"), NULL, 0 },
-	{ QQ_FIELD_UNUSED, 	QQ_FIELD_STRING, "unknow3",	"Unknow3", NULL, 0 },
-	{ QQ_FIELD_UNUSED, 	QQ_FIELD_STRING, "unknow4",	"Unknow4", NULL, 0 },
-	{ QQ_FIELD_UNUSED, 	QQ_FIELD_STRING, "unknow5",	"Unknow5", NULL, 0 },
-	{ QQ_FIELD_UNUSED, 	QQ_FIELD_CHOICE, "pub_mobile",	N_("Publish Mobile"), publish_types, QQ_PUBLISH_SIZE },
-	{ QQ_FIELD_CONTACT, 	QQ_FIELD_CHOICE, "pub_contact",	N_("Publish Contact"), publish_types, QQ_PUBLISH_SIZE },
 	{ QQ_FIELD_EXT, 	QQ_FIELD_STRING, "college",	N_("College"), NULL, 0 },
 	{ QQ_FIELD_EXT, 	QQ_FIELD_CHOICE, "horoscope",	N_("Horoscope"), horoscope_names, QQ_HOROSCOPE_SIZE },
 	{ QQ_FIELD_EXT, 	QQ_FIELD_CHOICE, "zodiac",	N_("Zodiac"), zodiac_names, QQ_ZODIAC_SIZE },
 	{ QQ_FIELD_EXT, 	QQ_FIELD_CHOICE, "blood",	N_("Blood"), blood_types, QQ_BLOOD_SIZE },
-	{ QQ_FIELD_UNUSED, 	QQ_FIELD_STRING, "qq_show",	"QQ Show", NULL, 0 },
-	{ QQ_FIELD_UNUSED, 	QQ_FIELD_STRING, "unknow6",	"Unknow6", NULL, 0 },
-	{ QQ_FIELD_UNUSED, 	QQ_FIELD_STRING, "LAST_2005",	"LAST_2005", NULL, 0 }
+	{ QQ_FIELD_ADDR, 	QQ_FIELD_TIME, "birth", 	N_("Birthday"), NULL, 0 },
+	{ QQ_FIELD_UNUSED, 	QQ_FIELD_CHOICE, "country_province_city",	"Country Province City", NULL, 0 },
+	{ QQ_FIELD_UNUSED, 	QQ_FIELD_CHOICE, "1st_lang",	"1st Language", NULL, 0 },
+	{ QQ_FIELD_UNUSED, 	QQ_FIELD_CHOICE, "2nd_lang",	"2nd Language", NULL, 0 },
+	{ QQ_FIELD_UNUSED, 	QQ_FIELD_CHOICE, "3rd_lang",	"3rd Language", NULL, 0 },
+	{ QQ_FIELD_BASE, 	QQ_FIELD_NUM, "age", 	N_("Age"), NULL, 0 },
+	{ QQ_FIELD_UNUSED, 	QQ_FIELD_CHOICE, "vip",	"VIP", NULL, 0 },
+	{ QQ_FIELD_UNUSED, 	QQ_FIELD_STRING, "client",	"Client", NULL, 0 },
 };
 
 typedef struct _modify_info_request {
 	PurpleConnection *gc;
 	int iclass;
-	gchar **segments;
+	guint8 *data;
+	guint16 info_num;
 } modify_info_request;
 
 #ifdef DEBUG
@@ -177,92 +185,156 @@ static void info_debug(gchar **segments)
 }
 #endif
 
-static void info_display_only(PurpleConnection *gc, gchar **segments)
+static void info_display_only(PurpleConnection *gc, guint8 *data)
 {
 	PurpleNotifyUserInfo *user_info;
-	gchar *utf8_value;
-	int index;
-	int choice_num;
+	gchar *value;
+	guint uid;
+	gchar *who;
+	guint index;
+	guint16 num;
+	guint8 choice_num;
+	guint bytes;
+	guint16 size;
+	guint8 * info;
+	GDate g_date;
 
 	user_info = purple_notify_user_info_new();
 
-	for (index = 1; segments[index] != NULL && index < QQ_INFO_LAST; index++) {
+	bytes = 3;
+	bytes += qq_get32(&uid, data+bytes);
+	who = uid_to_purple_name(uid);
+	value = g_strdup_printf("%d", uid);
+	purple_notify_user_info_add_pair(user_info, _(field_infos[0].text), value);
+	g_free(value);
+
+	bytes += 4;
+	bytes += qq_get16(&num, data+bytes);
+
+	for (index=1; index<num; ++index)
+	{
+		bytes += 2;
+		bytes += qq_get16(&size, data+bytes);
+		info = (guint8 *)g_alloca(size);
+		bytes += qq_getdata(info, size, data+bytes);
+
+
 		if (field_infos[index].iclass == QQ_FIELD_UNUSED) {
 			continue;
 		}
 		switch (field_infos[index].type) {
-			case QQ_FIELD_BOOL:
-				purple_notify_user_info_add_pair(user_info, _(field_infos[index].text),
-					strtol(segments[index], NULL, 10) ? _("True") : _("False"));
-				break;
-			case QQ_FIELD_CHOICE:
-				choice_num = strtol(segments[index], NULL, 10);
-				if (choice_num < 0 || choice_num >= field_infos[index].choice_size) {
-					choice_num = 0;
-				}
-
-				purple_notify_user_info_add_pair(user_info, _(field_infos[index].text), field_infos[index].choice[choice_num]);
-				break;
-			case QQ_FIELD_LABEL:
-			case QQ_FIELD_STRING:
-			case QQ_FIELD_MULTI:
-			default:
-				if (strlen(segments[index]) != 0) {
-					utf8_value = qq_to_utf8(segments[index], QQ_CHARSET_DEFAULT);
-					purple_notify_user_info_add_pair(user_info, _(field_infos[index].text), utf8_value);
-					g_free(utf8_value);
-				}
-				break;
+		case QQ_FIELD_BOOL:
+			purple_notify_user_info_add_pair(user_info, _(field_infos[index].text),
+				(guint8)*info? _("True") : _("False"));
+			break;
+		case QQ_FIELD_CHOICE:
+			choice_num = (guint8)*info;
+			if (choice_num < 0 || choice_num >= field_infos[index].choice_size) {
+				choice_num = 0;
+			}
+			purple_notify_user_info_add_pair(user_info, _(field_infos[index].text), field_infos[index].choice[choice_num]);
+			break;
+		case QQ_FIELD_NUM:
+			value = g_strdup_printf("%d", (guint8)*info);
+			purple_notify_user_info_add_pair(user_info, _(field_infos[index].text), value);
+			g_free(value);
+			break;
+		case QQ_FIELD_TIME:
+			g_date_set_time_t (&g_date, g_ntohl((guint)*info));
+			value = g_new0(gchar, 16);
+			g_date_strftime(value, 16, "%Y-%m-%d", &g_date);
+			purple_notify_user_info_add_pair(user_info, _(field_infos[index].text), value);
+			g_free(value);
+			break;
+		case QQ_FIELD_LABEL:
+		case QQ_FIELD_STRING:
+		case QQ_FIELD_MULTI:
+		default:
+			if (size) {
+				value = (gchar *)g_malloc0(size+1);
+				g_memmove(value, info, size);
+				purple_notify_user_info_add_pair(user_info, _(field_infos[index].text), value);
+				g_free(value);
+			} else {
+				purple_notify_user_info_add_pair(user_info, _(field_infos[index].text), "");
+			}
+			break;
 		}
 	}
-
-	purple_notify_userinfo(gc, segments[0], user_info, NULL, NULL);
+	purple_notify_userinfo(gc, who, user_info, NULL, NULL);
 
 	purple_notify_user_info_destroy(user_info);
-	g_strfreev(segments);
 }
 
-void qq_request_buddy_info(PurpleConnection *gc, UID uid,
-		UPDCLS update_class, int action)
+
+void qq_request_buddy_info(PurpleConnection *gc, guint32 uid,
+		guint32 update_class, int action)
 {
-	gchar raw_data[16] = {0};
+	guint8 raw_data[1024];
+	guint bytes;
+	static guint8 info[] = {
+		0x00, 0x1A, 0x4E, 0x22, 0x4E, 0x25, 0x4E, 0x26, 
+		0x4E, 0x27, 0x4E, 0x29, 0x4E, 0x2A, 0x4E, 0x2B, 
+		0x4E, 0x2C, 0x4E, 0x2D, 0x4E, 0x2E, 0x4E, 0x2F, 
+		0x4E, 0x30, 0x4E, 0x31, 0x4E, 0x33, 0x4E, 0x35, 
+		0x4E, 0x36, 0x4E, 0x37, 0x4E, 0x38, 0x4E, 0x3F, 
+		0x4E, 0x40, 0x4E, 0x41, 0x4E, 0x42, 0x4E, 0x43, 
+		0x4E, 0x45, 0x52, 0x0B, 0x52, 0x0F
+	};
 
 	g_return_if_fail(uid != 0);
 
-	g_snprintf(raw_data, sizeof(raw_data), "%u", uid);
-	qq_send_cmd_mess(gc, QQ_CMD_GET_BUDDY_INFO, (guint8 *) raw_data, strlen(raw_data),
+	bytes = 0;
+	bytes += qq_put16(raw_data+bytes, 0x0001);
+	bytes += qq_put32(raw_data+bytes, uid);
+	memset(raw_data+bytes, 0, 22);
+	bytes += 22;
+	bytes += qq_putdata(raw_data+bytes, info, sizeof(info));
+
+	qq_send_cmd_mess(gc, QQ_CMD_GET_BUDDY_INFO, raw_data, bytes,
 			update_class, action);
 }
 
 /* send packet to modify personal information */
-static void request_change_info(PurpleConnection *gc, gchar **segments)
+void request_change_info(PurpleConnection *gc, guint8 *data, guint8 *token, guint token_size)
 {
 	gint bytes = 0;
 	guint8 raw_data[MAX_PACKET_SIZE - 128] = {0};
-	guint8 bar;
-	gchar *join;
-
-	g_return_if_fail(segments != NULL);
-
-	bar = 0x1f;
+	guint i = 0;
+	guint16 size;
 
-	bytes += qq_put8(raw_data + bytes, bar);
-	bytes += qq_put8(raw_data + bytes, bar);
+	g_return_if_fail(data != NULL);
 
-	/* important! skip the first uid entry */
-	join = g_strjoinv("\x1f", segments + 1);
-	bytes += qq_putdata(raw_data + bytes, (guint8 *)join, strlen(join));
-	g_free(join);
-
-	bytes += qq_put8(raw_data + bytes, bar);
+	if (!token_size || token == NULL)
+	{
+		qq_request_auth_token(gc, 0x01, 0x0007, (guint32)data, 0);
+		return;
+	}
+	
 
+	bytes += qq_put8(raw_data + bytes, (guint8)token_size);
+	bytes += qq_putdata(raw_data + bytes, token, token_size);
+	bytes += qq_put16(raw_data + bytes, 0x0001);
+	memset(raw_data+bytes, 0, 22);
+	bytes += 22;
+	bytes += qq_put16(raw_data + bytes, 0x0001);
+
+	while ( (guint8) *(data+i) == 0x4E )
+	{
+		i += 2;		//4E xx
+		i += qq_get16(&size, data+i);
+		bytes += qq_putdata(raw_data+bytes, data+i-4, size+4);
+		i += size;
+	}
 	/* qq_show_packet("request_modify_info", raw_data, bytes); */
 	qq_send_cmd(gc, QQ_CMD_UPDATE_INFO, raw_data, bytes);
+		
+	g_free(data);
 }
 
 static void info_modify_cancel_cb(modify_info_request *info_request)
 {
-	g_strfreev(info_request->segments);
+	g_free(info_request->data);
 	g_free(info_request);
 }
 
@@ -270,106 +342,156 @@ static void info_modify_cancel_cb(modify
 static void info_modify_ok_cb(modify_info_request *info_request, PurpleRequestFields *fields)
 {
 	PurpleConnection *gc;
-	gchar **segments;
-	int index;
-	const char *utf8_str;
-	gchar *value;
-	int choice_num;
+	guint8 *data;
+	guint16 num;
+	guint bytes=0;
+	guint index;
+	guint16 size;
+	gchar *str;
+	guint32 value;
+	guint8 *newdata;
+	guint datasize;
+	GDate date;
+	struct tm tm;
 
 	gc = info_request->gc;
 	g_return_if_fail(gc != NULL);
-	segments = info_request->segments;
-	g_return_if_fail(segments != NULL);
+	data = info_request->data;
+	g_return_if_fail(data != NULL);
+	num = info_request->info_num;
+
+	for (index = 1; index < num; ++index) {
+		bytes += 2;
+		bytes += qq_get16(&size, data+bytes);
 
-	for (index = 1; segments[index] != NULL && index < QQ_INFO_LAST; index++) {
 		if (field_infos[index].iclass == QQ_FIELD_UNUSED) {
 			continue;
 		}
 		if (!purple_request_fields_exists(fields, field_infos[index].id)) {
 			continue;
 		}
+		
 		switch (field_infos[index].type) {
 			case QQ_FIELD_BOOL:
 				value = purple_request_fields_get_bool(fields, field_infos[index].id)
-						? g_strdup("1") : g_strdup("0");
-				g_free(segments[index]);
-				segments[index] = value;
+						? 0x01 : 0x00;
+				if (size==1) {
+					bytes += qq_put8(data+bytes, (guint8)value);
+					datasize += size+4;
+					newdata = (guint8 *)g_realloc(newdata, datasize);
+					g_memmove(newdata+datasize-size-4, data+bytes-4-size, 4+size);
+				}
 				break;
 			case QQ_FIELD_CHOICE:
-				choice_num = purple_request_fields_get_choice(fields, field_infos[index].id);
-				if (choice_num < 0 || choice_num >= field_infos[index].choice_size)	choice_num = 0;
-
-				if (index == QQ_INFO_GENDER) {
-					/* QQ Server only recept gender in Chinese */
-					value = g_strdup(genders_zh[choice_num]);
-				} else {
-					value = g_strdup_printf("%d", choice_num);
+				value = purple_request_fields_get_choice(fields, field_infos[index].id);
+				if (value < 0 || value >= field_infos[index].choice_size)	value = 0;
+				if (size==1) {
+					bytes += qq_put8(data+bytes, (guint8)value);
+					datasize += size+4;
+					newdata = (guint8 *)g_realloc(newdata, datasize);
+					g_memmove(newdata+datasize-size-4, data+bytes-4-size, 4+size);
+				}
+				break;
+			case QQ_FIELD_NUM:
+				value = purple_request_fields_get_integer(fields, field_infos[index].id)
+					? 0x01 : 0x00;
+				if (size==1) {
+					bytes += qq_put8(data+bytes, (guint8)value);
+					datasize += size+4;
+					newdata = (guint8 *)g_realloc(newdata, datasize);
+					g_memmove(newdata+datasize-size-4, data+bytes-4-size, 4+size);
+				}
+				break;
+			case QQ_FIELD_TIME:
+				str = purple_request_fields_get_string(fields, field_infos[index].id);
+				if (str != NULL) {
+					g_date_set_parse(&date, str);
+					if (g_date_valid (&date))
+					{
+						memset(&tm, 0, sizeof(tm));
+						tm.tm_mon = date.month - 1;
+						tm.tm_mday = date.day;
+						tm.tm_year = date.year - 1900;
+						value = mktime(&tm);
+						if (size==4)
+						{
+							bytes += qq_put32(data+bytes, value);
+							datasize += size+4;
+							newdata = (guint8 *)g_realloc(newdata, datasize);
+							g_memmove(newdata+datasize-size-4, data+bytes-size-4, size+4);
+							g_free(str);
+							break;
+						}				
+					}
+					g_free(str);
 				}
-				g_free(segments[index]);
-				segments[index] = value;
+				
+				newdata = (guint8 *)g_realloc(newdata, datasize+4+1);
+				qq_put16(newdata+datasize, (guint16)*(data+bytes-4));
+				qq_put16(newdata+datasize+2, 0x0001);
+				qq_put8(newdata+datasize+4,0x00);
+
+				datasize += 4+1;
+				bytes += size;
 				break;
 			case QQ_FIELD_LABEL:
 			case QQ_FIELD_STRING:
 			case QQ_FIELD_MULTI:
 			default:
-				utf8_str = purple_request_fields_get_string(fields, field_infos[index].id);
-				if (utf8_str == NULL) {
-					value = g_strdup("-");
-				} else {
-					value = utf8_to_qq(utf8_str, QQ_CHARSET_DEFAULT);
-					if (value == NULL) value = g_strdup("-");
+				str = purple_request_fields_get_string(fields, field_infos[index].id);
+				if (str == NULL) {
+					str = g_strdup("-");
 				}
-				g_free(segments[index]);
-				segments[index] = value;
+
+				newdata = (guint8 *)g_realloc(newdata, datasize+strlen(str));
+				qq_put16(newdata+datasize, (guint16) *(data+bytes-4));
+				qq_put16(newdata+datasize+2, strlen(str));
+				g_memmove(newdata+datasize+4, str, strlen(str));
+
+				datasize += strlen(str)+4;
+				bytes += size;
+				g_free(str);;
 				break;
 		}
 	}
-	request_change_info(gc, segments);
+	request_change_info(gc, newdata, NULL, 0);
 
-	g_strfreev(segments);
+	g_free(data);
 	g_free(info_request);
 }
 
-static void field_request_new(PurpleRequestFieldGroup *group, gint index, gchar **segments)
+static void field_request_new(PurpleRequestFieldGroup *group, guint index, guint8 *data)
 {
 	PurpleRequestField *field;
-	gchar *utf8_value;
-	int choice_num;
-	int i;
-
-	g_return_if_fail(index >=0 && segments[index] != NULL && index < QQ_INFO_LAST);
-
+	gchar *value;
+	guint choice_num;
+	guint i;
+	guint8 * info;
+	guint bytes=0;
+	guint16 size;
+	GDate g_date;
+
+	g_return_if_fail(index > 0);
+
+	for (i=0; i < index; ++i) {
+		bytes += 2;
+		bytes += qq_get16(&size, data+bytes);
+		info = (guint8 *)g_alloca(size);
+		bytes += qq_getdata(info, size, data+bytes);
+	}
 	switch (field_infos[index].type) {
-		case QQ_FIELD_STRING:
-		case QQ_FIELD_MULTI:
-			utf8_value = qq_to_utf8(segments[index], QQ_CHARSET_DEFAULT);
-			if (field_infos[index].type == QQ_FIELD_STRING) {
-				field = purple_request_field_string_new(
-					field_infos[index].id, _(field_infos[index].text), utf8_value, FALSE);
-			} else {
-				field = purple_request_field_string_new(
-					field_infos[index].id, _(field_infos[index].text), utf8_value, TRUE);
-			}
-			purple_request_field_group_add_field(group, field);
-			g_free(utf8_value);
-			break;
 		case QQ_FIELD_BOOL:
 			field = purple_request_field_bool_new(
 				field_infos[index].id, _(field_infos[index].text),
-				strtol(segments[index], NULL, 10) ? TRUE : FALSE);
+				(guint8)*info);
 			purple_request_field_group_add_field(group, field);
 			break;
 		case QQ_FIELD_CHOICE:
-			choice_num = strtol(segments[index], NULL, 10);
-			if (choice_num < 0 || choice_num >= field_infos[index].choice_size)	choice_num = 0;
-
-			if (index == QQ_INFO_GENDER && strlen(segments[index]) != 0) {
-				for (i = 0; i < QQ_GENDER_SIZE; i++) {
-					if (strcmp(segments[index], genders_zh[i]) == 0) {
-						choice_num = i;
-					}
-				}
+			choice_num = (gint8)*info;
+			if (choice_num < 0 || choice_num >= field_infos[index].choice_size) {
+				choice_num = 0;
 			}
+
 			field = purple_request_field_choice_new(
 				field_infos[index].id, _(field_infos[index].text), choice_num);
 			for (i = 0; i < field_infos[index].choice_size; i++) {
@@ -377,21 +499,49 @@ static void field_request_new(PurpleRequ
 			}
 			purple_request_field_group_add_field(group, field);
 			break;
+		case QQ_FIELD_NUM:
+			value = g_strdup_printf("%d", (guint8)*info);
+			field = purple_request_field_string_new(field_infos[index].id, _(field_infos[index].text), value, FALSE);
+			purple_request_field_group_add_field(group, field);
+			g_free(value);
+			break;
+		case QQ_FIELD_TIME:
+			g_date_set_time_t (&g_date, g_ntohl((guint)*info));
+			value = g_new0(gchar, 16);
+			field = purple_request_field_string_new(field_infos[index].id, _(field_infos[index].text), value, FALSE);
+			purple_request_field_group_add_field(group, field);
+			g_free(value);
+			break;
+		case QQ_FIELD_STRING:
+		case QQ_FIELD_MULTI:
 		case QQ_FIELD_LABEL:
 		default:
-			field = purple_request_field_label_new(field_infos[index].id, segments[index]);
+			value = (gchar *)g_malloc0(size+1);
+			g_memmove(value, info, size);
+			if (field_infos[index].type == QQ_FIELD_STRING) {
+				field = purple_request_field_string_new(
+					field_infos[index].id, _(field_infos[index].text), value, FALSE);
+			} else {
+				field = purple_request_field_string_new(
+					field_infos[index].id, _(field_infos[index].text), value, TRUE);
+			}
 			purple_request_field_group_add_field(group, field);
+			g_free(value);
 			break;
 	}
 }
 
-static void info_modify_dialogue(PurpleConnection *gc, gchar **segments, int iclass)
+static void info_modify_dialogue(PurpleConnection *gc, guint8 *data, int iclass)
 {
 	PurpleRequestFieldGroup *group;
 	PurpleRequestFields *fields;
 	modify_info_request *info_request;
 	gchar *utf8_title, *utf8_prim;
-	int index;
+	guint index;
+	guint8 bytes;
+	guint uid;
+	guint16 num;
+	guint16 size;
 
 	/* Keep one dialog once a time */
 	purple_request_close_with_handle(gc);
@@ -400,37 +550,47 @@ static void info_modify_dialogue(PurpleC
 	group = purple_request_field_group_new(NULL);
 	purple_request_fields_add_group(fields, group);
 
-	for (index = 1; segments[index] != NULL && index < QQ_INFO_LAST; index++) {
+	bytes = 3;
+	bytes += qq_get32(&uid, data+bytes);
+
+	bytes += 4;
+	bytes += qq_get16(&num, data+bytes);
+
+	for (index = 1; index < num; ++index) {
 		if (field_infos[index].iclass != iclass) {
 			continue;
 		}
-		field_request_new(group, index, segments);
+		field_request_new(group, index, data+bytes);
+		bytes += 2;
+		bytes += qq_get16(&size, data+bytes);
+		bytes += size;
 	}
 
 	switch (iclass) {
 		case QQ_FIELD_CONTACT:
 			utf8_title = g_strdup(_("Modify Contact"));
-			utf8_prim = g_strdup_printf("%s for %s", _("Modify Contact"), segments[0]);
+			utf8_prim = g_strdup_printf("%d for %d", _("Modify Contact"), uid);
 			break;
 		case QQ_FIELD_ADDR:
 			utf8_title = g_strdup(_("Modify Address"));
-			utf8_prim = g_strdup_printf("%s for %s", _("Modify Address"), segments[0]);
+			utf8_prim = g_strdup_printf("%d for %d", _("Modify Address"), uid);
 			break;
 		case QQ_FIELD_EXT:
 			utf8_title = g_strdup(_("Modify Extended Information"));
-			utf8_prim = g_strdup_printf("%s for %s", _("Modify Extended Information"), segments[0]);
+			utf8_prim = g_strdup_printf("%d for %d", _("Modify Extended Information"), uid);
 			break;
 		case QQ_FIELD_BASE:
 		default:
 			utf8_title = g_strdup(_("Modify Information"));
-			utf8_prim = g_strdup_printf("%s for %s", _("Modify Information"), segments[0]);
+			utf8_prim = g_strdup_printf("%d for %d", _("Modify Information"), uid);
 			break;
 	}
 
 	info_request = g_new0(modify_info_request, 1);
 	info_request->gc = gc;
 	info_request->iclass = iclass;
-	info_request->segments = segments;
+	info_request->data = data+13;
+	info_request->info_num = num;
 
 	purple_request_fields(gc,
 			utf8_title,
@@ -454,8 +614,7 @@ void qq_process_change_info(PurpleConnec
 
 	qd = (qq_data *) gc->proto_data;
 
-	data[data_len] = '\0';
-	if (qd->uid != atoi((gchar *) data)) {	/* return should be my uid */
+	if ((guint8) *(data+1) != 0x01) {
 		purple_debug_info("QQ", "Failed Updating info\n");
 		qq_got_message(gc, _("Could not change buddy information."));
 	}
@@ -615,29 +774,89 @@ void qq_update_buddy_icon(PurpleAccount
 	g_free(icon_path);
 }
 
-/* after getting info or modify myself, refresh the buddy list accordingly */
-static void update_buddy_info(PurpleConnection *gc, gchar **segments)
+/* process reply to get_info packet */
+void qq_process_get_buddy_info(guint8 *data, gint data_len, guint32 action, PurpleConnection *gc)
 {
-	PurpleBuddy *buddy = NULL;
-	qq_data *qd = NULL;
+	qq_data *qd;
+	gchar *icon_name;
 	qq_buddy_data *bd = NULL;
-	UID uid;
+	gint bytes;
+	guint32 uid;
+	guint8 ret;
+	guint16 num;
+	guint16 i;
+	guint16 flag;
+	guint16 size;
+	guint8 *info;
 	gchar *who;
-	gchar *alias_utf8;
-
+	gchar *nickname;
+	guint16 face;
+	guint8 age;
+	guint8 gender;
+	PurpleBuddy *buddy;
 	PurpleAccount *account = purple_connection_get_account(gc);
-	qd = (qq_data *)purple_connection_get_protocol_data(gc);
 
-	uid = strtoul(segments[QQ_INFO_UID], NULL, 10);
+	g_return_if_fail(data != NULL && data_len != 0);
+
+	qd = (qq_data *) gc->proto_data;
+
+	bytes = 2;
+	bytes += qq_get8(&ret, data+bytes);
+	if (ret!=0)
+	{
+		purple_debug_error("QQ", "Get Buddy Info Error!");
+		return;
+	}
+
+	bytes += qq_get32(&uid, data+bytes);
 	who = uid_to_purple_name(uid);
-	qq_filter_str(segments[QQ_INFO_NICK]);
-	alias_utf8 = qq_to_utf8(segments[QQ_INFO_NICK], QQ_CHARSET_DEFAULT);
+
+	bytes += 4;
+	bytes += qq_get16(&num, data+bytes);
+
+	for (i=0; i<num; ++i)
+	{
+		bytes += qq_get16(&flag, data+bytes);
+		bytes += qq_get16(&size, data+bytes);
+		info = (guint8 *)g_alloca(size);
+		bytes += qq_getdata(info, size, data+bytes);
+		
+		switch (flag)
+		{
+		case QQ_INFO_NICK:
+			nickname = (gchar *)g_malloc0(size+1);
+			g_memmove(nickname, info, size);
+			//qq_filter_str(nickname);
+			break;
+		case QQ_INFO_FACE:
+			face = g_ascii_strtoll((gchar *)info, NULL, 10);
+			if (action == QQ_BUDDY_INFO_SET_ICON) {
+				if (face != qd->my_icon) {
+					icon_name = g_strdup_printf("\x4E\x2F\x00\x04%d\x00", qd->my_icon);
+					/* send new face to server */
+					request_change_info(gc, (guint8 *)icon_name, NULL, 0);
+				}
+				g_free(data);
+				return;
+			}
+			break;
+		case QQ_INFO_AGE:
+			age = *info;
+			break;
+		case QQ_INFO_GENDER:
+			gender = *info;
+			if (gender>2) gender = 0;
+			break;
+		default:
+			break;
+		}
+	}
 
 	if (uid == qd->uid) {	/* it is me */
 		purple_debug_info("QQ", "Got my info\n");
-		qd->my_icon = strtol(segments[QQ_INFO_FACE], NULL, 10);
-		if (alias_utf8 != NULL) {
-			purple_account_set_alias(account, alias_utf8);
+		qd->my_icon = face;
+		if (nickname != NULL) {
+			purple_account_set_alias(account, nickname);
 		}
 		/* add me to buddy list */
 		buddy = qq_buddy_find_or_new(gc, uid);
@@ -650,125 +869,64 @@ static void update_buddy_info(PurpleConn
 	bd = purple_buddy_get_protocol_data(buddy);
 	/* purple_debug_info("QQ", "bd=%p\n", (void*)bd); */
 
-	if (bd == NULL || buddy == NULL) {
-		g_free(who);
-		g_free(alias_utf8);
-		return;
-	}
+	if (bd != NULL && buddy != NULL) {
+		/* update buddy list (including myself, if myself is the buddy) */
+		bd->age = age;
+		bd->gender = gender;
+		bd->face = face;
+
+		if (nickname != NULL) {
+			if (bd->nickname) g_free(bd->nickname);
+			bd->nickname = g_strdup(nickname);
+		}
+		bd->last_update = time(NULL);
 
-	/* update buddy list (including myself, if myself is the buddy) */
-	bd->age = strtol(segments[QQ_INFO_AGE], NULL, 10);
-	bd->gender = strtol(segments[QQ_INFO_GENDER], NULL, 10);
-	bd->face = strtol(segments[QQ_INFO_FACE], NULL, 10);
+		purple_blist_server_alias_buddy(buddy, bd->nickname);
 
-	if (alias_utf8 != NULL) {
-		if (bd->nickname) g_free(bd->nickname);
-		bd->nickname = g_strdup(alias_utf8);
+		/* convert face num from packet (0-299) to local face (1-100) */
+		qq_update_buddy_icon(gc->account, who, bd->face);
 	}
-	bd->last_update = time(NULL);
-
-	purple_blist_server_alias_buddy(buddy, bd->nickname);
-
-	/* convert face num from packet (0-299) to local face (1-100) */
-	qq_update_buddy_icon(gc->account, who, bd->face);
 
 	g_free(who);
-	g_free(alias_utf8);
-}
-
-/* process reply to get_info packet */
-void qq_process_get_buddy_info(guint8 *data, gint data_len, guint32 action, PurpleConnection *gc)
-{
-	qq_data *qd;
-	gchar **segments;
-	gint field_count;
-	gchar *icon_name;
-
-	g_return_if_fail(data != NULL && data_len != 0);
-
-	qd = (qq_data *) gc->proto_data;
-
-	if (qd->client_version >= 2008) {
-		field_count = QQ_INFO_LAST;
-	} else {
-		field_count = QQ_INFO_LAST_2007;
-	}
-	if (NULL == (segments = split_data(data, data_len, "\x1e", field_count)))
-		return;
-
-#ifdef DEBUG
-	info_debug(segments);
-#endif
-
-	if (action == QQ_BUDDY_INFO_SET_ICON) {
-		if (strtol(segments[QQ_INFO_FACE], NULL, 10) != qd->my_icon) {
-			icon_name = g_strdup_printf("%d", qd->my_icon);
-			g_free(segments[QQ_INFO_FACE]);
-			segments[QQ_INFO_FACE] = icon_name;
-
-			/* Update me in buddy list */
-			update_buddy_info(gc, segments);
-			/* send new face to server */
-			request_change_info(gc, segments);
-		}
-		g_strfreev(segments);
-		return;
-	}
-
-	update_buddy_info(gc, segments);
+	g_free(nickname);
+	
 	switch (action) {
 		case QQ_BUDDY_INFO_DISPLAY:
-			info_display_only(gc, segments);
+			info_display_only(gc, data);
 			break;
 		case QQ_BUDDY_INFO_SET_ICON:
 			g_return_if_reached();
 			break;
 		case QQ_BUDDY_INFO_MODIFY_BASE:
-			info_modify_dialogue(gc, segments, QQ_FIELD_BASE);
+			info_modify_dialogue(gc, data, QQ_FIELD_BASE);
 			break;
 		case QQ_BUDDY_INFO_MODIFY_EXT:
-			info_modify_dialogue(gc, segments, QQ_FIELD_EXT);
+			info_modify_dialogue(gc, data, QQ_FIELD_EXT);
 			break;
 		case QQ_BUDDY_INFO_MODIFY_ADDR:
-			info_modify_dialogue(gc, segments, QQ_FIELD_ADDR);
+			info_modify_dialogue(gc, data, QQ_FIELD_ADDR);
 			break;
 		case QQ_BUDDY_INFO_MODIFY_CONTACT:
-			info_modify_dialogue(gc, segments, QQ_FIELD_CONTACT);
+			info_modify_dialogue(gc, data, QQ_FIELD_CONTACT);
 			break;
 		default:
-			g_strfreev(segments);
 			break;
 	}
 	return;
 }
 
-void qq_request_get_level(PurpleConnection *gc, UID uid)
-{
-	qq_data *qd = (qq_data *) gc->proto_data;
-	guint8 buf[16] = {0};
-	gint bytes = 0;
-
-	if (qd->client_version >= 2007) {
-		bytes += qq_put8(buf + bytes, 0x02);
-	} else {
-		bytes += qq_put8(buf + bytes, 0x00);
-	}
-	bytes += qq_put32(buf + bytes, uid);
-	qq_send_cmd(gc, QQ_CMD_GET_LEVEL, buf, bytes);
-}
-
-void qq_request_get_level_2007(PurpleConnection *gc, UID uid)
+void qq_request_get_level(PurpleConnection *gc, guint32 uid)
 {
 	guint8 buf[16] = {0};
 	gint bytes = 0;
 
-	bytes += qq_put8(buf + bytes, 0x08);
+	bytes += qq_put8(buf + bytes, 0x88);
 	bytes += qq_put32(buf + bytes, uid);
 	bytes += qq_put8(buf + bytes, 0x00);
 	qq_send_cmd(gc, QQ_CMD_GET_LEVEL, buf, bytes);
 }
 
-void qq_request_get_buddies_level(PurpleConnection *gc, UPDCLS update_class)
+void qq_request_get_buddies_level(PurpleConnection *gc, guint32 update_class)
 {
 	qq_data *qd = (qq_data *) gc->proto_data;
 	PurpleBuddy *buddy;
@@ -781,7 +939,7 @@ void qq_request_get_buddies_level(Purple
 	buf = g_newa(guint8, MAX_PACKET_SIZE);
 
 	bytes = 0;
-	bytes += qq_put8(buf + bytes, 0x00);
+	bytes += qq_put8(buf + bytes, 0x89);
 	buddies = purple_find_buddies(purple_connection_get_account(gc), NULL);
 	for (it = buddies; it; it = it->next) {
 		buddy = it->data;
@@ -795,104 +953,55 @@ void qq_request_get_buddies_level(Purple
 	qq_send_cmd_mess(gc, QQ_CMD_GET_LEVEL, buf, bytes, update_class, 0);
 }
 
-static void process_level(PurpleConnection *gc, guint8 *data, gint data_len)
-{
-	gint bytes = 0;
-	UID uid;
-	guint32 onlineTime;
-	guint16 level, timeRemainder;
-	qq_buddy_data *bd;
-
-	while (data_len - bytes >= 12) {
-		bytes += qq_get32(&uid, data + bytes);
-		bytes += qq_get32(&onlineTime, data + bytes);
-		bytes += qq_get16(&level, data + bytes);
-		bytes += qq_get16(&timeRemainder, data + bytes);
-		purple_debug_info("QQ", "level: %d, uid %u, tmOnline: %d, tmRemainder: %d\n",
-				level, uid, onlineTime, timeRemainder);
-
-		bd = qq_buddy_data_find(gc, uid);
-		if (bd == NULL) {
-			purple_debug_error("QQ", "Got levels of %u not in my buddy list\n", uid);
-			continue;
-		}
-
-		bd->onlineTime = onlineTime;
-		bd->level = level;
-		bd->timeRemainder = timeRemainder;
-	}
-
-	if (bytes != data_len) {
-		purple_debug_error("QQ",
-				"Wrong format of Get levels. Truncate %d bytes.\n", data_len - bytes);
-	}
-}
-
-static void process_level_2007(PurpleConnection *gc, guint8 *data, gint data_len)
-{
-	gint bytes;
-	UID uid;
-	guint32 onlineTime;
-	guint16 level, timeRemainder;
-	qq_buddy_data *bd;
-	guint16 str_len;
-	gchar *str;
-	gchar *str_utf8;
-
-	bytes = 0;
-	bytes += qq_get32(&uid, data + bytes);
-	bytes += qq_get32(&onlineTime, data + bytes);
-	bytes += qq_get16(&level, data + bytes);
-	bytes += qq_get16(&timeRemainder, data + bytes);
-	purple_debug_info("QQ", "level: %d, uid %u, tmOnline: %d, tmRemainder: %d\n",
-			level, uid, onlineTime, timeRemainder);
-
-	bd = qq_buddy_data_find(gc, uid);
-	if (bd == NULL) {
-		purple_debug_error("QQ", "Got levels of %u not in my buddy list\n", uid);
-		return;
-	}
-
-	bd->onlineTime = onlineTime;
-	bd->level = level;
-	bd->timeRemainder = timeRemainder;
-
-	/* extend bytes in qq2007*/
-	bytes += 4;	/* skip 8 bytes */
-	/* qq_show_packet("Buddies level", data + bytes, data_len - bytes); */
-
-	do {
-		bytes += qq_get16(&str_len, data + bytes);
-		if (str_len <= 0 || bytes + str_len > data_len) {
-			purple_debug_error("QQ",
-					"Wrong format of Get levels. Truncate %d bytes.\n", data_len - bytes);
-			break;
-		}
-		str = g_strndup((gchar *)data + bytes, str_len);
-		bytes += str_len;
-		str_utf8 = qq_to_utf8(str, QQ_CHARSET_DEFAULT);
-		purple_debug_info("QQ", "%s\n", str_utf8);
-		g_free(str_utf8);
-		g_free(str);
-	} while (bytes < data_len);
-}
-
 void qq_process_get_level_reply(guint8 *data, gint data_len, PurpleConnection *gc)
 {
 	gint bytes;
 	guint8 sub_cmd;
+	guint32 uid, onlineTime;
+	guint16 level, activeDays;
+	qq_buddy_data *bd;
+	qq_data * qd = (qq_data *) gc->proto_data;
 
 	bytes = 0;
 	bytes += qq_get8(&sub_cmd, data + bytes);
 	switch (sub_cmd) {
-		case 0x08:
-			process_level_2007(gc, data + bytes, data_len - bytes);
+		case 0x88:
+			if (data_len - bytes >= 12) {
+				bytes += qq_get32(&uid, data + bytes);
+				bytes += qq_get32(&onlineTime, data + bytes);
+				bytes += qq_get16(&level, data + bytes);
+				bytes += qq_get16(&activeDays, data + bytes);
+				
+				if (uid == qd->uid)
+				{				
+					purple_debug_info("QQ", "level: %d, uid %u, tmOnline: %d, tmactiveDays: %d\n",
+						level, uid, onlineTime, activeDays);
+					qd->onlineTime = onlineTime;
+					qd->level = level;
+					qd->activeDays = activeDays;
+				}
+			}
 			break;
-		case 0x00:
-		case 0x02:
-		default:
-			process_level(gc, data + bytes, data_len - bytes);
+		case 0x89:
+			while (data_len - bytes >= 12) {
+				bytes += qq_get32(&uid, data + bytes);
+				bytes += qq_get16(&level, data + bytes);
+				bytes += 2;
+				purple_debug_info("QQ", "level: %d, uid %u \n",
+					level, uid);
+
+				bd = qq_buddy_data_find(gc, uid);
+				if (bd == NULL) {
+					purple_debug_error("QQ", "Got levels of %u not in my buddy list\n", uid);
+					continue;
+				}
+
+				bd->level = level;
+			}
 			break;
+		default:
+			purple_debug_error("QQ",
+				"Unknown CMD 0x%X  of Get levels.", sub_cmd);
 	}
 }
 
diff -urp libpurple/protocols/qq/buddy_info.h libpurple/protocols/qq/buddy_info.h
--- libpurple/protocols/qq/buddy_info.h	2011-02-07 11:42:12.000000000 +0800
+++ libpurple/protocols/qq/buddy_info.h	2011-02-24 17:38:52.000127002 +0800
@@ -78,15 +78,16 @@ gchar *qq_get_icon_name(gint face);
 gchar *qq_get_icon_path(gchar *icon_name);
 void qq_change_icon_cb(PurpleConnection *gc, const char *filepath);
 
-void qq_request_buddy_info(PurpleConnection *gc, UID uid, UPDCLS update_class, int action);
+void qq_request_buddy_info(PurpleConnection *gc, guint32 uid,
+		guint32 update_class, int action);
 void qq_set_custom_icon(PurpleConnection *gc, PurpleStoredImage *img);
 void qq_process_change_info(PurpleConnection *gc, guint8 *data, gint data_len);
 void qq_process_get_buddy_info(guint8 *data, gint data_len, guint32 action, PurpleConnection *gc);
 
-void qq_request_get_level(PurpleConnection *gc, UID uid);
-void qq_request_get_level_2007(PurpleConnection *gc, UID uid);
-void qq_request_get_buddies_level(PurpleConnection *gc, UPDCLS update_class);
+void qq_request_get_level(PurpleConnection *gc, guint32 uid);
+void qq_request_get_buddies_level(PurpleConnection *gc, guint32 update_class);
 void qq_process_get_level_reply(guint8 *buf, gint buf_len, PurpleConnection *gc);
 
 void qq_update_buddy_icon(PurpleAccount *account, const gchar *who, gint face);
+void request_change_info(PurpleConnection *gc, guint8 *data, guint8 *token, guint token_size);
 #endif
diff -urp libpurple/protocols/qq/buddy_list.c libpurple/protocols/qq/buddy_list.c
--- libpurple/protocols/qq/buddy_list.c	2011-02-07 11:42:12.000000000 +0800
+++ libpurple/protocols/qq/buddy_list.c	2011-02-24 17:38:51.903460334 +0800
@@ -41,8 +41,6 @@
 
 #include "qq_network.h"
 
-#define QQ_GET_ONLINE_BUDDY_02          0x02
-#define QQ_GET_ONLINE_BUDDY_03          0x03	/* unknown function */
 
 typedef struct _qq_buddy_online {
 	guint16 unknown1;
@@ -53,7 +51,7 @@ typedef struct _qq_buddy_online {
 } qq_buddy_online;
 
 /* get a list of online_buddies */
-void qq_request_get_buddies_online(PurpleConnection *gc, guint8 position, UPDCLS update_class)
+void qq_request_get_buddies_online(PurpleConnection *gc, guint8 position, guint32 update_class)
 {
 	guint8 *raw_data;
 	gint bytes = 0;
@@ -64,7 +62,7 @@ void qq_request_get_buddies_online(Purpl
 	 * only 0x02 and 0x03 returns info from server, other valuse all return 0xff
 	 * I can also only send the first byte (0x02, or 0x03)
 	 * and the result is the same */
-	bytes += qq_put8(raw_data + bytes, QQ_GET_ONLINE_BUDDY_02);
+	bytes += qq_put8(raw_data + bytes, 0x02);
 	/* 001-001 seems it supports 255 online buddies at most */
 	bytes += qq_put8(raw_data + bytes, position);
 	/* 002-002 */
@@ -77,7 +75,7 @@ void qq_request_get_buddies_online(Purpl
 
 /* position starts with 0x0000,
  * server may return a position tag if list is too long for one packet */
-void qq_request_get_buddies(PurpleConnection *gc, guint16 position, UPDCLS update_class)
+void qq_request_get_buddies_list(PurpleConnection *gc, guint16 position, guint32 update_class)
 {
 	qq_data *qd;
 	guint8 raw_data[16] = {0};
@@ -85,36 +83,17 @@ void qq_request_get_buddies(PurpleConnec
 
 	qd = (qq_data *) gc->proto_data;
 
-	/* 000-001 starting position, can manually specify */
-	bytes += qq_put16(raw_data + bytes, position);
-	/* before Mar 18, 2004, any value can work, and we sent 00
-	 * I do not know what data QQ server is expecting, as QQ2003iii 0304 itself
-	 * even can sending packets 00 and get no response.
-	 * Now I tested that 00,00,00,00,00,01 work perfectly
-	 * March 22, found the 00,00,00 starts to work as well */
-	bytes += qq_put8(raw_data + bytes, 0x00);
-	if (qd->client_version >= 2007) {
-		bytes += qq_put16(raw_data + bytes, 0x0000);
-	}
-
-	qq_send_cmd_mess(gc, QQ_CMD_GET_BUDDIES_LIST, raw_data, bytes, update_class, 0);
-}
+	
+	bytes += qq_put16(raw_data + bytes, 0x0100);
+	bytes += qq_put32(raw_data + bytes, 0x00000000);
+	bytes += qq_put32(raw_data + bytes, 0x00000002);
 
-/* get all list, buddies & Quns with groupsid support */
-void qq_request_get_buddies_and_rooms(PurpleConnection *gc, guint32 position, UPDCLS update_class)
-{
-	guint8 raw_data[16] = {0};
-	gint bytes = 0;
+	/* starting position, can manually specify */
+	bytes += qq_put16(raw_data+bytes, position);
 
-	/* 0x01 download, 0x02, upload */
-	bytes += qq_put8(raw_data + bytes, 0x01);
-	/* unknown 0x02 */
-	bytes += qq_put8(raw_data + bytes, 0x02);
-	/* unknown 00 00 00 00 */
-	bytes += qq_put32(raw_data + bytes, 0x00000000);
-	bytes += qq_put32(raw_data + bytes, position);
+	bytes += qq_put16(raw_data+bytes, 0);
 
-	qq_send_cmd_mess(gc, QQ_CMD_GET_BUDDIES_AND_ROOMS, raw_data, bytes, update_class, 0);
+	qq_send_cmd_mess(gc, QQ_CMD_GET_BUDDIES_LIST, raw_data, bytes, update_class, 0);
 }
 
 /* parse the data into qq_buddy_status */
@@ -140,13 +119,20 @@ static gint get_buddy_status(qq_buddy_st
 	/* 012-012: status */
 	bytes += qq_get8(&bs->status, data + bytes);
 	/* 013-014: client tag */
-	bytes += qq_get16(&bs->unknown3, data + bytes);
+	bytes += qq_get16(&bs->version, data + bytes);
 	/* 015-030: unknown key */
-	bytes += qq_getdata(&(bs->unknown_key[0]), QQ_KEY_LENGTH, data + bytes);
+	bytes += qq_getdata(bs->key, QQ_KEY_LENGTH, data + bytes);
+	/* 031-032: */
+	bytes += qq_get16(&bs->unknown3, data + bytes);
+	/* 033-033: ext_flag */
+	bytes += qq_get8(&bs->ext_flag, data + bytes);
+	/* 034-034: comm_flag */
+	bytes += qq_get8(&bs->comm_flag, data + bytes);
 
-	purple_debug_info("QQ", "Status:%d, uid: %u, ip: %s:%d, U: %d - %d - %04X\n",
+	purple_debug_info("QQ", "Status: %d, uid: %u, ip: %s:%d, Flag: 0x%X - 0x%X, U: %d - %d - %d, Ver: %04X\n",
 			bs->status, bs->uid, inet_ntoa(bs->ip), bs->port,
-			bs->unknown1, bs->unknown2, bs->unknown3);
+			bs->ext_flag, bs->comm_flag, 
+			bs->unknown1, bs->unknown2, bs->unknown3, bs->version);
 
 	return bytes;
 }
@@ -161,23 +147,17 @@ guint8 qq_process_get_buddies_online(gui
 	gchar *who;
 	PurpleBuddy *buddy;
 	qq_buddy_data *bd;
-	int entry_len = 38;
+	int entry_len = 42;
 
 	qq_buddy_status bs;
-	struct {
-		guint16 unknown1;
-		guint8 ext_flag;
-		guint8 comm_flag;
-		guint16 unknown2;
-		guint8 ending;		/* 0x00 */
-	} packet;
+	guint16 unknown;
+	guint8 ending;		/* 0x00 */
 
 	g_return_val_if_fail(data != NULL && data_len != 0, -1);
 
 	qd = (qq_data *) gc->proto_data;
 
 	/* qq_show_packet("Get buddies online reply packet", data, len); */
-	if (qd->client_version >= 2007)	entry_len += 4;
 
 	bytes = 0;
 	bytes += qq_get8(&position, data + bytes);
@@ -190,25 +170,18 @@ guint8 qq_process_get_buddies_online(gui
 			break;
 		}
 		memset(&bs, 0 ,sizeof(bs));
-		memset(&packet, 0 ,sizeof(packet));
 
 		/* set flag */
 		bytes_start = bytes;
 		/* based on one online buddy entry */
-		/* 000-030 qq_buddy_status */
+		/* 000-034 qq_buddy_status */
 		bytes += get_buddy_status(&bs, data + bytes);
-		/* 031-032: */
-		bytes += qq_get16(&packet.unknown1, data + bytes);
-		/* 033-033: ext_flag */
-		bytes += qq_get8(&packet.ext_flag, data + bytes);
-		/* 034-034: comm_flag */
-		bytes += qq_get8(&packet.comm_flag, data + bytes);
 		/* 035-036: */
-		bytes += qq_get16(&packet.unknown2, data + bytes);
+		bytes += qq_get16(&unknown, data + bytes);
 		/* 037-037: */
-		bytes += qq_get8(&packet.ending, data + bytes);	/* 0x00 */
-		/* skip 4 bytes in qq2007 */
-		if (qd->client_version >= 2007)	bytes += 4;
+		bytes += qq_get8(&ending, data + bytes);	/* 0x00 */
+
+		bytes += 4;
 
 		if (bs.uid == 0 || (bytes - bytes_start) != entry_len) {
 			purple_debug_error("QQ", "uid=0 or entry complete len(%d) != %d\n",
@@ -238,14 +211,14 @@ guint8 qq_process_get_buddies_online(gui
 		if(0 != fe->s->client_tag)
 			q_bud->client_tag = fe->s->client_tag;
 		*/
-		if (bd->status != bs.status || bd->comm_flag != packet.comm_flag) {
+		if (bd->status != bs.status || bd->comm_flag != bs.comm_flag) {
 			bd->status = bs.status;
-			bd->comm_flag = packet.comm_flag;
+			bd->comm_flag = bs.comm_flag;
 			qq_update_buddy_status(gc, bd->uid, bd->status, bd->comm_flag);
 		}
 		bd->ip.s_addr = bs.ip.s_addr;
 		bd->port = bs.port;
-		bd->ext_flag = packet.ext_flag;
+		bd->ext_flag = bs.ext_flag;
 		bd->last_update = time(NULL);
 		count++;
 	}
@@ -262,7 +235,7 @@ guint8 qq_process_get_buddies_online(gui
 
 
 /* process reply for get_buddies_list */
-guint16 qq_process_get_buddies(guint8 *data, gint data_len, PurpleConnection *gc)
+guint16 qq_process_get_buddies_list(guint8 *data, gint data_len, PurpleConnection *gc)
 {
 	qq_data *qd;
 	qq_buddy_data bd;
@@ -281,11 +254,13 @@ guint16 qq_process_get_buddies(guint8 *d
 		return -1;
 	}
 	/* qq_show_packet("QQ get buddies list", data, data_len); */
-	bytes = 0;
+	bytes = 10;
 	bytes += qq_get16(&position, data + bytes);
+	bytes += 5;
 	/* the following data is buddy list in this packet */
 	count = 0;
-	while (bytes < data_len) {
+	while (bytes < data_len-5) /* end with 04 4D XX XX XX */
+	{
 		memset(&bd, 0, sizeof(bd));
 		/* set flag */
 		buddy_bytes = bytes;
@@ -298,8 +273,8 @@ guint16 qq_process_get_buddies(guint8 *d
 		/* 007-007: gender */
 		bytes += qq_get8(&bd.gender, data + bytes);
 
-		nickname_len = qq_get_vstr(&bd.nickname, QQ_CHARSET_DEFAULT, data + bytes);
-		bytes += nickname_len;
+		bytes += nickname_len = qq_get_vstr(&bd.nickname, NULL, sizeof(guint8), data+bytes);
+
 		qq_filter_str(bd.nickname);
 
 		/* Fixme: merge following as 32bit flag */
@@ -307,12 +282,8 @@ guint16 qq_process_get_buddies(guint8 *d
 		bytes += qq_get8(&bd.ext_flag, data + bytes);
 		bytes += qq_get8(&bd.comm_flag, data + bytes);
 
-		if (qd->client_version >= 2007) {
-			bytes += 4;		/* skip 4 bytes */
-			bytes_expected = 16 + nickname_len;
-		} else {
-			bytes_expected = 12 + nickname_len;
-		}
+		bytes += 32-4;
+		bytes_expected = 40 + nickname_len;
 
 		if (bd.uid == 0 || (bytes - buddy_bytes) != bytes_expected) {
 			purple_debug_info("QQ",
@@ -339,16 +310,11 @@ guint16 qq_process_get_buddies(guint8 *d
 		qq_update_buddy_status(gc, bd.uid, bd.status, bd.comm_flag);
 
 		g_memmove(purple_buddy_get_protocol_data(buddy), &bd, sizeof(qq_buddy_data));
-		/* nickname has been copy to buddy_data do not free
-		   g_free(bd.nickname);
-		*/
-		/*qq_request_buddy_memo(gc, ((qq_buddy_data*)buddy->proto_data)->uid, 0, QQ_BUDDY_MEMO_GET);*/
-		qq_request_buddy_memo(gc, bd.uid, bd.uid, QQ_BUDDY_MEMO_GET);
 	}
 
 	if(bytes > data_len) {
 		purple_debug_error("QQ",
-				"qq_process_get_buddies: Dangerous error! maybe protocol changed, notify developers!\n");
+				"qq_process_get_buddies_list: Dangerous error! maybe protocol changed, notify developers!\n");
 	}
 
 	purple_debug_info("QQ", "Received %d buddies, nextposition=%u\n",
@@ -356,69 +322,6 @@ guint16 qq_process_get_buddies(guint8 *d
 	return position;
 }
 
-guint32 qq_process_get_buddies_and_rooms(guint8 *data, gint data_len, PurpleConnection *gc)
-{
-	gint i, j;
-	gint bytes;
-	guint8 sub_cmd, reply_code;
-	guint32 unknown, position;
-	UID uid;
-	guint8 type;
-	qq_room_data *rmd;
-
-	g_return_val_if_fail(data != NULL && data_len != 0, -1);
-
-	bytes = 0;
-	bytes += qq_get8(&sub_cmd, data + bytes);
-	g_return_val_if_fail(sub_cmd == 0x01, -1);
-
-	bytes += qq_get8(&reply_code, data + bytes);
-	if(0 != reply_code) {
-		purple_debug_warning("QQ", "qq_process_get_buddies_and_rooms, %d\n", reply_code);
-	}
-
-	bytes += qq_get32(&unknown, data + bytes);
-	bytes += qq_get32(&position, data + bytes);
-	/* the following data is all list in this packet */
-	i = 0;
-	j = 0;
-	while (bytes < data_len) {
-		/* 00-03: uid */
-		bytes += qq_get32(&uid, data + bytes);
-		/* 04: type 0x1:buddy 0x4:Qun */
-		bytes += qq_get8(&type, data + bytes);
-		/* 05: skip unknow 0x00 */
-		bytes += 1;
-		if (uid == 0 || (type != 0x1 && type != 0x4)) {
-			purple_debug_info("QQ", "Buddy entry, uid=%u, type=%d\n", uid, type);
-			continue;
-		}
-		if(0x1 == type) { /* a buddy */
-			/* don't do anything but count - buddies are handled by
-			 * qq_request_get_buddies */
-			++i;
-		} else { /* a group */
-			rmd = qq_room_data_find(gc, uid);
-			if(rmd == NULL) {
-				purple_debug_info("QQ", "Unknown room id %u\n", uid);
-				qq_send_room_cmd_only(gc, QQ_ROOM_CMD_GET_INFO, uid);
-			} else {
-				rmd->my_role = QQ_ROOM_ROLE_YES;
-			}
-			++j;
-		}
-	}
-
-	if(bytes > data_len) {
-		purple_debug_error("QQ",
-				"qq_process_get_buddies_and_rooms: Dangerous error! maybe protocol changed, notify developers!\n");
-	}
-
-	purple_debug_info("QQ", "Received %d buddies and %d groups, nextposition=%u\n", i, j, (guint) position);
-	return position;
-}
-
-#define QQ_MISC_STATUS_HAVING_VIIDEO      0x00000001
 #define QQ_CHANGE_ONLINE_STATUS_REPLY_OK 	0x30	/* ASCII value of "0" */
 
 /* TODO: figure out what's going on with the IP region. Sometimes I get valid IP addresses,
@@ -439,15 +342,13 @@ static guint8  get_status_from_purple(Pu
 		ret = QQ_BUDDY_ONLINE_INVISIBLE;
 	} else if (purple_presence_is_status_primitive_active(presence, PURPLE_STATUS_UNAVAILABLE))
 	{
-		if (qd->client_version >= 2007) {
+		if (qd->client_version >= 2010) {
 			ret = QQ_BUDDY_ONLINE_BUSY;
-		} else {
-			ret = QQ_BUDDY_ONLINE_INVISIBLE;
 		}
 	} else if (purple_presence_is_status_primitive_active(presence, PURPLE_STATUS_AWAY)
-			|| purple_presence_is_status_primitive_active(presence, PURPLE_STATUS_EXTENDED_AWAY)
-			|| purple_presence_is_status_primitive_active(presence, PURPLE_STATUS_UNAVAILABLE)) {
-		ret = QQ_BUDDY_ONLINE_AWAY;
+		|| purple_presence_is_status_primitive_active(presence, PURPLE_STATUS_EXTENDED_AWAY)
+		|| purple_presence_is_status_primitive_active(presence, PURPLE_STATUS_UNAVAILABLE)) {
+			ret = QQ_BUDDY_ONLINE_AWAY;
 	} else {
 		ret = QQ_BUDDY_ONLINE_NORMAL;
 	}
@@ -455,13 +356,13 @@ static guint8  get_status_from_purple(Pu
 }
 
 /* send a packet to change my online status */
-void qq_request_change_status(PurpleConnection *gc, UPDCLS update_class)
+void qq_request_change_status(PurpleConnection *gc, guint32 update_class)
 {
 	qq_data *qd;
 	guint8 raw_data[16] = {0};
 	gint bytes = 0;
 	guint8 away_cmd;
-	guint32 misc_status;
+	guint16 misc_status;
 	gboolean fake_video;
 
 	qd = (qq_data *) gc->proto_data;
@@ -470,24 +371,20 @@ void qq_request_change_status(PurpleConn
 
 	away_cmd = get_status_from_purple(gc);
 
-	misc_status = 0x00000000;
+	misc_status = 0x0000;
 	fake_video = purple_prefs_get_bool("/plugins/prpl/qq/show_fake_video");
 	if (fake_video)
-		misc_status |= QQ_MISC_STATUS_HAVING_VIIDEO;
+		misc_status |= 0x0001;
 
-	if (qd->client_version >= 2007) {
+	if (qd->client_version >= 2010) {
 		bytes = 0;
 		bytes += qq_put8(raw_data + bytes, away_cmd);
 		/* status version */
 		bytes += qq_put16(raw_data + bytes, 0);
-		bytes += qq_put16(raw_data + bytes, 0);
-		bytes += qq_put32(raw_data + bytes, misc_status);
+		bytes += qq_put16(raw_data + bytes, misc_status);
 		/* Fixme: custom status message, now is empty */
 		bytes += qq_put16(raw_data + bytes, 0);
-	} else {
-		bytes = 0;
-		bytes += qq_put8(raw_data + bytes, away_cmd);
-		bytes += qq_put32(raw_data + bytes, misc_status);
+		bytes += qq_put32(raw_data + bytes, 0);
 	}
 	qq_send_cmd_mess(gc, QQ_CMD_CHANGE_STATUS, raw_data, bytes, update_class, 0);
 }
@@ -525,7 +422,7 @@ void qq_process_buddy_change_status(guin
 {
 	qq_data *qd;
 	gint bytes;
-	UID my_uid;
+	guint32 my_uid;
 	gchar *who;
 	PurpleBuddy *buddy;
 	qq_buddy_data *bd;
@@ -544,7 +441,7 @@ void qq_process_buddy_change_status(guin
 	bytes = 0;
 	/* 000-030: qq_buddy_status */
 	bytes += get_buddy_status(&bs, data + bytes);
-	/* 031-034:  Unknow, maybe my uid */
+	/* 034-037:  my uid */
 	/* This has a value of 0 when we've changed our status to
 	 * QQ_BUDDY_ONLINE_INVISIBLE */
 	bytes += qq_get32(&my_uid, data + bytes);
@@ -574,16 +471,12 @@ void qq_process_buddy_change_status(guin
 	bd->last_update = time(NULL);
 
 	if (bd->status == QQ_BUDDY_ONLINE_NORMAL && bd->level <= 0) {
-		if (qd->client_version >= 2007) {
-			qq_request_get_level_2007(gc, bd->uid);
-		} else {
 			qq_request_get_level(gc, bd->uid);
-		}
 	}
 }
 
 /*TODO: maybe this should be qq_update_buddy_status() ?*/
-void qq_update_buddy_status(PurpleConnection *gc, UID uid, guint8 status, guint8 flag)
+void qq_update_buddy_status(PurpleConnection *gc, guint32 uid, guint8 status, guint8 flag)
 {
 	gchar *who;
 	const gchar *status_id;
diff -urp libpurple/protocols/qq/buddy_list.h libpurple/protocols/qq/buddy_list.h
--- libpurple/protocols/qq/buddy_list.h	2011-02-07 11:42:12.000000000 +0800
+++ libpurple/protocols/qq/buddy_list.h	2011-02-24 17:38:51.906793668 +0800
@@ -30,30 +30,33 @@
 
 #include "qq.h"
 typedef struct _qq_buddy_status {
-	UID uid;
+	guint32 uid;
 	guint8 unknown1;
 	struct in_addr ip;
 	guint16 port;
 	guint8 unknown2;
 	guint8 status;
+	guint16 version;
+	guint8 key[QQ_KEY_LENGTH];
 	guint16 unknown3;
-	guint8 unknown_key[QQ_KEY_LENGTH];
+	guint8 ext_flag;
+	guint8 comm_flag;
 } qq_buddy_status;
 
-void qq_request_get_buddies_online(PurpleConnection *gc, guint8 position, UPDCLS update_class);
+void qq_request_get_buddies_online(PurpleConnection *gc, guint8 position, guint32 update_class);
 guint8 qq_process_get_buddies_online(guint8 *data, gint data_len, PurpleConnection *gc);
 
-void qq_request_get_buddies(PurpleConnection *gc, guint16 position, UPDCLS update_class);
-guint16 qq_process_get_buddies(guint8 *data, gint data_len, PurpleConnection *gc);
+void qq_request_get_buddies_list(PurpleConnection *gc, guint16 position, guint32 update_class);
+guint16 qq_process_get_buddies_list(guint8 *data, gint data_len, PurpleConnection *gc);
 
-void qq_request_get_buddies_and_rooms(PurpleConnection *gc, guint32 position, UPDCLS update_class);
+void qq_request_get_rooms(PurpleConnection *gc, guint32 position, guint32 update_class);
 guint32 qq_process_get_buddies_and_rooms(guint8 *data, gint data_len, PurpleConnection *gc);
 
-void qq_request_change_status(PurpleConnection *gc, UPDCLS update_class);
+void qq_request_change_status(PurpleConnection *gc, guint32 update_class);
 void qq_process_change_status(guint8 *data, gint data_len, PurpleConnection *gc);
 void qq_process_buddy_change_status(guint8 *data, gint data_len, PurpleConnection *gc);
 
 void qq_update_buddyies_status(PurpleConnection *gc);
-void qq_update_buddy_status(PurpleConnection *gc, UID uid, guint8 status, guint8 flag);
+void qq_update_buddy_status(PurpleConnection *gc, guint32 uid, guint8 status, guint8 flag);
 void qq_buddy_data_free_all(PurpleConnection *gc);
 #endif
diff -urp libpurple/protocols/qq/buddy_memo.c libpurple/protocols/qq/buddy_memo.c
--- libpurple/protocols/qq/buddy_memo.c	2011-02-07 11:42:12.000000000 +0800
+++ libpurple/protocols/qq/buddy_memo.c	2011-02-24 17:38:51.943460335 +0800
@@ -83,7 +83,7 @@ static const gchar *memo_txt[] = {
 
 typedef struct _modify_memo_request {
 	PurpleConnection *gc;
-	UID bd_uid;
+	guint32 bd_uid;
 	gchar **segments;
 } modify_memo_request;
 
@@ -107,7 +107,7 @@ static void memo_free(gchar **segments)
 	purple_debug_info("QQ", "memo freed\n");
 }
 
-static void update_buddy_memo(PurpleConnection *gc, UID bd_uid, gchar *alias)
+static void update_buddy_alias(PurpleConnection *gc, guint32 bd_uid, gchar *alias)
 {
 	PurpleAccount *account;
 	PurpleBuddy *buddy;
@@ -127,7 +127,7 @@ static void update_buddy_memo(PurpleConn
 	purple_blist_alias_buddy(buddy, (const char*)alias);
 }
 
-static void request_change_memo(PurpleConnection *gc, UID bd_uid, gchar **segments)
+static void request_change_memo(PurpleConnection *gc, guint32 bd_uid, gchar **segments)
 {
 	gint bytes;
 	/* Attention, length of each segment must be guint8(0~255),
@@ -170,7 +170,7 @@ static void memo_modify_cancle_cb(modify
 static void memo_modify_ok_cb(modify_memo_request *memo_request, PurpleRequestFields *fields)
 {
 	PurpleConnection *gc;
-	UID bd_uid;
+	guint32 bd_uid;
 	gchar **segments;
 	const gchar *utf8_str;
 	gchar *value = NULL;
@@ -185,9 +185,9 @@ static void memo_modify_ok_cb(modify_mem
 
 	for (index = 0; index < QQ_MEMO_SIZE; index++) {
 		utf8_str = purple_request_fields_get_string(fields, memo_id[index]);
-		/* update alias */
+		/* update memo */
 		if (QQ_MEMO_ALIAS == index) {
-			update_buddy_memo(gc, (UID)bd_uid, segments[QQ_MEMO_ALIAS]);
+			update_buddy_alias(gc, bd_uid, segments[QQ_MEMO_ALIAS]);
 		}
 		if (NULL == utf8_str) {
 			value = g_strdup("");
@@ -213,7 +213,7 @@ static void memo_modify_ok_cb(modify_mem
 }
 
 /* memo modify dialogue */
-static void memo_modify_dialogue(PurpleConnection *gc, UID bd_uid, gchar **segments, guint32 action)
+static void memo_modify_dialogue(PurpleConnection *gc, guint32 bd_uid, gchar **segments, guint32 action)
 {
 	modify_memo_request *memo_request;
 	PurpleRequestField *field;
@@ -226,9 +226,6 @@ static void memo_modify_dialogue(PurpleC
 	g_return_if_fail(NULL != gc && NULL != segments);
 
 	switch (action) {
-		case QQ_BUDDY_MEMO_GET:
-			memo_free(segments);
-			break;
 		case QQ_BUDDY_MEMO_MODIFY:
 			/* keep one dialog once a time */
 			purple_request_close_with_handle(gc);
@@ -272,7 +269,7 @@ static void memo_modify_dialogue(PurpleC
 	}
 }
 
-static void qq_create_buddy_memo(PurpleConnection *gc, UID bd_uid, guint32 action)
+static void qq_create_buddy_memo(PurpleConnection *gc, guint32 bd_uid, guint32 action)
 {
 	gchar **segments;
 	gint index;
@@ -285,19 +282,18 @@ static void qq_create_buddy_memo(PurpleC
 	memo_modify_dialogue(gc, bd_uid, segments, action);
 }
 
-/* process reply to get_memo packet
- * here, update_class will be regarded as buddy's uid. because some 
- * memo packages returned without uid, which will make us confused */
+/* process reply to get_memo packet */
 void qq_process_get_buddy_memo(PurpleConnection *gc, guint8* data, gint data_len,
-		UPDCLS update_class, guint32 action)
+		guint32 update_class, guint32 action)
 {
 	gchar **segments;
 	gint bytes;
 	gint index;
 	guint8 rcv_cmd;
 	guint32 rcv_uid;
-	guint8 unk1_8;
 	guint8 is_success;
+	gchar * alias;
+	qq_data * qd;
 
 	g_return_if_fail(NULL != gc && NULL != data && 0 != data_len);
 	/*
@@ -311,14 +307,15 @@ void qq_process_get_buddy_memo(PurpleCon
 	bytes += qq_get8(&rcv_cmd, data+bytes);
 	purple_debug_info("QQ", "rcv_cmd=0x%02X\n", rcv_cmd);
 
-	/* it's possible that packet contains no buddy uid and no memo!!!
-	 * go to next step according to previous action sent */
-	if (1 == data_len) { /* only one byte */
-		purple_debug_info("QQ", "memo packet contains no buddy uid and memo...\n");
+	/* it's possible that packet contains no buddy uid and no memo
+	 * ONLY when qd->uid send QQ_BUDDY_MEMO_GET
+	 * AND we could have that */
+	if (1 == data_len) { 
+		purple_debug_info("QQ", "no memo info \n");
+		g_return_if_fail (gc != NULL && gc->proto_data != NULL);
+		qd = (qq_data *) gc->proto_data;
 		if (QQ_BUDDY_MEMO_MODIFY == action) {
-			UID mod_uid;
-			mod_uid = (UID)update_class;
-			qq_create_buddy_memo(gc, mod_uid, QQ_BUDDY_MEMO_MODIFY);
+			qq_create_buddy_memo(gc, qd->uid, QQ_BUDDY_MEMO_MODIFY);
 			return;
 		}
 		return;
@@ -346,22 +343,37 @@ void qq_process_get_buddy_memo(PurpleCon
 		case QQ_BUDDY_MEMO_GET:
 			bytes += qq_get32(&rcv_uid, data+bytes);
 			purple_debug_info("QQ", "rcv_uid=%u\n", rcv_uid);
-			bytes += qq_get8(&unk1_8, data+bytes);
-			purple_debug_info("QQ", "unk1_8=0x%02X\n", unk1_8);
+			bytes += qq_get8(&is_success, data+bytes);
+			purple_debug_info("QQ", "is_success=0x%02X\n", is_success);
+
 			segments = g_new0(gchar*, QQ_MEMO_SIZE);
+
 			for (index = 0; index < QQ_MEMO_SIZE; index++) {
-				/* get utf8 string */
-				bytes += qq_get_vstr(&segments[index], QQ_CHARSET_DEFAULT, data+bytes);
+
+				bytes += qq_get_vstr(&segments[index], NULL, sizeof(guint8), data+bytes);
 				/*
-				   purple_debug_info("QQ", "bytes:%d, seg:%s\n", bytes, segments[index]);
-				   */
+			   purple_debug_info("QQ", "bytes:%d, seg:%s\n", bytes, segments[index]);
+				  */
 			}
 
 			/* common action, update buddy memo */
-			update_buddy_memo(gc, (UID)rcv_uid, segments[QQ_MEMO_ALIAS]);
-
-			/* memo is a thing that we regard our buddy as, so we need one more buddy_uid */
+			update_buddy_alias(gc, rcv_uid, segments[QQ_MEMO_ALIAS]);
+			/* memo is thing that we regard our buddy as, so we need one more buddy_uid */
+			/* action might be QQ_BUDDY_MEMO_MODIFY */
 			memo_modify_dialogue(gc, rcv_uid, segments, action);
+			g_free(segments);
+			break;
+		case QQ_BUDDY_MEMO_ALIAS:
+			bytes += qq_get8(&is_success, data+bytes);
+			purple_debug_info("QQ", "is_success=0x%02X\n", is_success);
+
+			while (bytes < data_len)
+			{
+				bytes += qq_get32(&rcv_uid, data+bytes);
+				purple_debug_info("QQ", "rcv_uid=%u\n", rcv_uid);
+				bytes += qq_get_vstr(&alias, NULL, sizeof(guint8),data+bytes);
+				update_buddy_alias(gc, rcv_uid, alias);
+			}
 			break;
 		default:
 			purple_debug_info("QQ", "received an UNKNOWN memo cmd!!!\n");
@@ -369,30 +381,33 @@ void qq_process_get_buddy_memo(PurpleCon
 	}
 }
 
-/* request buddy memo
- *
- * param: gc, uid, update_class, action
- * here, update_class will be set to buddy's uid. because some memo 
- * packages returned without uid, which will make us confused */
-void qq_request_buddy_memo(PurpleConnection *gc, UID bd_uid, UPDCLS update_class, guint32 action)
+/* request buddy memo */
+void qq_request_buddy_memo( PurpleConnection *gc, guint32 bd_uid, guint32 update_class, guint8 action )
 {
 	guint8 raw_data[16] = {0};
 	gint bytes;
 
-	purple_debug_info("QQ", "qq_request_buddy_memo, buddy uid=%u, update_class=%u\n",
-			bd_uid, update_class);
+	purple_debug_info("QQ", "qq_request_buddy_memo, buddy bd_uid=%u, action=%u\n",
+			bd_uid, action);
 	g_return_if_fail(NULL != gc);
 	/* '0' is ok
 	   g_return_if_fail(uid != 0);
 	   */
 	bytes = 0;
-	bytes += qq_put8(raw_data+bytes, QQ_BUDDY_MEMO_GET);
-	bytes += qq_put32(raw_data+bytes, bd_uid);
+	bytes += qq_put8(raw_data+bytes, action);
+	if (action == QQ_BUDDY_MEMO_ALIAS)
+	{
+		bytes += qq_put8(raw_data+bytes, (guint8)bd_uid);
+		/* need one byte of index, just make a conversion */
+	} else {
+		bytes += qq_put32(raw_data+bytes, bd_uid);
+	}
+	
 	/*
 	   qq_show_packet("MEMO REQUEST", raw_data, bytes);
 	   */
 
-	qq_send_cmd_mess(gc, QQ_CMD_BUDDY_MEMO, (guint8*)raw_data, bytes, update_class, action);
+	qq_send_cmd_mess(gc, QQ_CMD_BUDDY_MEMO, (guint8*)raw_data, bytes, update_class , action);
 }
 
 
diff -urp libpurple/protocols/qq/buddy_memo.h libpurple/protocols/qq/buddy_memo.h
--- libpurple/protocols/qq/buddy_memo.h	2011-02-07 11:42:12.000000000 +0800
+++ libpurple/protocols/qq/buddy_memo.h	2011-02-24 17:38:51.943460335 +0800
@@ -28,22 +28,19 @@
 #include <glib.h>
 #include "connection.h"
 #include "blist.h"
-#include "qq.h"
 
 #define QQ_BUDDY_MEMO_REQUEST_SUCCESS 0x00
 
 /* clan command for memo */
-enum
-{
-	QQ_BUDDY_MEMO_MODIFY = 0x01,	/* upload memo */
-	QQ_BUDDY_MEMO_REMOVE,		/* remove memo */
-	QQ_BUDDY_MEMO_GET		/* get memo */
-};
+#define 	QQ_BUDDY_MEMO_MODIFY 0x01		/* upload memo */
+#define 	QQ_BUDDY_MEMO_REMOVE	0x02	/* remove memo */
+#define 	QQ_BUDDY_MEMO_GET 0x67		/* get memo */
+#define  QQ_BUDDY_MEMO_ALIAS 0x68		/* get buddies alias list */
 
 
-void qq_process_get_buddy_memo(PurpleConnection *gc, guint8* data, gint data_len, UPDCLS update_class, guint32 action);
+void qq_process_get_buddy_memo(PurpleConnection *gc, guint8* data, gint data_len, guint32 update_class, guint32 action);
 
-void qq_request_buddy_memo(PurpleConnection *gc, UID bd_uid, UPDCLS update_class, guint32 action);
+void qq_request_buddy_memo(PurpleConnection *gc, guint32 bd_uid, guint32 update_class, guint8 action);
 
 #endif
 
diff -urp libpurple/protocols/qq/buddy_opt.c libpurple/protocols/qq/buddy_opt.c
--- libpurple/protocols/qq/buddy_opt.c	2011-02-07 11:42:12.000000000 +0800
+++ libpurple/protocols/qq/buddy_opt.c	2011-02-24 17:38:51.943460335 +0800
@@ -51,12 +51,12 @@ enum {
 
 typedef struct _qq_buddy_req {
 	PurpleConnection *gc;
-	UID uid;
+	guint32 uid;
 	guint8 *auth;
 	guint8 auth_len;
 } qq_buddy_req;
 
-void add_buddy_authorize_input(PurpleConnection *gc, UID uid,
+void add_buddy_authorize_input(PurpleConnection *gc, guint32 uid,
 		guint8 *auth, guint8 auth_len);
 
 static void buddy_req_free(qq_buddy_req *add_req)
@@ -88,7 +88,7 @@ PurpleGroup *qq_group_find_or_new(const
 	return g;
 }
 
-static qq_buddy_data *qq_buddy_data_new(UID uid)
+static qq_buddy_data *qq_buddy_data_new(guint32 uid)
 {
 	qq_buddy_data *bd = g_new0(qq_buddy_data, 1);
 	memset(bd, 0, sizeof(qq_buddy_data));
@@ -97,7 +97,7 @@ static qq_buddy_data *qq_buddy_data_new(
 	return bd;
 }
 
-qq_buddy_data *qq_buddy_data_find(PurpleConnection *gc, UID uid)
+qq_buddy_data *qq_buddy_data_find(PurpleConnection *gc, guint32 uid)
 {
 	gchar *who;
 	PurpleBuddy *buddy;
@@ -131,7 +131,7 @@ void qq_buddy_data_free(qq_buddy_data *b
 }
 
 /* create purple buddy without data and display with no-auth icon */
-PurpleBuddy *qq_buddy_new(PurpleConnection *gc, UID uid)
+PurpleBuddy *qq_buddy_new(PurpleConnection *gc, guint32 uid)
 {
 	PurpleBuddy *buddy;
 	PurpleGroup *group;
@@ -162,7 +162,7 @@ PurpleBuddy *qq_buddy_new(PurpleConnecti
 	return buddy;
 }
 
-static void qq_buddy_free(PurpleBuddy *buddy)
+void qq_buddy_free(PurpleBuddy *buddy)
 {
 	qq_buddy_data *bd;
 
@@ -175,7 +175,7 @@ static void qq_buddy_free(PurpleBuddy *b
 	purple_blist_remove_buddy(buddy);
 }
 
-PurpleBuddy *qq_buddy_find(PurpleConnection *gc, UID uid)
+PurpleBuddy *qq_buddy_find(PurpleConnection *gc, guint32 uid)
 {
 	PurpleBuddy *buddy;
 	gchar *who;
@@ -188,7 +188,7 @@ PurpleBuddy *qq_buddy_find(PurpleConnect
 	return buddy;
 }
 
-PurpleBuddy *qq_buddy_find_or_new(PurpleConnection *gc, UID uid)
+PurpleBuddy *qq_buddy_find_or_new(PurpleConnection *gc, guint32 uid)
 {
 	PurpleBuddy *buddy;
 	qq_buddy_data *bd;
@@ -213,20 +213,8 @@ PurpleBuddy *qq_buddy_find_or_new(Purple
 }
 
 /* send packet to remove a buddy from my buddy list */
-static void request_remove_buddy(PurpleConnection *gc, UID uid)
-{
-	gchar uid_str[11];
-	gint bytes;
-
-	g_return_if_fail(uid > 0);
-
-	g_snprintf(uid_str, sizeof(uid_str), "%u", uid);
-	bytes = strlen(uid_str);
-	qq_send_cmd_mess(gc, QQ_CMD_REMOVE_BUDDY, (guint8 *) uid_str, bytes, 0, uid);
-}
-
 static void request_remove_buddy_ex(PurpleConnection *gc,
-		UID uid, guint8 *auth, guint8 auth_len)
+		guint32 uid, guint8 *auth, guint8 auth_len)
 {
 	gint bytes;
 	guint8 *raw_data;
@@ -246,7 +234,7 @@ static void request_remove_buddy_ex(Purp
 	qq_send_cmd_mess(gc, QQ_CMD_REMOVE_BUDDY, raw_data, bytes, 0, uid);
 }
 
-void qq_request_auth_code(PurpleConnection *gc, guint8 cmd, guint16 sub_cmd, UID uid)
+void qq_request_auth_token(PurpleConnection *gc, guint8 cmd, guint16 sub_cmd, guint32 dataptr, guint32 uid)
 {
 	guint8 raw_data[16];
 	gint bytes;
@@ -257,10 +245,10 @@ void qq_request_auth_code(PurpleConnecti
 	bytes += qq_put16(raw_data + bytes, sub_cmd);
 	bytes += qq_put32(raw_data + bytes, uid);
 
-	qq_send_cmd_mess(gc, QQ_CMD_AUTH_CODE, raw_data, bytes, 0, uid);
+	qq_send_cmd_mess(gc, QQ_CMD_AUTH_TOKEN, raw_data, bytes, dataptr, uid);
 }
 
-void qq_process_auth_code(PurpleConnection *gc, guint8 *data, gint data_len, UID uid)
+void qq_process_auth_token(PurpleConnection *gc, guint8 *data, gint data_len, guint32 dataptr, guint32 uid)
 {
 	gint bytes;
 	guint8 cmd, reply;
@@ -271,7 +259,7 @@ void qq_process_auth_code(PurpleConnecti
 	g_return_if_fail(data != NULL && data_len != 0);
 	g_return_if_fail(uid != 0);
 
-	qq_show_packet("qq_process_auth_code", data, data_len);
+	qq_show_packet("qq_process_auth_token", data, data_len);
 	bytes = 0;
 	bytes += qq_get8(&cmd, data + bytes);
 	bytes += qq_get16(&sub_cmd, data + bytes);
@@ -292,6 +280,10 @@ void qq_process_auth_code(PurpleConnecti
 		add_buddy_authorize_input(gc, uid, code, code_len);
 		return;
 	}
+	if (cmd == QQ_AUTH_INFO_BUDDY && sub_cmd == QQ_AUTH_INFO_UPDATE_BUDDY_INFO) {
+		request_change_info(gc, (guint8 *)dataptr, code, code_len);
+		return;
+	}
 	purple_debug_info("QQ", "Got auth info cmd 0x%x, sub 0x%x, reply 0x%x\n",
 			cmd, sub_cmd, reply);
 }
@@ -308,7 +300,7 @@ static void add_buddy_question_cb(qq_bud
 	buddy_req_free(add_req);
 }
 
-static void add_buddy_question_input(PurpleConnection *gc, UID uid, gchar *question)
+static void add_buddy_question_input(PurpleConnection *gc, guint32 uid, gchar *question)
 {
 	gchar *who, *msg;
 	qq_buddy_req *add_req;
@@ -336,7 +328,7 @@ static void add_buddy_question_input(Pur
 }
 
 void qq_request_question(PurpleConnection *gc,
-		guint8 cmd, UID uid, const gchar *question_utf8, const gchar *answer_utf8)
+		guint8 cmd, guint32 uid, const gchar *question_utf8, const gchar *answer_utf8)
 {
 	guint8 raw_data[MAX_PACKET_SIZE - 16];
 	gint bytes;
@@ -371,7 +363,7 @@ void qq_request_question(PurpleConnectio
 	return;
 }
 
-static void request_add_buddy_by_question(PurpleConnection *gc, UID uid,
+static void request_add_buddy_by_question(PurpleConnection *gc, guint32 uid,
 	guint8 *code, guint16 code_len)
 {
 	guint8 raw_data[MAX_PACKET_SIZE - 16];
@@ -395,7 +387,7 @@ static void request_add_buddy_by_questio
 	qq_send_cmd(gc, QQ_CMD_ADD_BUDDY_AUTH_EX, raw_data, bytes);
 }
 
-void qq_process_question(PurpleConnection *gc, guint8 *data, gint data_len, UID uid)
+void qq_process_question(PurpleConnection *gc, guint8 *data, gint data_len, guint32 uid)
 {
 	gint bytes;
 	guint8 cmd, reply;
@@ -409,8 +401,8 @@ void qq_process_question(PurpleConnectio
 	bytes = 0;
 	bytes += qq_get8(&cmd, data + bytes);
 	if (cmd == QQ_QUESTION_GET) {
-		bytes += qq_get_vstr(&question, QQ_CHARSET_DEFAULT, data + bytes);
-		bytes += qq_get_vstr(&answer, QQ_CHARSET_DEFAULT, data + bytes);
+		bytes += qq_get_vstr(&question, QQ_CHARSET_DEFAULT, sizeof(guint8), data + bytes);
+		bytes += qq_get_vstr(&answer, QQ_CHARSET_DEFAULT, sizeof(guint8), data + bytes);
 		purple_debug_info("QQ", "Get buddy adding Q&A:\n%s\n%s\n", question, answer);
 		g_free(question);
 		g_free(answer);
@@ -434,7 +426,7 @@ void qq_process_question(PurpleConnectio
 			purple_debug_warning("QQ", "Failed getting question, reply %d\n", reply);
 			return;
 		}
-		bytes += qq_get_vstr(&question, QQ_CHARSET_DEFAULT, data + bytes);
+		bytes += qq_get_vstr(&question, QQ_CHARSET_DEFAULT, sizeof(guint8), data + bytes);
 		purple_debug_info("QQ", "Get buddy question:\n%s\n", question);
 		add_buddy_question_input(gc, uid, question);
 		g_free(question);
@@ -460,33 +452,8 @@ void qq_process_question(PurpleConnectio
 	g_return_if_reached();
 }
 
-/* try to remove myself from someone's buddy list */
-static void request_buddy_remove_me(PurpleConnection *gc, UID uid)
-{
-	guint8 raw_data[16] = {0};
-	gint bytes = 0;
-
-	g_return_if_fail(uid > 0);
-
-	bytes += qq_put32(raw_data + bytes, uid);
-
-	qq_send_cmd_mess(gc, QQ_CMD_REMOVE_ME, raw_data, bytes, 0, uid);
-}
-
 /* try to add a buddy without authentication */
-static void request_add_buddy_no_auth(PurpleConnection *gc, UID uid)
-{
-	gchar uid_str[11];
-
-	g_return_if_fail(uid > 0);
-
-	/* we need to send the ascii code of this uid to qq server */
-	g_snprintf(uid_str, sizeof(uid_str), "%u", uid);
-	qq_send_cmd_mess(gc, QQ_CMD_ADD_BUDDY_NO_AUTH,
-			(guint8 *) uid_str, strlen(uid_str), 0, uid);
-}
-
-static void request_add_buddy_no_auth_ex(PurpleConnection *gc, UID uid)
+static void request_add_buddy_no_auth(PurpleConnection *gc, guint32 uid)
 {
 	guint bytes;
 	guint8 raw_data[16];
@@ -498,35 +465,35 @@ static void request_add_buddy_no_auth_ex
 	qq_send_cmd_mess(gc, QQ_CMD_ADD_BUDDY_NO_AUTH_EX, raw_data, bytes, 0, uid);
 }
 
-/* this buddy needs authentication, text conversion is done at lowest level */
-static void request_add_buddy_auth(PurpleConnection *gc, UID uid, const gchar response, const gchar *text)
-{
-	guint8 raw_data[MAX_PACKET_SIZE - 16];
-	gint bytes;
-	gchar *msg, uid_str[11];
-	guint8 bar;
-
-	g_return_if_fail(uid != 0);
-
-	g_snprintf(uid_str, sizeof(uid_str), "%u", uid);
-	bar = 0x1f;
-
-	bytes = 0;
-	bytes += qq_putdata(raw_data + bytes, (guint8 *) uid_str, strlen(uid_str));
-	bytes += qq_put8(raw_data + bytes, bar);
-	bytes += qq_put8(raw_data + bytes, response);
-
-	if (text != NULL) {
-		msg = utf8_to_qq(text, QQ_CHARSET_DEFAULT);
-		bytes += qq_put8(raw_data + bytes, bar);
-		bytes += qq_putdata(raw_data + bytes, (guint8 *) msg, strlen(msg));
-		g_free(msg);
-	}
-
-	qq_send_cmd(gc, QQ_CMD_ADD_BUDDY_AUTH, raw_data, bytes);
-}
+/* this buddy needs authentication, text conversion is done at lowest level */
+static void request_add_buddy_auth(PurpleConnection *gc, guint32 uid, const gchar response, const gchar *text)
+{
+	guint8 raw_data[MAX_PACKET_SIZE - 16];
+	gint bytes;
+	gchar *msg, uid_str[11];
+	guint8 bar;
+
+	g_return_if_fail(uid != 0);
+
+	g_snprintf(uid_str, sizeof(uid_str), "%u", uid);
+	bar = 0x1f;
+
+	bytes = 0;
+	bytes += qq_putdata(raw_data + bytes, (guint8 *) uid_str, strlen(uid_str));
+	bytes += qq_put8(raw_data + bytes, bar);
+	bytes += qq_put8(raw_data + bytes, response);
+
+	if (text != NULL) {
+		msg = utf8_to_qq(text, QQ_CHARSET_DEFAULT);
+		bytes += qq_put8(raw_data + bytes, bar);
+		bytes += qq_putdata(raw_data + bytes, (guint8 *) msg, strlen(msg));
+		g_free(msg);
+	}
+
+	qq_send_cmd(gc, QQ_CMD_ADD_BUDDY_AUTH, raw_data, bytes);
+}
 
-static void request_add_buddy_auth_ex(PurpleConnection *gc, UID uid,
+static void request_add_buddy_auth_ex(PurpleConnection *gc, guint32 uid,
 	const gchar *text, guint8 *auth, guint8 auth_len)
 {
 	guint8 raw_data[MAX_PACKET_SIZE - 16];
@@ -569,11 +536,9 @@ static void add_buddy_auth_cb(qq_buddy_r
 	}
 
 	qd = (qq_data *)add_req->gc->proto_data;
-	if (qd->client_version > 2005) {
+	if (qd->client_version >= 2010) {
 		request_add_buddy_auth_ex(add_req->gc, add_req->uid,
 				text, add_req->auth, add_req->auth_len);
-	} else {
-		request_add_buddy_auth(add_req->gc, add_req->uid, QQ_MY_AUTH_REQUEST, text);
 	}
 	buddy_req_free(add_req);
 }
@@ -635,15 +600,13 @@ static void add_buddy_no_auth_cb(qq_budd
 	}
 
 	qd = (qq_data *) add_req->gc->proto_data;
-	if (qd->client_version > 2005) {
-		request_add_buddy_no_auth_ex(add_req->gc, add_req->uid);
-	} else {
+	if (qd->client_version >= 2010) {
 		request_add_buddy_no_auth(add_req->gc, add_req->uid);
 	}
 	buddy_req_free(add_req);
 }
 
-void add_buddy_authorize_input(PurpleConnection *gc, UID uid,
+void add_buddy_authorize_input(PurpleConnection *gc, guint32 uid,
 		guint8 *auth, guint8 auth_len)
 {
 	gchar *who, *msg;
@@ -683,7 +646,7 @@ void add_buddy_authorize_input(PurpleCon
 void qq_add_buddy(PurpleConnection *gc, PurpleBuddy *buddy, PurpleGroup *group)
 {
 	qq_data *qd;
-	UID uid;
+	guint32 uid;
 
 	g_return_if_fail(NULL != gc && NULL != gc->proto_data);
 	g_return_if_fail(buddy != NULL);
@@ -694,11 +657,7 @@ void qq_add_buddy(PurpleConnection *gc,
 
 	uid = purple_name_to_uid(purple_buddy_get_name(buddy));
 	if (uid > 0) {
-		if (qd->client_version > 2005) {
-			request_add_buddy_no_auth_ex(gc, uid);
-		} else {
 			request_add_buddy_no_auth(gc, uid);
-		}
 		return;
 	}
 
@@ -733,7 +692,7 @@ void qq_process_add_buddy_auth(guint8 *d
 }
 
 /* process the server reply for my request to remove a buddy */
-void qq_process_remove_buddy(PurpleConnection *gc, guint8 *data, gint data_len, UID uid)
+void qq_process_remove_buddy(PurpleConnection *gc, guint8 *data, gint data_len, guint32 uid)
 {
 	PurpleBuddy *buddy = NULL;
 	gchar *msg;
@@ -756,7 +715,7 @@ void qq_process_remove_buddy(PurpleConne
 }
 
 /* process the server reply for my request to remove myself from a buddy */
-void qq_process_buddy_remove_me(PurpleConnection *gc, guint8 *data, gint data_len, UID uid)
+void qq_process_buddy_remove_me(PurpleConnection *gc, guint8 *data, gint data_len, guint32 uid)
 {
 	gchar *msg;
 
@@ -772,7 +731,7 @@ void qq_process_buddy_remove_me(PurpleCo
 }
 
 void qq_process_add_buddy_no_auth(PurpleConnection *gc,
-		guint8 *data, gint data_len, UID uid)
+		guint8 *data, gint data_len, guint32 uid)
 {
 	qq_data *qd;
 	gchar **segments;
@@ -804,9 +763,7 @@ void qq_process_add_buddy_no_auth(Purple
 		qq_buddy_find_or_new(gc, uid);
 
 		qq_request_buddy_info(gc, uid, 0, 0);
-		if (qd->client_version >= 2007) {
-			qq_request_get_level_2007(gc, uid);
-		} else {
+		if (qd->client_version >= 2010) {
 			qq_request_get_level(gc, uid);
 		}
 		qq_request_get_buddies_online(gc, 0, 0);
@@ -834,11 +791,11 @@ void qq_process_add_buddy_no_auth(Purple
 }
 
 void qq_process_add_buddy_no_auth_ex(PurpleConnection *gc,
-		guint8 *data, gint data_len, UID uid)
+		guint8 *data, gint data_len, guint32 uid)
 {
 	qq_data *qd;
 	gint bytes;
-	UID dest_uid;
+	guint32 dest_uid;
 	guint8 reply;
 	guint8 auth_type;
 
@@ -861,9 +818,7 @@ void qq_process_add_buddy_no_auth_ex(Pur
 		qq_buddy_find_or_new(gc, uid);
 
 		qq_request_buddy_info(gc, uid, 0, 0);
-		if (qd->client_version >= 2007) {
-			qq_request_get_level_2007(gc, uid);
-		} else {
+		if (qd->client_version >= 2010) {
 			qq_request_get_level(gc, uid);
 		}
 		qq_request_get_buddies_online(gc, 0, 0);
@@ -884,7 +839,7 @@ void qq_process_add_buddy_no_auth_ex(Pur
 		case 0x00:	/* no authorize */
 			break;
 		case 0x01:	/* authorize */
-			qq_request_auth_code(gc, QQ_AUTH_INFO_BUDDY, QQ_AUTH_INFO_ADD_BUDDY, uid);
+			qq_request_auth_token(gc, QQ_AUTH_INFO_BUDDY, QQ_AUTH_INFO_ADD_BUDDY, 0, uid);
 			break;
 		case 0x02:	/* disable */
 			break;
@@ -903,7 +858,7 @@ void qq_remove_buddy(PurpleConnection *g
 {
 	qq_data *qd;
 	qq_buddy_data *bd;
-	UID uid;
+	guint32 uid;
 
 	g_return_if_fail(gc != NULL && gc->proto_data != NULL);
 	g_return_if_fail(buddy != NULL);
@@ -914,13 +869,9 @@ void qq_remove_buddy(PurpleConnection *g
 
 	uid = purple_name_to_uid(purple_buddy_get_name(buddy));
 	if (uid > 0 && uid != qd->uid) {
-		if (qd->client_version > 2005) {
-			qq_request_auth_code(gc, QQ_AUTH_INFO_BUDDY, QQ_AUTH_INFO_REMOVE_BUDDY, uid);
-		} else {
-			request_remove_buddy(gc, uid);
-			request_buddy_remove_me(gc, uid);
-		}
-	}
+		if (qd->client_version >= 2010) {
+			qq_request_auth_token(gc, QQ_AUTH_INFO_BUDDY, QQ_AUTH_INFO_REMOVE_BUDDY, 0, uid);
+		}	}
 
 	if ((bd = purple_buddy_get_protocol_data(buddy)) != NULL) {
 		qq_buddy_data_free(bd);
@@ -933,7 +884,7 @@ void qq_remove_buddy(PurpleConnection *g
 	 * otherwise purple segmentation fault */
 }
 
-static void buddy_add_input(PurpleConnection *gc, UID uid, gchar *reason)
+static void buddy_add_input(PurpleConnection *gc, guint32 uid, gchar *reason)
 {
 	PurpleAccount *account = purple_connection_get_account(gc);
 	qq_buddy_req *add_req;
@@ -967,7 +918,7 @@ static void buddy_add_input(PurpleConnec
 static void server_buddy_add_request(PurpleConnection *gc, gchar *from, gchar *to,
 		guint8 *data, gint data_len)
 {
-	UID uid;
+	guint32 uid;
 	gchar *msg, *reason;
 
 	g_return_if_fail(from != NULL && to != NULL);
@@ -996,7 +947,7 @@ void qq_process_buddy_check_code(PurpleC
 	gint bytes;
 	guint8 cmd;
 	guint8 reply;
-	UID uid;
+	guint32 uid;
 	guint16 flag1, flag2;
 
 	g_return_if_fail(data != NULL && data_len >= 5);
@@ -1026,7 +977,7 @@ static void request_buddy_check_code(Pur
 {
 	guint8 *raw_data;
 	gint bytes;
-	UID uid;
+	guint32 uid;
 
 	g_return_if_fail(code != NULL && code_len > 0 && from != NULL);
 
@@ -1073,7 +1024,7 @@ static void server_buddy_add_request_ex(
 		guint8 *data, gint data_len)
 {
 	gint bytes;
-	UID uid;
+	guint32 uid;
 	gchar *msg;
 	guint8 allow_reverse;
 
@@ -1085,7 +1036,7 @@ static void server_buddy_add_request_ex(
 	/* qq_show_packet("server_buddy_add_request_ex", data, data_len); */
 
 	bytes = 0;
-	bytes += qq_get_vstr(&msg, QQ_CHARSET_DEFAULT, data+bytes);
+	bytes += qq_get_vstr(&msg, QQ_CHARSET_DEFAULT, sizeof(guint8), data+bytes);
 	bytes += qq_get8(&allow_reverse, data + bytes);	/* allow_reverse = 0x01, allowed */
 	server_buddy_check_code(gc, from, data + bytes, data_len - bytes);
 
@@ -1103,7 +1054,7 @@ static void server_buddy_added(PurpleCon
 {
 	PurpleAccount *account = purple_connection_get_account(gc);
 	PurpleBuddy *buddy;
-	UID uid;
+	guint32 uid;
 	qq_buddy_req *add_req;
 	gchar *who;
 	gchar *primary;
@@ -1147,7 +1098,7 @@ static void server_buddy_added_ex(Purple
 	qq_show_packet("server_buddy_added_ex", data, data_len);
 
 	bytes = 0;
-	bytes += qq_get_vstr(&msg, QQ_CHARSET_DEFAULT, data+bytes);	/* always empty msg */
+	bytes += qq_get_vstr(&msg, QQ_CHARSET_DEFAULT, sizeof(guint8), data+bytes);	/* always empty msg */
 	purple_debug_info("QQ", "Buddy added msg: %s\n", msg);
 	bytes += qq_get8(&allow_reverse, data + bytes);	/* allow_reverse = 0x01, allowed */
 	server_buddy_check_code(gc, from, data + bytes, data_len - bytes);
@@ -1177,7 +1128,7 @@ static void server_buddy_added_me(Purple
 {
 	PurpleAccount *account = purple_connection_get_account(gc);
 	qq_data *qd;
-	UID uid;
+	guint32 uid;
 
 	g_return_if_fail(from != NULL && to != NULL);
 
@@ -1191,9 +1142,7 @@ static void server_buddy_added_me(Purple
 	qq_buddy_find_or_new(gc, uid);
 	qq_request_buddy_info(gc, uid, 0, 0);
 	qq_request_get_buddies_online(gc, 0, 0);
-	if (qd->client_version >= 2007) {
-		qq_request_get_level_2007(gc, uid);
-	} else {
+	if (qd->client_version >= 2010) {
 		qq_request_get_level(gc, uid);
 	}
 
@@ -1204,7 +1153,7 @@ static void server_buddy_added_me(Purple
 static void server_buddy_rejected_me(PurpleConnection *gc, gchar *from, gchar *to,
 		guint8 *data, gint data_len)
 {
-	UID uid;
+	guint32 uid;
 	PurpleBuddy *buddy;
 	gchar *msg, *msg_utf8;
 	gint bytes;
diff -urp libpurple/protocols/qq/buddy_opt.h libpurple/protocols/qq/buddy_opt.h
--- libpurple/protocols/qq/buddy_opt.h	2011-02-07 11:42:12.000000000 +0800
+++ libpurple/protocols/qq/buddy_opt.h	2011-02-24 17:38:51.986793667 +0800
@@ -54,31 +54,31 @@ void qq_change_buddys_group(PurpleConnec
 void qq_remove_buddy_and_me(PurpleBlistNode * node);
 void qq_remove_buddy(PurpleConnection *gc, PurpleBuddy *buddy, PurpleGroup *group);
 
-void qq_process_remove_buddy(PurpleConnection *gc, guint8 *data, gint data_len, UID uid);
-void qq_process_buddy_remove_me(PurpleConnection *gc, guint8 *data, gint data_len, UID uid);
+void qq_process_remove_buddy(PurpleConnection *gc, guint8 *data, gint data_len, guint32 uid);
+void qq_process_buddy_remove_me(PurpleConnection *gc, guint8 *data, gint data_len, guint32 uid);
 void qq_process_add_buddy_no_auth(PurpleConnection *gc,
-		guint8 *data, gint data_len, UID uid);
+		guint8 *data, gint data_len, guint32 uid);
 void qq_process_add_buddy_no_auth_ex(PurpleConnection *gc,
-		guint8 *data, gint data_len, UID uid);
+		guint8 *data, gint data_len, guint32 uid);
 void qq_process_add_buddy_auth(guint8 *data, gint data_len, PurpleConnection *gc);
 void qq_process_buddy_from_server(PurpleConnection *gc, int funct,
 		gchar *from, gchar *to, guint8 *data, gint data_len);
 
 void qq_process_buddy_check_code(PurpleConnection *gc, guint8 *data, gint data_len);
 
-void qq_request_auth_code(PurpleConnection *gc, guint8 cmd, guint16 sub_cmd, UID uid);
-void qq_process_auth_code(PurpleConnection *gc, guint8 *data, gint data_len, UID uid);
+void qq_request_auth_token(PurpleConnection *gc, guint8 cmd, guint16 sub_cmd, guint32 dataptr, guint32 uid);
+void qq_process_auth_token(PurpleConnection *gc, guint8 *data, gint data_len, guint32 dataptr, guint32 uid);
 void qq_request_question(PurpleConnection *gc,
-		guint8 cmd, UID uid, const gchar *question_utf8, const gchar *answer_utf8);
-void qq_process_question(PurpleConnection *gc, guint8 *data, gint data_len, UID uid);
+		guint8 cmd, guint32 uid, const gchar *question_utf8, const gchar *answer_utf8);
+void qq_process_question(PurpleConnection *gc, guint8 *data, gint data_len, guint32 uid);
 
 void qq_process_add_buddy_auth_ex(PurpleConnection *gc, guint8 *data, gint data_len, guint32 ship32);
 
-qq_buddy_data *qq_buddy_data_find(PurpleConnection *gc, UID uid);
+qq_buddy_data *qq_buddy_data_find(PurpleConnection *gc, guint32 uid);
 void qq_buddy_data_free(qq_buddy_data *bd);
 
-PurpleBuddy *qq_buddy_new(PurpleConnection *gc, UID uid);
-PurpleBuddy *qq_buddy_find_or_new(PurpleConnection *gc, UID uid);
-PurpleBuddy *qq_buddy_find(PurpleConnection *gc, UID uid);
+PurpleBuddy *qq_buddy_new(PurpleConnection *gc, guint32 uid);
+PurpleBuddy *qq_buddy_find_or_new(PurpleConnection *gc, guint32 uid);
+PurpleBuddy *qq_buddy_find(PurpleConnection *gc, guint32 uid);
 PurpleGroup *qq_group_find_or_new(const gchar *group_name);
 #endif
diff -urp libpurple/protocols/qq/ChangeLog libpurple/protocols/qq/ChangeLog
--- libpurple/protocols/qq/ChangeLog	2011-02-07 11:42:12.000000000 +0800
+++ libpurple/protocols/qq/ChangeLog	2011-02-24 17:38:51.990127000 +0800
@@ -1,12 +1,3 @@
-2010.01.23 - flos <lonicerae(at)gmail.com>
-	* added an option to force incoming message in chat room to use a default font instead of the font in message itself
-
-2010.01.18 - flos <lonicerae(at)gmail.com>
-	* added type 'UPDCLS' and 'UID' for implementing business logic layer
-
-2010.01.13 - ccpaging <ccpaging(at)gmail.com>
-	* qq2009-1 patch from ccpaging
-
 2009.04.23 - flos <lonicerae(at)gmail.com>
 	* Fixed a bug of updating buddy who is not in user's buddy list
 
diff -urp libpurple/protocols/qq/char_conv.c libpurple/protocols/qq/char_conv.c
--- libpurple/protocols/qq/char_conv.c	2011-01-08 23:19:45.000000000 +0800
+++ libpurple/protocols/qq/char_conv.c	2011-02-24 17:38:51.986793667 +0800
@@ -37,7 +37,7 @@
 
 /* convert a string from from_charset to to_charset, using g_convert */
 /* Warning: do not return NULL */
-static gchar *do_convert(const gchar *str, gssize len, guint8 *out_len, const gchar *to_charset, const gchar *from_charset)
+static gchar *do_convert(const gchar *str, gssize len, gsize *out_len, const gchar *to_charset, const gchar *from_charset)
 {
 	GError *error = NULL;
 	gchar *ret;
@@ -62,32 +62,47 @@ static gchar *do_convert(const gchar *st
 }
 
 /*
+ * Changed!!!! Check Every Invoke!!!!
  * take the input as a pascal string and return a converted c-string in UTF-8
+ * len_size is the size of length bytes in pascal string
+ * if from_charset == NULL, will not do the conversion
  * returns the number of bytes read, return -1 if fatal error
  * the converted UTF-8 will be saved in ret
  * Return: *ret != NULL
  */
-gint qq_get_vstr(gchar **ret, const gchar *from_charset, guint8 *data)
+gint qq_get_vstr( gchar **ret, const gchar *from_charset, gsize len_size, guint8 *data )
 {
-	gssize len;
-	guint8 out_len;
-
-	g_return_val_if_fail(data != NULL && from_charset != NULL, -1);
+	guint32 len = 0;
+	guint32 tmp = 0;
+	gint i;
+
+	g_return_val_if_fail(data != NULL, -1);
+
+	for (i=len_size-1; i>=0; --i) {
+		tmp = *((guint8 *)(data+i));
+		tmp <<= (len_size-i-1) * 8;
+		len ^= tmp;
+	}
 
-	len = data[0];
-	if (len == 0) {
+	if (len) {
+		if (from_charset)
+		{
+			*ret = do_convert((gchar *) (data + len_size), len, &len, UTF8, from_charset);
+		} else {
+			*ret = (gchar *)g_malloc0(len+1);
+			g_memmove(*ret, data+len_size, len);
+		}
+	} else {	
 		*ret = g_strdup("");
 		return 1;
 	}
-	*ret = do_convert((gchar *) (data + 1), len, &out_len, UTF8, from_charset);
-
-	return out_len + 1;
+	return len + len_size;
 }
 
 gint qq_put_vstr(guint8 *buf, const gchar *str_utf8, const gchar *to_charset)
 {
 	gchar *str;
-	guint8 len;
+	guint32 len;
 
 	if (str_utf8 == NULL || str_utf8[0] == '\0') {
 		buf[0] = 0;
diff -urp libpurple/protocols/qq/char_conv.h libpurple/protocols/qq/char_conv.h
--- libpurple/protocols/qq/char_conv.h	2011-01-08 23:19:45.000000000 +0800
+++ libpurple/protocols/qq/char_conv.h	2011-02-24 17:38:51.990127000 +0800
@@ -29,7 +29,7 @@
 
 #define QQ_CHARSET_DEFAULT      "GB18030"
 
-gint qq_get_vstr(gchar **ret, const gchar *from_charset, guint8 *data);
+gint qq_get_vstr(gchar **ret, const gchar *from_charset, gsize len_size, guint8 *data);
 gint qq_put_vstr(guint8 *buf, const gchar *str_utf8, const gchar *to_charset);
 
 gchar *utf8_to_qq(const gchar *str, const gchar *to_charset);
diff -urp libpurple/protocols/qq/file_trans.c libpurple/protocols/qq/file_trans.c
--- libpurple/protocols/qq/file_trans.c	2011-02-07 11:42:12.000000000 +0800
+++ libpurple/protocols/qq/file_trans.c	2011-02-24 17:38:51.943460335 +0800
@@ -38,12 +38,14 @@
 #include "send_file.h"
 #include "utils.h"
 
-typedef struct _qq_file_header {
+struct _qq_file_header {
 	guint16 client_ver;
 	guint8 file_key;
-	UID sender_uid;
-	UID receiver_uid;
-} qq_file_header;
+	guint32 sender_uid;
+	guint32 receiver_uid;
+};
+
+typedef struct _qq_file_header qq_file_header;
 
 static guint32 _get_file_key(guint8 seed)
 {
@@ -60,12 +62,12 @@ static guint32 _gen_file_key(void)
 	return _get_file_key(seed);
 }
 
-static guint32 _decrypt_qq_uid(UID uid, guint32 key)
+static guint32 _decrypt_qq_uid(guint32 uid, guint32 key)
 {
 	return ~(uid ^ key);
 }
 
-static guint32 _encrypt_qq_uid(UID uid, guint32 key)
+static guint32 _encrypt_qq_uid(guint32 uid, guint32 key)
 {
 	return (~uid) ^ key;
 }
@@ -230,7 +232,7 @@ void qq_xfer_close_file(PurpleXfer *xfer
 }
 #endif
 
-static gint _qq_send_file(PurpleConnection *gc, guint8 *data, gint len, guint16 packet_type, UID to_uid)
+static gint _qq_send_file(PurpleConnection *gc, guint8 *data, gint len, guint16 packet_type, guint32 to_uid)
 {
 	guint8 *raw_data;
 	gint bytes = 0;
@@ -257,7 +259,7 @@ static gint _qq_send_file(PurpleConnecti
 }
 
 /* send a file to udp channel with QQ_FILE_CONTROL_PACKET_TAG */
-void qq_send_file_ctl_packet(PurpleConnection *gc, guint16 packet_type, UID to_uid, guint8 hellobyte)
+void qq_send_file_ctl_packet(PurpleConnection *gc, guint16 packet_type, guint32 to_uid, guint8 hellobyte)
 {
 	qq_data *qd;
 	gint bytes, bytes_expected, encrypted_len;
diff -urp libpurple/protocols/qq/file_trans.h libpurple/protocols/qq/file_trans.h
--- libpurple/protocols/qq/file_trans.h	2011-02-07 11:42:12.000000000 +0800
+++ libpurple/protocols/qq/file_trans.h	2011-02-24 17:38:51.983460334 +0800
@@ -26,7 +26,6 @@
 #define _QQ_QQ_FILE_TRANS_H_
 
 #include "server.h"
-#include "qq.h"
 
 enum {
 	QQ_FILE_CMD_SENDER_SAY_HELLO = 0x31,
@@ -60,7 +59,7 @@ enum {
 #define QQ_FILE_AGENT_PACKET_TAG 0x04
 /* #define QQ_PACKET_TAIL          0x03 */   /* all QQ text packets end with it */
 
-void qq_send_file_ctl_packet(PurpleConnection *gc, guint16 packet_type, UID to_uid, guint8 hellobyte);
+void qq_send_file_ctl_packet(PurpleConnection *gc, guint16 packet_type, guint32 to_uid, guint8 hellobyte);
 void qq_process_recv_file(PurpleConnection *gc, guint8 *data, gint len);
 /* void qq_send_file_data_packet(PurpleConnection *gc, guint16 packet_type, guint8 sub_type, guint32 fragment_index, guint16 seq, guint8 *data, gint len); */
 void qq_xfer_close_file(PurpleXfer *xfer);
diff -urp libpurple/protocols/qq/group.h libpurple/protocols/qq/group.h
--- libpurple/protocols/qq/group.h	2011-02-07 11:42:12.000000000 +0800
+++ libpurple/protocols/qq/group.h	2011-02-24 17:38:51.986793667 +0800
@@ -31,7 +31,7 @@
 #include "roomlist.h"
 #include "qq.h"
 
-#define PURPLE_GROUP_QQ_QUN         "QQ "
+#define PURPLE_GROUP_QQ_ROOM         "QQ "
 
 typedef enum {
 	QQ_ROOM_ROLE_NO = 0x00,	/* default 0x00 means not member */
@@ -40,13 +40,14 @@ typedef enum {
 	QQ_ROOM_ROLE_ADMIN
 } qq_room_role;
 
-typedef struct _qq_room_data {
+typedef struct _qq_room_data qq_room_data;
+struct _qq_room_data {
 	/* all these will be saved when we exit Purple */
 	qq_room_role my_role;	/* my role for this room */
 	guint32 id;
 	guint32 ext_id;
 	guint8 type8;			/* permanent or temporory */
-	UID creator_uid;
+	guint32 creator_uid;
 	guint32 category;
 	guint8 auth_type;
 	gchar *title_utf8;
@@ -56,7 +57,7 @@ typedef struct _qq_room_data {
 
 	gboolean is_got_buddies;
 	GList *members;
-} qq_room_data;
+};
 
 GList *qq_chat_info(PurpleConnection *gc);
 GHashTable *qq_chat_info_defaults(PurpleConnection *gc, const gchar *chat_name);
diff -urp libpurple/protocols/qq/group_im.c libpurple/protocols/qq/group_im.c
--- libpurple/protocols/qq/group_im.c	2011-02-07 11:42:12.000000000 +0800
+++ libpurple/protocols/qq/group_im.c	2011-02-24 17:38:51.943460335 +0800
@@ -161,7 +161,7 @@ void qq_room_conv_set_onlines(PurpleConn
 }
 
 void qq_room_got_chat_in(PurpleConnection *gc,
-		guint32 room_id, UID uid_from, const gchar *msg, time_t in_time)
+		guint32 room_id, guint32 uid_from, const gchar *msg, time_t in_time)
 {
 	PurpleConversation *conv;
 	qq_data *qd;
@@ -207,11 +207,10 @@ void qq_process_room_im(guint8 *data, gi
 {
 	gchar *msg_smiley, *msg_fmt, *msg_utf8;
 	gint bytes, tail_len;
-	qq_data *qd;
 	struct {
 		guint32 ext_id;
 		guint8 type8;
-		UID member_uid;
+		guint32 member_uid;
 		guint16 unknown;
 		guint16 msg_seq;
 		time_t send_time;
@@ -223,29 +222,25 @@ void qq_process_room_im(guint8 *data, gi
 	guint16 content_type;
 	guint8 frag_count, frag_index;
 	guint16 msg_id;
-	guint32 use_default_font;
 	qq_im_format *fmt = NULL;
-	qd = (qq_data *) gc->proto_data;
 
 	/* at least include im_text.msg_len */
 	g_return_if_fail(data != NULL && data_len > 23);
 
-	use_default_font = (qd->custom) & QQ_CUSTOM_USE_DEFAULT_FONT;
-
 	/* qq_show_packet("ROOM_IM", data, data_len); */
 	memset(&im_text, 0, sizeof(im_text));
 	bytes = 0;
 	bytes += qq_get32(&(im_text.ext_id), data + bytes);
 	bytes += qq_get8(&(im_text.type8), data + bytes);
 
-	if(QQ_MSG_TEMP_QUN_IM == msg_type) {
+	if(QQ_MSG_TEMP_ROOM_IM == msg_type) {
 		bytes += qq_get32(&temp_id, data + bytes);
 	}
 
 	bytes += qq_get32(&(im_text.member_uid), bytes + data);
 	bytes += qq_get16(&im_text.unknown, data + bytes);	/* 0x0001? */
 	bytes += qq_get16(&(im_text.msg_seq), data + bytes);
-	bytes += qq_getime(&im_text.send_time, data + bytes);
+	bytes += qq_gettime(&im_text.send_time, data + bytes);
 	bytes += qq_get32(&im_text.version, data + bytes);
 	bytes += qq_get16(&(im_text.msg_len), data + bytes);
 	purple_debug_info("QQ", "Room IM, ext id %u, seq %u, version 0x%04X, len %u\n",
@@ -258,7 +253,7 @@ void qq_process_room_im(guint8 *data, gi
 	}
 
 	g_return_if_fail(im_text.msg_len > 0 && bytes + im_text.msg_len <= data_len);
-	if(msg_type != QQ_MSG_QUN_IM_UNKNOWN) {
+	if(msg_type != QQ_MSG_ROOM_IM_UNKNOWN) {
 		g_return_if_fail(im_text.msg_len >= 10);
 
 		bytes += qq_get16(&content_type, data + bytes);
@@ -274,7 +269,7 @@ void qq_process_room_im(guint8 *data, gi
 
 	/* qq_show_packet("Message", data + bytes, data_len - bytes); */
 	if (frag_count <= 1 || frag_count == frag_index + 1) {
-		fmt = qq_im_fmt_new();
+		fmt = qq_im_fmt_new_default();
 		tail_len = qq_get_im_tail(fmt, data + bytes, data_len - bytes);
 		im_text.msg = g_strndup((gchar *)(data + bytes), data_len - tail_len);
 	} else {
@@ -284,14 +279,8 @@ void qq_process_room_im(guint8 *data, gi
 	/* group im_group has no flag to indicate whether it has font_attr or not */
 	msg_smiley = qq_emoticon_to_purple(im_text.msg);
 	if (fmt != NULL) {
-		purple_debug_info("QQ", "going to use_default_font\n");
-		if (QQ_CUSTOM_USE_DEFAULT_FONT == use_default_font) {
-			qq_im_fmt_reset_font(fmt);
-			purple_debug_info("QQ", "use_default_font set\n");
-		}
-		msg_fmt = qq_im_fmt_to_purple(fmt, msg_smiley);
+		//msg_fmt = qq_im_fmt_to_purple(fmt, msg_smiley);
 		msg_utf8 =  qq_to_utf8(msg_fmt, QQ_CHARSET_DEFAULT);
-		purple_debug_info("QQ", "passed!\n");
 		g_free(msg_fmt);
 		qq_im_fmt_free(fmt);
 	} else {
@@ -318,7 +307,7 @@ static void request_room_send_im(PurpleC
 	bytes = 0;
 	bytes += qq_put16(raw_data + bytes, 0);
 	bytes += qq_putdata(raw_data + bytes, (guint8 *)msg, strlen(msg));
-	bytes += qq_put_im_tail(raw_data + bytes, fmt);
+	//bytes += qq_put_im_tail(raw_data + bytes, fmt);
 	/* reset first two bytes */
 	qq_put16(raw_data, bytes - 2);
 
diff -urp libpurple/protocols/qq/group_im.h libpurple/protocols/qq/group_im.h
--- libpurple/protocols/qq/group_im.h	2011-02-07 11:42:12.000000000 +0800
+++ libpurple/protocols/qq/group_im.h	2011-02-24 17:38:51.943460335 +0800
@@ -30,16 +30,11 @@
 #include "conversation.h"
 #include "group.h"
 
-enum {
-	QQ_CUSTOM_USE_DEFAULT_FONT = 0x00000001,
-	QQ_CUSTOM_NONE = 0x00000000
-};
-
 PurpleConversation *qq_room_conv_open(PurpleConnection *gc, qq_room_data *rmd);
 void qq_room_conv_set_onlines(PurpleConnection *gc, qq_room_data *rmd);
 
 void qq_room_got_chat_in(PurpleConnection *gc,
-		guint32 room_id, UID uid_from, const gchar *msg, time_t in_time);
+		guint32 room_id, guint32 uid_from, const gchar *msg, time_t in_time);
 
 int qq_chat_send(PurpleConnection *gc, int id, const char *message, PurpleMessageFlags flags);
 void qq_process_room_send_im(PurpleConnection *gc, guint8 *data, gint len);
@@ -48,4 +43,3 @@ void qq_process_room_send_im_ex(PurpleCo
 void qq_process_room_im(guint8 *data, gint data_len, guint32 id, PurpleConnection *gc, guint16 msg_type);
 
 #endif
-
diff -urp libpurple/protocols/qq/group_info.c libpurple/protocols/qq/group_info.c
--- libpurple/protocols/qq/group_info.c	2011-02-07 11:42:12.000000000 +0800
+++ libpurple/protocols/qq/group_info.c	2011-02-24 17:38:51.990127000 +0800
@@ -65,7 +65,7 @@ static void set_all_offline(qq_room_data
 }
 
 /* send packet to get info for each group member */
-gint qq_request_room_get_buddies(PurpleConnection *gc, guint32 room_id, UPDCLS update_class)
+gint qq_request_room_get_buddies(PurpleConnection *gc, guint32 room_id, guint32 update_class)
 {
 	guint8 *raw_data;
 	gint bytes, num;
@@ -177,8 +177,7 @@ void qq_process_room_cmd_get_info(guint8
 	PurpleConversation *conv;
 	guint8 organization, role;
 	guint16 unknown, max_members;
-	UID member_uid;
-	guint32 id, ext_id;
+	guint32 member_uid, id, ext_id;
 	guint32 unknown4;
 	guint8 unknown1;
 	gint bytes, num;
@@ -212,23 +211,23 @@ void qq_process_room_cmd_get_info(guint8
 	bytes += qq_get16(&max_members, data + bytes);
 	bytes += qq_get8(&unknown1, data + bytes);
 	/* the following, while Eva:
-	 * 4(unk), 4(verID), 1(nameLen), nameLen(qunNameContent), 1(0x00),
-	 * 2(qunNoticeLen), qunNoticeLen(qunNoticeContent, 1(qunDescLen),
-	 * qunDestLen(qunDestcontent)) */
+	 * 4(unk), 4(verID), 1(nameLen), nameLen(roomNameContent), 1(0x00),
+	 * 2(roomNoticeLen), roomNoticeLen(roomNoticeContent, 1(roomDescLen),
+	 * roomDestLen(roomDestcontent)) */
 	bytes += qq_get8(&unknown1, data + bytes);
 	purple_debug_info("QQ", "type: %u creator: %u category: %u maxmembers: %u\n",
 			rmd->type8, rmd->creator_uid, rmd->category, max_members);
 
-	if (qd->client_version >= 2007) {
+	if (qd->client_version >= 2010) {
 		/* skip 7 bytes unknow in qq2007 0x(00 00 01 00 00 00 fc)*/
 		bytes += 7;
 	}
 	/* qq_show_packet("Room Info", data + bytes, data_len - bytes); */
 	/* strlen + <str content> */
-	bytes += qq_get_vstr(&(rmd->title_utf8), QQ_CHARSET_DEFAULT, data + bytes);
+	bytes += qq_get_vstr(&(rmd->title_utf8), QQ_CHARSET_DEFAULT, sizeof(guint8), data + bytes);
 	bytes += qq_get16(&unknown, data + bytes);	/* 0x0000 */
-	bytes += qq_get_vstr(&notice, QQ_CHARSET_DEFAULT, data + bytes);
-	bytes += qq_get_vstr(&(rmd->desc_utf8), QQ_CHARSET_DEFAULT, data + bytes);
+	bytes += qq_get_vstr(&notice, QQ_CHARSET_DEFAULT, sizeof(guint8), data + bytes);
+	bytes += qq_get_vstr(&(rmd->desc_utf8), QQ_CHARSET_DEFAULT, sizeof(guint8), data + bytes);
 
 	purple_debug_info("QQ", "room [%s] notice [%s] desc [%s] unknow 0x%04X\n",
 			rmd->title_utf8, notice, rmd->desc_utf8, unknown);
@@ -263,7 +262,7 @@ void qq_process_room_cmd_get_info(guint8
 
 	/* filter \r\n in notice */
 	qq_filter_str(notice);
-	rmd->notice_utf8 = strdup(notice);
+	rmd->notice_utf8 = g_strdup(notice);
 	g_free(notice);
 
 	qq_room_update_chat_info(chat, rmd);
@@ -287,8 +286,7 @@ void qq_process_room_cmd_get_info(guint8
 
 void qq_process_room_cmd_get_onlines(guint8 *data, gint len, PurpleConnection *gc)
 {
-	guint32 room_id;
-	UID member_uid;
+	guint32 room_id, member_uid;
 	guint8 unknown;
 	gint bytes, num;
 	qq_room_data *rmd;
@@ -336,8 +334,7 @@ void qq_process_room_cmd_get_buddies(gui
 {
 	gint bytes;
 	gint num;
-	guint32 id;
-	UID member_uid;
+	guint32 id, member_uid;
 	guint16 unknown;
 	qq_room_data *rmd;
 	qq_buddy_data *bd;
@@ -366,7 +363,7 @@ void qq_process_room_cmd_get_buddies(gui
 		bytes += qq_get16(&(bd->face), data + bytes);
 		bytes += qq_get8(&(bd->age), data + bytes);
 		bytes += qq_get8(&(bd->gender), data + bytes);
-		bytes += qq_get_vstr(&nick, QQ_CHARSET_DEFAULT, data + bytes);
+		bytes += qq_get_vstr(&nick, QQ_CHARSET_DEFAULT, sizeof(guint8), data + bytes);
 		bytes += qq_get16(&unknown, data + bytes);
 		bytes += qq_get8(&(bd->ext_flag), data + bytes);
 		bytes += qq_get8(&(bd->comm_flag), data + bytes);
diff -urp libpurple/protocols/qq/group_info.h libpurple/protocols/qq/group_info.h
--- libpurple/protocols/qq/group_info.h	2011-02-07 11:42:12.000000000 +0800
+++ libpurple/protocols/qq/group_info.h	2011-02-24 17:38:51.993460334 +0800
@@ -34,7 +34,7 @@ enum {
 	QQ_ROOM_INFO_DISPLAY
 };
 
-gint qq_request_room_get_buddies(PurpleConnection *gc, guint32 room_id, UPDCLS update_class);
+gint qq_request_room_get_buddies(PurpleConnection *gc, guint32 room_id, guint32 update_class);
 
 void qq_process_room_cmd_get_info(guint8 *data, gint len, guint32 action, PurpleConnection *gc);
 void qq_process_room_cmd_get_onlines(guint8 *data, gint len, PurpleConnection *gc);
diff -urp libpurple/protocols/qq/group_internal.c libpurple/protocols/qq/group_internal.c
--- libpurple/protocols/qq/group_internal.c	2011-02-07 11:42:12.000000000 +0800
+++ libpurple/protocols/qq/group_internal.c	2011-02-24 17:38:52.010127001 +0800
@@ -139,7 +139,7 @@ static PurpleChat *chat_new(PurpleConnec
 	g_hash_table_insert(components, g_strdup(QQ_ROOM_KEY_TITLE_UTF8), g_strdup(rmd->title_utf8));
 
 	chat = purple_chat_new(purple_connection_get_account(gc), rmd->title_utf8, components);
-	g = qq_group_find_or_new(PURPLE_GROUP_QQ_QUN);
+	g = qq_group_find_or_new(PURPLE_GROUP_QQ_ROOM);
 	purple_blist_add_chat(chat, g, NULL);
 
 	return chat;
@@ -207,7 +207,7 @@ void qq_room_remove(PurpleConnection *gc
 }
 
 /* find a qq_buddy_data by uid, called by im.c */
-qq_buddy_data *qq_room_buddy_find(qq_room_data *rmd, UID uid)
+qq_buddy_data *qq_room_buddy_find(qq_room_data *rmd, guint32 uid)
 {
 	GList *list;
 	qq_buddy_data *bd;
@@ -226,7 +226,7 @@ qq_buddy_data *qq_room_buddy_find(qq_roo
 }
 
 /* remove a qq_buddy_data by uid, called by qq_group_opt.c */
-void qq_room_buddy_remove(qq_room_data *rmd, UID uid)
+void qq_room_buddy_remove(qq_room_data *rmd, guint32 uid)
 {
 	GList *list;
 	qq_buddy_data *bd;
@@ -244,7 +244,7 @@ void qq_room_buddy_remove(qq_room_data *
 	}
 }
 
-qq_buddy_data *qq_room_buddy_find_or_new(PurpleConnection *gc, qq_room_data *rmd, UID member_uid)
+qq_buddy_data *qq_room_buddy_find_or_new(PurpleConnection *gc, qq_room_data *rmd, guint32 member_uid)
 {
 	qq_buddy_data *member, *bd;
 	PurpleBuddy *buddy;
@@ -384,7 +384,7 @@ void qq_room_data_initial(PurpleConnecti
 	qd = (qq_data *) gc->proto_data;
 
 	purple_debug_info("QQ", "Initial QQ Qun configurations\n");
-	purple_group = purple_find_group(PURPLE_GROUP_QQ_QUN);
+	purple_group = purple_find_group(PURPLE_GROUP_QQ_ROOM);
 	if (purple_group == NULL) {
 		purple_debug_info("QQ", "We have no QQ Qun\n");
 		return;
diff -urp libpurple/protocols/qq/group_internal.h libpurple/protocols/qq/group_internal.h
--- libpurple/protocols/qq/group_internal.h	2011-02-07 11:42:12.000000000 +0800
+++ libpurple/protocols/qq/group_internal.h	2011-02-24 17:38:52.020127000 +0800
@@ -36,9 +36,9 @@ PurpleChat *qq_room_find_or_new(PurpleCo
 void qq_room_remove(PurpleConnection *gc, guint32 id);
 void qq_room_update_chat_info(PurpleChat *chat, qq_room_data *rmd);
 
-qq_buddy_data *qq_room_buddy_find(qq_room_data *rmd, UID uid);
-void qq_room_buddy_remove(qq_room_data *rmd, UID uid);
-qq_buddy_data *qq_room_buddy_find_or_new(PurpleConnection *gc, qq_room_data *rmd, UID member_uid);
+qq_buddy_data *qq_room_buddy_find(qq_room_data *rmd, guint32 uid);
+void qq_room_buddy_remove(qq_room_data *rmd, guint32 uid);
+qq_buddy_data *qq_room_buddy_find_or_new(PurpleConnection *gc, qq_room_data *rmd, guint32 member_uid);
 
 void qq_room_data_initial(PurpleConnection *gc);
 void qq_room_data_free_all(PurpleConnection *gc);
diff -urp libpurple/protocols/qq/group_join.c libpurple/protocols/qq/group_join.c
--- libpurple/protocols/qq/group_join.c	2011-02-07 11:42:12.000000000 +0800
+++ libpurple/protocols/qq/group_join.c	2011-02-24 17:38:51.990127000 +0800
@@ -155,7 +155,7 @@ static void do_room_join_request(PurpleC
 }
 
 void qq_send_cmd_group_auth(PurpleConnection *gc, qq_room_data *rmd,
-		guint8 opt, UID uid, const gchar *reason_utf8)
+		guint8 opt, guint32 uid, const gchar *reason_utf8)
 {
 	guint8 raw_data[MAX_PACKET_SIZE - 16];
 	gint bytes;
@@ -401,10 +401,10 @@ void qq_process_room_search(PurpleConnec
 	bytes += qq_get16(&(unknown), data + bytes);
 	bytes += qq_get16(&(unknown), data + bytes);
 	bytes += qq_get32(&(rmd.category), data + bytes);
-	bytes += qq_get_vstr(&(rmd.title_utf8), QQ_CHARSET_DEFAULT, data + bytes);
+	bytes += qq_get_vstr(&(rmd.title_utf8), QQ_CHARSET_DEFAULT, sizeof(guint8), data + bytes);
 	bytes += qq_get16(&(unknown), data + bytes);
 	bytes += qq_get8(&(rmd.auth_type), data + bytes);
-	bytes += qq_get_vstr(&(rmd.desc_utf8), QQ_CHARSET_DEFAULT, data + bytes);
+	bytes += qq_get_vstr(&(rmd.desc_utf8), QQ_CHARSET_DEFAULT, sizeof(guint8), data + bytes);
 	/* end of one qq_group */
 	if(bytes != len) {
 		purple_debug_error("QQ",
diff -urp libpurple/protocols/qq/group_join.h libpurple/protocols/qq/group_join.h
--- libpurple/protocols/qq/group_join.h	2011-02-07 11:42:12.000000000 +0800
+++ libpurple/protocols/qq/group_join.h	2011-02-24 17:38:51.993460334 +0800
@@ -49,7 +49,7 @@ enum {
 void qq_request_room_search(PurpleConnection *gc, guint32 ext_id, int action);
 void qq_process_room_search(PurpleConnection *gc, guint8 *data, gint len, guint32 ship32);
 
-void qq_send_cmd_group_auth(PurpleConnection *gc, qq_room_data *rmd, guint8 opt, UID uid, const gchar *reason_utf8);
+void qq_send_cmd_group_auth(PurpleConnection *gc, qq_room_data *rmd, guint8 opt, guint32 uid, const gchar *reason_utf8);
 void qq_group_join(PurpleConnection *gc, GHashTable *data);
 void qq_request_room_join(PurpleConnection *gc, qq_room_data *rmd);
 void qq_room_quit(PurpleConnection *gc, guint32 room_id);
@@ -57,4 +57,3 @@ void qq_process_group_cmd_exit_group(gui
 void qq_process_group_cmd_join_group_auth(guint8 *data, gint len, PurpleConnection *gc);
 void qq_process_group_cmd_join_group(guint8 *data, gint len, PurpleConnection *gc);
 #endif
-
diff -urp libpurple/protocols/qq/group_opt.c libpurple/protocols/qq/group_opt.c
--- libpurple/protocols/qq/group_opt.c	2011-01-08 23:19:45.000000000 +0800
+++ libpurple/protocols/qq/group_opt.c	2011-02-24 17:38:51.993460334 +0800
@@ -141,9 +141,9 @@ void qq_group_modify_members(PurpleConne
 	if (new_members[0] == 0xffffffff)
 		return;
 
-	old_members = g_newa(guint32, QQ_QUN_MEMBER_MAX);
-	del_members = g_newa(guint32, QQ_QUN_MEMBER_MAX);
-	add_members = g_newa(guint32, QQ_QUN_MEMBER_MAX);
+	old_members = g_newa(guint32, QQ_ROOM_MEMBER_MAX);
+	del_members = g_newa(guint32, QQ_ROOM_MEMBER_MAX);
+	add_members = g_newa(guint32, QQ_ROOM_MEMBER_MAX);
 
 	/* construct the old member list */
 	list = rmd->members;
@@ -412,7 +412,7 @@ void qq_process_room_buddy_request_join(
 
 	g_return_if_fail(ext_id > 0 && member_id > 0);
 
-	bytes += qq_get_vstr(&reason, QQ_CHARSET_DEFAULT, data + bytes);
+	bytes += qq_get_vstr(&reason, QQ_CHARSET_DEFAULT, sizeof(guint8), data + bytes);
 
 	purple_debug_info("QQ", "%u requested to join room, ext id %u\n", member_id, ext_id);
 
@@ -472,7 +472,7 @@ void qq_process_room_buddy_rejected(guin
 
 	g_return_if_fail(ext_id > 0 && admin_uid > 0);
 
-	bytes += qq_get_vstr(&reason, QQ_CHARSET_DEFAULT, data + bytes);
+	bytes += qq_get_vstr(&reason, QQ_CHARSET_DEFAULT, sizeof(guint8), data + bytes);
 
 	msg = g_strdup_printf
 		(_("Failed to join Qun %u, operated by admin %u"), ext_id, admin_uid);
@@ -508,8 +508,8 @@ void qq_process_room_buddy_approved(guin
 	bytes += qq_get32(&admin_uid, data + bytes);
 
 	g_return_if_fail(ext_id > 0 && admin_uid > 0);
-	/* it is also a "" here, so do not display */
-	bytes += qq_get_vstr(&reason, QQ_CHARSET_DEFAULT, data + bytes);
+	/* it is also a "" here, so do not display */
+	bytes += qq_get_vstr(&reason, QQ_CHARSET_DEFAULT, sizeof(guint8), data + bytes);
 
 	qq_room_find_or_new(gc, id, ext_id);
 	rmd = qq_room_data_find(gc, id);
diff -urp libpurple/protocols/qq/group_opt.h libpurple/protocols/qq/group_opt.h
--- libpurple/protocols/qq/group_opt.h	2011-01-08 23:19:45.000000000 +0800
+++ libpurple/protocols/qq/group_opt.h	2011-02-24 17:38:51.993460334 +0800
@@ -29,7 +29,7 @@
 #include "connection.h"
 #include "group.h"
 
-#define QQ_QUN_MEMBER_MAX       80	/* max number of the group */
+#define QQ_ROOM_MEMBER_MAX       80	/* max number of the group */
 
 typedef struct _qq_room_req {
 	PurpleConnection *gc;
diff -urp libpurple/protocols/qq/im.c libpurple/protocols/qq/im.c
--- libpurple/protocols/qq/im.c	2011-02-07 11:42:12.000000000 +0800
+++ libpurple/protocols/qq/im.c	2011-02-24 17:38:51.906793668 +0800
@@ -42,7 +42,7 @@
 #include "send_file.h"
 #include "utils.h"
 
-#define QQ_MSG_IM_MAX               700	/* max length of IM */
+#define QQ_MSG_IM_MAX               513	/* max length of IM */
 
 enum {
 	QQ_IM_TEXT = 0x01,
@@ -51,7 +51,7 @@ enum {
 
 enum
 {
-	QQ_NORMAL_IM_TEXT = 0x000b,
+	QQ_NORMAL_IM_TEXT = 0x000B,
 	QQ_NORMAL_IM_FILE_REQUEST_TCP = 0x0001,
 	QQ_NORMAL_IM_FILE_APPROVE_TCP = 0x0003,
 	QQ_NORMAL_IM_FILE_REJECT_TCP = 0x0005,
@@ -67,14 +67,15 @@ enum
 	QQ_NORMAL_IM_FILE_EX_NOTIFY_IP = 0x87
 };
 
-typedef struct _qq_im_header {
+typedef struct _qq_im_header qq_im_header;
+struct _qq_im_header {
 	/* this is the common part of normal_text */
 	guint16 version_from;
-	UID uid_from;
-	UID uid_to;
+	guint32 uid_from;
+	guint32 uid_to;
 	guint8 session_md5[QQ_KEY_LENGTH];
 	guint16 im_type;
-} qq_im_header;
+};
 
 /* read the common parts of the normal_im,
  * returns the bytes read if succeed, or -1 if there is any error */
@@ -92,10 +93,11 @@ static gint get_im_header(qq_im_header *
 	return bytes;
 }
 
-typedef struct _qq_emoticon {
+typedef struct _qq_emoticon qq_emoticon;
+struct _qq_emoticon {
 	guint8 symbol;
 	gchar *name;
-} qq_emoticon;
+};
 
 static gboolean emoticons_is_sorted = FALSE;
 /* Map for purple smiley convert to qq, need qsort */
@@ -523,34 +525,23 @@ void qq_im_fmt_free(qq_im_format *fmt)
 	g_free(fmt);
 }
 
-qq_im_format *qq_im_fmt_new(void)
+qq_im_format *qq_im_fmt_new_default(void)
 {
 	qq_im_format *fmt;
-	/* '0xcb, 0xce, 0xcc, 0xe5' means Chinese '' in utf8 */
-	const gchar simsun[] = { 0xcb, 0xce, 0xcc, 0xe5, 0};
-
+	const gchar msyh[] = {
+		0xE5, 0xBE, 0xAE, 0xE8, 0xBD, 0xAF, 0xE9, 0x9B, 0x85, 0xE9, 0xBB, 0x91, 0x00
+	};		/*Microsoft YaHei*/
 	fmt = g_new0(qq_im_format, 1);
 	memset(fmt, 0, sizeof(qq_im_format));
-	fmt->font_len = strlen(simsun);
-	fmt->font = g_strdup(simsun);
-	fmt->attr = 10;
-	/* encoding, 0x8602=GB, 0x0000=EN, define BIG5 support here */
-	fmt->charset = 0x8602;
+	fmt->font_len = strlen(msyh);
+	fmt->font = g_strdup(msyh);
+	fmt->font_size = 14;
+	/* encoding, 0x8622=GB, 0x0000=EN */
+	fmt->charset = 0x8622;
 
 	return fmt;
 }
 
-void qq_im_fmt_reset_font(qq_im_format *fmt)
-{
-	const gchar simsun[] = {0xcb, 0xce, 0xcc, 0xe5, 0x00};
-	g_return_if_fail(NULL != fmt);
-
-	if (NULL != fmt->font) {
-		g_free(fmt->font);
-		fmt->font = g_strdup(simsun);
-	}
-}
-
 qq_im_format *qq_im_fmt_new_by_purple(const gchar *msg)
 {
 	qq_im_format *fmt;
@@ -560,7 +551,7 @@ qq_im_format *qq_im_fmt_new_by_purple(co
 
 	g_return_val_if_fail(msg != NULL, NULL);
 
-	fmt = qq_im_fmt_new();
+	fmt = qq_im_fmt_new_default();
 
 	last = msg;
 	while (purple_markup_find_tag("font", last, &start, &end, &attribs)) {
@@ -592,99 +583,69 @@ qq_im_format *qq_im_fmt_new_by_purple(co
 	}
 
 	if (purple_markup_find_tag("b", msg, &start, &end, &attribs)) {
-		fmt->attr |= 0x20;
+		fmt->attr ^= 0x01;
 		g_datalist_clear(&attribs);
 	}
 
 	if (purple_markup_find_tag("i", msg, &start, &end, &attribs)) {
-		fmt->attr |= 0x40;
+		fmt->attr ^= 0x02;
 		g_datalist_clear(&attribs);
 	}
 
 	if (purple_markup_find_tag("u", msg, &start, &end, &attribs)) {
-		fmt->attr |= 0x80;
+		fmt->attr ^= 0x04;
 		g_datalist_clear(&attribs);
 	}
 
 	return fmt;
 }
 
-/* convert qq format to purple
-   Notice: text is in qq charset, GB18030 or utf8 */
-gchar *qq_im_fmt_to_purple(qq_im_format *fmt, gchar *text)
+/* convert qq format to purple */
+gchar * qq_im_fmt_to_purple( qq_im_format *fmt, GString *text )
 {
-	GString *converted, *tmp;
+	GString *tmp;
 	gchar *ret;
-	gint size;
 
-	converted = g_string_new(text);
 	tmp = g_string_new("");
 	g_string_append_printf(tmp, "<font color=\"#%02x%02x%02x\">",
 		fmt->rgb[0], fmt->rgb[1], fmt->rgb[2]);
-	g_string_prepend(converted, tmp->str);
+	g_string_prepend(text, tmp->str);
 	g_string_set_size(tmp, 0);
-	g_string_append(converted, "</font>");
+	g_string_append(text, "</font>");
 
-	/* Fixme:
-	 * check font face can be convert to utf8 or not?
-	 * If failed, prepending font face cause msg display as "(NULL)" */
 	if (fmt->font != NULL) {
 		g_string_append_printf(tmp, "<font face=\"%s\">", fmt->font);
-		g_string_prepend(converted, tmp->str);
+		g_string_prepend(text, tmp->str);
 		g_string_set_size(tmp, 0);
-		g_string_append(converted, "</font>");
+		g_string_append(text, "</font>");
 	}
-	size = (fmt->attr & 0x1f) / 3;
-	if (size >= 0) {
-		g_string_append_printf(tmp, "<font size=\"%d\">", size);
-		g_string_prepend(converted, tmp->str);
+	if (fmt->font_size >= 0) {
+		g_string_append_printf(tmp, "<font size=\"%d\">", fmt->font_size);
+		g_string_prepend(text, tmp->str);
 		g_string_set_size(tmp, 0);
-		g_string_append(converted, "</font>");
+		g_string_append(text, "</font>");
 	}
-	if (fmt->attr & 0x20) {
+	if (fmt->attr & 0x01) {
 		/* bold */
-		g_string_prepend(converted, "<b>");
-		g_string_append(converted, "</b>");
+		g_string_prepend(text, "<b>");
+		g_string_append(text, "</b>");
 	}
-	if (fmt->attr & 0x40) {
+	if (fmt->attr & 0x02) {
 		/* italic */
-		g_string_prepend(converted, "<i>");
-		g_string_append(converted, "</i>");
+		g_string_prepend(text, "<i>");
+		g_string_append(text, "</i>");
 	}
-	if (fmt->attr & 0x80) {
+	if (fmt->attr & 0x04) {
 		/* underline */
-		g_string_prepend(converted, "<u>");
-		g_string_append(converted, "</u>");
+		g_string_prepend(text, "<u>");
+		g_string_append(text, "</u>");
 	}
 
 	g_string_free(tmp, TRUE);
-	ret = converted->str;
-	g_string_free(converted, FALSE);
+	ret = text->str;
 	return ret;
 }
 
-gint qq_put_im_tail(guint8 *buf, qq_im_format *fmt)
-{
-	gint bytes;
-
-	g_return_val_if_fail(buf != NULL && fmt != NULL, 0);
-
-	bytes = 0;
-	bytes += qq_put8(buf + bytes, 0);
-	bytes += qq_put8(buf + bytes, fmt->attr);
-	bytes += qq_putdata(buf + bytes, fmt->rgb, sizeof(fmt->rgb));
-	bytes += qq_put8(buf + bytes, 0);
-	bytes += qq_put16(buf + bytes, fmt->charset);
-	if (fmt->font != NULL && fmt->font_len > 0) {
-		bytes += qq_putdata(buf + bytes, (guint8 *)fmt->font, fmt->font_len);
-	} else {
-		purple_debug_warning("QQ", "Font name is empty\n");
-	}
-	bytes += qq_put8(buf + bytes, bytes + 1);
-	/* qq_show_packet("IM tail", buf, bytes); */
-	return bytes;
-}
-
 /* data includes text msg and font attr*/
 gint qq_get_im_tail(qq_im_format *fmt, guint8 *data, gint data_len)
 {
@@ -735,18 +696,25 @@ void qq_got_message(PurpleConnection *gc
 }
 
 /* process received normal text IM */
-static void process_im_text(PurpleConnection *gc, guint8 *data, gint len, qq_im_header *im_header)
+static void process_im_text(PurpleConnection *gc, guint8 *data, gint len, qq_im_header *im_header, guint16 msg_type)
 {
-	guint16 purple_msg_type;
+	guint16 purple_msg_flag;
 	gchar *who;
 	gchar *msg_smiley, *msg_fmt, *msg_utf8;
 	PurpleBuddy *buddy;
 	qq_buddy_data *bd;
 	gint bytes, tail_len;
 	qq_im_format *fmt = NULL;
+	guint8 type;
+	guint8 *msg_data;
+	//guint msg_dataseg_len;
+	//guint8 msg_dataseg_flag;
+	//guint msg_dataseg_pos;
+	gchar *text;
+	gchar *emoticon;
+	gchar *purple_smiley;
 
 	struct {
-		/* now comes the part for text only */
 		guint16 msg_seq;
 		guint32 send_time;
 		guint16 sender_icon;
@@ -754,10 +722,10 @@ static void process_im_text(PurpleConnec
 		guint8 has_font_attr;
 		guint8 fragment_count;
 		guint8 fragment_index;
-		guint8 msg_id;
+		guint16 msg_id;
 		guint8 unknown2;
-		guint8 msg_type;
-		gchar *msg;		/* no fixed length, ends with 0x00 */
+		guint8 auto_reply;
+		GString *msg;		/* no fixed length, ends with 0x00 */
 	} im_text;
 
 	g_return_if_fail(data != NULL && len > 0);
@@ -774,23 +742,13 @@ static void process_im_text(PurpleConnec
 	bytes += qq_get8(&(im_text.has_font_attr), data + bytes);
 	bytes += qq_get8(&(im_text.fragment_count), data + bytes);
 	bytes += qq_get8(&(im_text.fragment_index), data + bytes);
-	bytes += qq_get8(&(im_text.msg_id), data + bytes);
-	bytes += 1; 	/* skip 0x00 */
-	bytes += qq_get8(&(im_text.msg_type), data + bytes);
+	bytes += qq_get16(&(im_text.msg_id), data + bytes);
+	bytes += qq_get8(&(im_text.auto_reply), data + bytes);
 	purple_debug_info("QQ", "IM Seq %u, id %04X, fragment %d-%d, type %d, %s\n",
 			im_text.msg_seq, im_text.msg_id,
 			im_text.fragment_count, im_text.fragment_index,
-			im_text.msg_type,
-			im_text.has_font_attr ? "exist font atrr" : "");
-
-	if (im_text.has_font_attr) {
-		fmt = qq_im_fmt_new();
-		tail_len = qq_get_im_tail(fmt, data + bytes, len - bytes);
-		im_text.msg = g_strndup((gchar *)(data + bytes), len - tail_len);
-	} else	{
-		im_text.msg = g_strndup((gchar *)(data + bytes), len - bytes);
-	}
-	/* qq_show_packet("IM text", (guint8 *)im_text.msg , strlen(im_text.msg) ); */
+			im_text.auto_reply,
+			im_text.has_font_attr ? "exist font attr" : "");
 
 	who = uid_to_purple_name(im_header->uid_from);
 	buddy = purple_find_buddy(gc->account, who);
@@ -804,131 +762,124 @@ static void process_im_text(PurpleConnec
 		bd->face = im_text.sender_icon;
 		qq_update_buddy_icon(gc->account, who, bd->face);
 	}
-
-	purple_msg_type = (im_text.msg_type == QQ_IM_AUTO_REPLY)
+	purple_msg_flag = (im_text.auto_reply == QQ_IM_AUTO_REPLY)
 		? PURPLE_MESSAGE_AUTO_RESP : 0;
 
-	msg_smiley = qq_emoticon_to_purple(im_text.msg);
-	if (fmt != NULL) {
-		msg_fmt = qq_im_fmt_to_purple(fmt, msg_smiley);
-		msg_utf8 =  qq_to_utf8(msg_fmt, QQ_CHARSET_DEFAULT);
-		g_free(msg_fmt);
-		qq_im_fmt_free(fmt);
-	} else {
-		msg_utf8 =  qq_to_utf8(msg_smiley, QQ_CHARSET_DEFAULT);
-	}
-	g_free(msg_smiley);
-
-	/* send encoded to purple, note that we use im_text.send_time,
-	 * not the time we receive the message
-	 * as it may have been delayed when I am not online. */
-	purple_debug_info("QQ", "IM from %u: %s\n", im_header->uid_from,msg_utf8);
-	serv_got_im(gc, who, msg_utf8, purple_msg_type, (time_t) im_text.send_time);
-
-	g_free(msg_utf8);
-	g_free(who);
-	g_free(im_text.msg);
-}
-
-/* process received extended (2007) text IM */
-static void process_extend_im_text(PurpleConnection *gc, guint8 *data, gint len, qq_im_header *im_header)
-{
-	guint16 purple_msg_type;
-	gchar *who;
-	gchar *msg_smiley, *msg_fmt, *msg_utf8;
-	PurpleBuddy *buddy;
-	qq_buddy_data *bd;
-	gint bytes, tail_len;
-	qq_im_format *fmt = NULL;
-
-	struct {
-		/* now comes the part for text only */
-		guint16 msg_seq;
-		guint32 send_time;
-		guint16 sender_icon;
-		guint32 has_font_attr;
-		guint8 unknown1[8];
-		guint8 fragment_count;
-		guint8 fragment_index;
-		guint8 msg_id;
-		guint8 unknown2;
-		guint8 msg_type;
-		gchar *msg;		/* no fixed length, ends with 0x00 */
-		guint8 fromMobileQQ;
-	} im_text;
-
-	g_return_if_fail(data != NULL && len > 0);
-	g_return_if_fail(im_header != NULL);
-
-	memset(&im_text, 0, sizeof(im_text));
+	if (msg_type == QQ_MSG_BUDDY_A6 || msg_type == QQ_MSG_BUDDY_78)
+	{
+		bytes += 8;		//4d 53 47 00 00 00 00 00		MSG.....
+		bytes += qq_get32(&(im_text.send_time), data + bytes);
+		bytes += 4;		//random guint32;
+
+		if (im_text.has_font_attr)
+		{
+			fmt = g_new0(qq_im_format, 1);
+			
+			bytes += 1;		//Unknown 0x00
+
+			bytes += qq_get8(&fmt->rgb[0], data+bytes);
+			bytes += qq_get8(&fmt->rgb[1], data+bytes);
+			bytes += qq_get8(&fmt->rgb[2], data+bytes);
+
+			bytes += qq_get8(&fmt->font_size, data+bytes);
+			/* font attr guint8 : bold:00000001 XOR italic 00000010 XOR underline 00000100*/
+			bytes += qq_get8(&fmt->attr, data+bytes);
+			/* encoding, 0x8622=GB, 0x0000=EN */
+			bytes += qq_get16(&fmt->charset, data+bytes);
+
+			bytes += qq_get_vstr(&fmt->font, NULL, sizeof(guint16), data+bytes);
+		} 
+
+		bytes += 2;
+		im_text.msg = g_string_new("");
+		while (bytes < len) {
+			bytes += qq_get8(&type, data+bytes);
+			bytes += qq_get_vstr(&msg_data, NULL, sizeof(guint16), data+bytes);
+			//bytes += msg_dataseg_len = qq_get_vstr(&msg_data, NULL, sizeof(guint16), data+bytes);
+			//msg_dataseg_len -= sizeof(guint16);
+
+			switch (type) {
+			case 0x01:	//text
+				qq_get_vstr(&text, NULL, sizeof(guint16), msg_data+1);		//+1 bypass msg_dataseg_flag 0x01
+				g_free(msg_data);
+				g_string_append(im_text.msg, text);
+				g_free(text);
+				break;
+			case 0x02:	//emoticon
+				qq_get_vstr(&emoticon, NULL, sizeof(guint16), msg_data+1);		//+1 bypass msg_dataseg_flag 0x01
+				/* remained Unknown data is FF 00 02 14 XX ; FF Unknown msg_dataseg_flag */
+				g_free(msg_data);
+				purple_smiley = emoticon_get(*emoticon);
+				if (purple_smiley == NULL) {
+					purple_debug_info("QQ", "Not found smiley of 0x%02X\n", *emoticon);
+					g_string_append(im_text.msg, "<IMG ID=\"0\">");
+				} else {
+					purple_debug_info("QQ", "Found 0x%02X smiley is %s\n", *emoticon, purple_smiley);
+					g_string_append(im_text.msg, purple_smiley);
+				}
+				g_free(emoticon);
+				break;
+			case 03:	//image
+				break;
+				/*		it's kinda complicated, TOFIX later
+				msg_dataseg_pos = 0;
+				while (msg_dataseg_pos < msg_dataseg_len)
+				{
+					msg_dataseg_pos = qq_get8(&msg_dataseg_flag, msg_data);
+					switch (msg_dataseg_flag)
+					{
+					case 0x0:
+						break;
+					}
+				}
+				*/
+			}
+		}
 
-	/* qq_show_packet("Extend IM text", data, len); */
-	bytes = 0;
-	bytes += qq_get16(&(im_text.msg_seq), data + bytes);
-	bytes += qq_get32(&(im_text.send_time), data + bytes);
-	bytes += qq_get16(&(im_text.sender_icon), data + bytes);
-	bytes += qq_get32(&(im_text.has_font_attr), data + bytes);
-	bytes += qq_getdata(im_text.unknown1, sizeof(im_text.unknown1), data + bytes);
-	bytes += qq_get8(&(im_text.fragment_count), data + bytes);
-	bytes += qq_get8(&(im_text.fragment_index), data + bytes);
-	bytes += qq_get8(&(im_text.msg_id), data + bytes);
-	bytes += 1; 	/* skip 0x00 */
-	bytes += qq_get8(&(im_text.msg_type), data + bytes);
-	purple_debug_info("QQ", "IM Seq %u, id %04X, fragment %d-%d, type %d, %s\n",
-			im_text.msg_seq, im_text.msg_id,
-			im_text.fragment_count, im_text.fragment_index,
-			im_text.msg_type,
-			im_text.has_font_attr ? "exist font atrr" : "");
+		if (fmt != NULL) {
+			msg_utf8 = qq_im_fmt_to_purple(fmt, im_text.msg);
+			qq_im_fmt_free(fmt);
+		} else {
+			msg_utf8 =  im_text.msg->str;
+		}
 
-	if (im_text.has_font_attr) {
-		fmt = qq_im_fmt_new();
-		tail_len = qq_get_im_tail(fmt, data + bytes, len - bytes);
-		im_text.msg = g_strndup((gchar *)(data + bytes), len - tail_len);
-	} else	{
-		im_text.msg = g_strndup((gchar *)(data + bytes), len - bytes);
-	}
-	/* qq_show_packet("IM text", (guint8 *)im_text.msg , strlen(im_text.msg)); */
+	} else {
 
-	if(im_text.fragment_count == 0) 	im_text.fragment_count = 1;
+		if (im_text.has_font_attr) {
+			fmt = qq_im_fmt_new_default();
+			tail_len = qq_get_im_tail(fmt, data + bytes, len - bytes);
+			im_text.msg = g_string_new_len((gchar *)(data + bytes), len-tail_len);
+		} else	{
+			im_text.msg = g_string_new_len((gchar *)(data + bytes), len - bytes);
+		}
+		msg_smiley = qq_emoticon_to_purple(im_text.msg->str);
+		if (fmt != NULL) {
+			msg_fmt = qq_im_fmt_to_purple(fmt, g_string_new(msg_smiley));
+			msg_utf8 =  qq_to_utf8(msg_fmt, QQ_CHARSET_DEFAULT);
+			g_free(msg_fmt);
+			qq_im_fmt_free(fmt);
+		} else {
+			msg_utf8 =  qq_to_utf8(msg_smiley, QQ_CHARSET_DEFAULT);
+		}
+		g_free(msg_smiley);
 
-	who = uid_to_purple_name(im_header->uid_from);
-	buddy = purple_find_buddy(gc->account, who);
-	if (buddy == NULL) {
-		/* create no-auth buddy */
-		buddy = qq_buddy_new(gc, im_header->uid_from);
-	}
-	bd = (buddy == NULL) ? NULL : purple_buddy_get_protocol_data(buddy);
-	if (bd != NULL) {
-		bd->client_tag = im_header->version_from;
-		bd->face = im_text.sender_icon;
-		qq_update_buddy_icon(gc->account, who, bd->face);
 	}
 
-	purple_msg_type = 0;
-
-	msg_smiley = qq_emoticon_to_purple(im_text.msg);
-	if (fmt != NULL) {
-		msg_fmt = qq_im_fmt_to_purple(fmt, msg_smiley);
-		msg_utf8 =  qq_to_utf8(msg_fmt, QQ_CHARSET_DEFAULT);
-		g_free(msg_fmt);
-		qq_im_fmt_free(fmt);
-	} else {
-		msg_utf8 =  qq_to_utf8(msg_smiley, QQ_CHARSET_DEFAULT);
-	}
-	g_free(msg_smiley);
+	/* qq_show_packet("IM text", (guint8 *)im_text.msg , strlen(im_text.msg) ); */
 
 	/* send encoded to purple, note that we use im_text.send_time,
 	 * not the time we receive the message
 	 * as it may have been delayed when I am not online. */
-	serv_got_im(gc, who, msg_utf8, purple_msg_type, (time_t) im_text.send_time);
+	purple_debug_info("QQ", "IM from %u: %s\n", im_header->uid_from,msg_utf8);
+	serv_got_im(gc, who, msg_utf8, purple_msg_flag, (time_t) im_text.send_time);
 
 	g_free(msg_utf8);
 	g_free(who);
-	g_free(im_text.msg);
+	g_string_free (im_text.msg, TRUE);
 }
 
 /* it is a normal IM, maybe text or video request */
-void qq_process_im(PurpleConnection *gc, guint8 *data, gint len)
+void qq_process_im( PurpleConnection *gc, guint8 *data, gint len, guint16 msg_type )
 {
 	gint bytes = 0;
 	qq_im_header im_header;
@@ -952,7 +903,7 @@ void qq_process_im(PurpleConnection *gc,
 				purple_debug_warning("QQ", "Received normal IM text is empty\n");
 				return;
 			}
-			process_im_text(gc, data + bytes, len - bytes, &im_header);
+			process_im_text(gc, data + bytes, len - bytes, &im_header, msg_type);
 			break;
 		case QQ_NORMAL_IM_FILE_REJECT_UDP:
 			qq_process_recv_file_reject(data + bytes, len - bytes, im_header.uid_from, gc);
@@ -988,72 +939,19 @@ void qq_process_im(PurpleConnection *gc,
 	}
 }
 
-/* it is a extended IM, maybe text or video request */
-void qq_process_extend_im(PurpleConnection *gc, guint8 *data, gint len)
-{
-	gint bytes;
-	qq_im_header im_header;
-
-	g_return_if_fail (data != NULL && len > 0);
-
-	bytes = get_im_header(&im_header, data, len);
-	if (bytes < 0) {
-		purple_debug_error("QQ", "Fail read im header, len %d\n", len);
-		qq_show_packet ("IM Header", data, len);
-		return;
-	}
-	purple_debug_info("QQ",
-			"Got Extend IM to %u, type: %02X from: %u ver: %s (%04X)\n",
-			im_header.uid_to, im_header.im_type, im_header.uid_from,
-			qq_get_ver_desc(im_header.version_from), im_header.version_from);
-
-	switch (im_header.im_type) {
-		case QQ_NORMAL_IM_TEXT:
-			process_extend_im_text(gc, data + bytes, len - bytes, &im_header);
-			break;
-		case QQ_NORMAL_IM_FILE_REJECT_UDP:
-			qq_process_recv_file_reject (data + bytes, len - bytes, im_header.uid_from, gc);
-			break;
-		case QQ_NORMAL_IM_FILE_APPROVE_UDP:
-			qq_process_recv_file_accept (data + bytes, len - bytes, im_header.uid_from, gc);
-			break;
-		case QQ_NORMAL_IM_FILE_REQUEST_UDP:
-			qq_process_recv_file_request (data + bytes, len - bytes, im_header.uid_from, gc);
-			break;
-		case QQ_NORMAL_IM_FILE_CANCEL:
-			qq_process_recv_file_cancel (data + bytes, len - bytes, im_header.uid_from, gc);
-			break;
-		case QQ_NORMAL_IM_FILE_NOTIFY:
-			qq_process_recv_file_notify (data + bytes, len - bytes, im_header.uid_from, gc);
-			break;
-		case QQ_NORMAL_IM_FILE_REQUEST_TCP:
-			/* Check ReceivedFileIM::parseContents in eva*/
-			/* some client use this function for detect invisable buddy*/
-		case QQ_NORMAL_IM_FILE_APPROVE_TCP:
-		case QQ_NORMAL_IM_FILE_REJECT_TCP:
-		case QQ_NORMAL_IM_FILE_PASV:
-		case QQ_NORMAL_IM_FILE_EX_REQUEST_UDP:
-		case QQ_NORMAL_IM_FILE_EX_REQUEST_ACCEPT:
-		case QQ_NORMAL_IM_FILE_EX_REQUEST_CANCEL:
-		case QQ_NORMAL_IM_FILE_EX_NOTIFY_IP:
-			qq_show_packet ("Not support", data, len);
-			break;
-		default:
-			/* a simple process here, maybe more later */
-			qq_show_packet ("Unknow", data + bytes, len - bytes);
-			break;
-	}
-}
-
 /* send an IM to uid_to */
-static void request_send_im(PurpleConnection *gc, UID uid_to, gint type,
-	qq_im_format *fmt, gchar *msg, guint8 id, guint8 frag_count, guint8 frag_index)
+static void request_send_im(PurpleConnection *gc, guint32 uid_to, guint8 type, qq_im_format *fmt, GString *msg, guint16 msg_id, guint8 frag_count, guint8 frag_index)
 {
 	qq_data *qd;
-	guint8 raw_data[MAX_PACKET_SIZE - 16];
+	guint8 raw_data[1024];
 	gint bytes;
 	time_t now;
-
+	static guint8 fill[] = {
+		0x00, 0x00, 0x00, 0x0D, 
+		0x00, 0x01, 0x00, 0x04,
+		0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x03, 0x00, 0x01, 0x01
+	};
 	qd = (qq_data *) gc->proto_data;
 
 	/* purple_debug_info("QQ", "Send IM %d-%d\n", frag_count, frag_index); */
@@ -1062,124 +960,138 @@ static void request_send_im(PurpleConnec
 	bytes += qq_put32(raw_data + bytes, qd->uid);
 	/* 004-007: sender uid */
 	bytes += qq_put32(raw_data + bytes, uid_to);
-	/* 008-009: sender client version */
+	/* 008-024: Unknown */
+	bytes += qq_putdata(raw_data + bytes, fill, sizeof(fill));
+	/* 025-026: sender client version */
 	bytes += qq_put16(raw_data + bytes, qd->client_tag);
-	/* 010-013: receiver uid */
+	/* 027-030: receiver uid */
 	bytes += qq_put32(raw_data + bytes, qd->uid);
-	/* 014-017: sender uid */
+	/* 031-034: sender uid */
 	bytes += qq_put32(raw_data + bytes, uid_to);
-	/* 018-033: md5 of (uid+session_key) */
+	/* 035-040: md5 of (uid+session_key) */
 	bytes += qq_putdata(raw_data + bytes, qd->session_md5, 16);
-	/* 034-035: message type */
+	/* 041-042: message type */
 	bytes += qq_put16(raw_data + bytes, QQ_NORMAL_IM_TEXT);
-	/* 036-037: sequence number */
+	/* 042-043: sequence number */
 	bytes += qq_put16(raw_data + bytes, qd->send_seq);
-	/* 038-041: send time */
+	/* 044-047: send time */
 	now = time(NULL);
 	bytes += qq_put32(raw_data + bytes, (guint32) now);
-	/* 042-043: sender icon */
+	/* 048-049: sender icon */
 	bytes += qq_put16(raw_data + bytes, qd->my_icon);
-	/* 044-046: always 0x00 */
-	bytes += qq_put16(raw_data + bytes, 0x0000);
-	bytes += qq_put8(raw_data + bytes, 0x00);
-	/* 047-047: always use font attr */
+	/* 050-052: 00 00 00 Unknown */
+	bytes += qq_put32(raw_data + bytes ,0);
+	bytes --;
+	/* 050-050: have_font_attribute 0x01 */
 	bytes += qq_put8(raw_data + bytes, 0x01);
-	/* 048-051: always 0x00 */
-	/* Fixme: frag_count, frag_index not working now */
+	/* 051-051: slice count */
 	bytes += qq_put8(raw_data + bytes, frag_count);
+	/* 052-052: slice index */
 	bytes += qq_put8(raw_data + bytes, frag_index);
-	bytes += qq_put8(raw_data + bytes, id);
-	bytes += qq_put8(raw_data + bytes, 0);
+	/* 053-053: msg_id */
+	bytes += qq_put16(raw_data + bytes, msg_id);
 	/* 052-052: text message type (normal/auto-reply) */
 	bytes += qq_put8(raw_data + bytes, type);
-	/* 053-   : msg ends with 0x00 */
-	bytes += qq_putdata(raw_data + bytes, (guint8 *)msg, strlen(msg));
-	if (frag_count == frag_index + 1) {
-		bytes += qq_put8(raw_data + bytes, 0x20);	/* add extra SPACE */
-	}
-	bytes += qq_put_im_tail(raw_data + bytes, fmt);
+	/* "MSG" */
+	bytes += qq_put32(raw_data + bytes, 0x4D534700);
+	bytes += qq_put32(raw_data + bytes, 0x00000000);
+	bytes += qq_put32(raw_data + bytes, (guint32) now);
+	/* Likely a random int */
+	srand((unsigned)now);
+	bytes += qq_put32(raw_data + bytes, rand());
+	/* font attr set */
+	bytes += qq_put8(raw_data + bytes, 0x00);
+	bytes += qq_put8(raw_data + bytes, fmt->rgb[0]);
+	bytes += qq_put8(raw_data + bytes, fmt->rgb[1]);
+	bytes += qq_put8(raw_data + bytes, fmt->rgb[2]);
+	bytes += qq_put8(raw_data + bytes, fmt->font_size);
+	bytes += qq_put8(raw_data + bytes, fmt->attr);
+	bytes += qq_put16(raw_data + bytes, fmt->charset);
+	bytes += qq_put16(raw_data + bytes, fmt->font_len);
+	bytes += qq_putdata(raw_data + bytes, fmt->font, fmt->font_len);
+
+	bytes += qq_put16(raw_data + bytes, 0x0000);
+	/* 053-   : msg does not end with 0x00 */
+	bytes += qq_putdata(raw_data + bytes, (guint8 *)msg->str, msg->len);
 
 	/* qq_show_packet("QQ_CMD_SEND_IM", raw_data, bytes); */
 	qq_send_cmd(gc, QQ_CMD_SEND_IM, raw_data, bytes);
 }
 
-static void im_convert_and_merge(GString *dest, GString *append)
-{
-	gchar *converted;
-	g_return_if_fail(dest != NULL && append != NULL);
-
-	if (append->str == NULL || append->len <= 0) {
-		return;
-	}
-	/* purple_debug_info("QQ", "Append:\n%s\n", append->str); */
-	converted = utf8_to_qq(append->str, QQ_CHARSET_DEFAULT);
-	g_string_append(dest, converted);
-	g_string_set_size(append, 0);
-	g_free(converted);
-}
-
 GSList *qq_im_get_segments(gchar *msg_stripped, gboolean is_smiley_none)
 {
 	GSList *string_list = NULL;
-	GString *new_string;
-	GString *append_utf8;
+	GString *string_seg;
 	gchar *start, *p;
-	gint len;
+	guint msg_len;
+	guint16 string_len;
+	guint16 string_ad_len;
 	qq_emoticon *emoticon;
+	static gchar em_v[] = {
+		0x02, 0x00, 0x09, 0x01, 0x00, 0x01, 0x4F, 0xFF, 0x00, 0x02, 0x14, 0xA0
+	};
 
 	g_return_val_if_fail(msg_stripped != NULL, NULL);
 
-	start = msg_stripped;
-	new_string = g_string_new("");
-	append_utf8 = g_string_new("");
-	while (*start) {
-		p = start;
-
-		/* Convert emoticon */
-		if (!is_smiley_none && *p == '/') {
-			if (new_string->len + append_utf8->len + 2 > QQ_MSG_IM_MAX) {
+	//start = msg_stripped;
+	msg_len = strlen(msg_stripped);
+	string_seg = g_string_new("");
+
+	p = msg_stripped;
+	while (p)
+	{
+		start = p;
+
+		p = g_utf8_strchr(p, -1, '/');
+		if (!p)	string_len = msg_stripped + msg_len - start;		//if not find emoticon, append all remained data
+		else 	string_len = p - start;
+
+		if (string_len >0)
+		{
+			if (string_seg->len + string_len + 6 > QQ_MSG_IM_MAX) {
 				/* enough chars to send */
-				im_convert_and_merge(new_string, append_utf8);
-				string_list = g_slist_append(string_list, strdup(new_string->str));
-				g_string_set_size(new_string, 0);
-				continue;
+				string_list = g_slist_append(string_list, string_seg);
+				string_seg = g_string_new("");
+			}
+			g_string_append_c(string_seg, 0x01);		//TEXT FLAG
+			string_ad_len = string_len + 3;		//len of text with prepended data
+			string_ad_len = htons(string_ad_len);
+			g_string_append_len(string_seg, (gchar *)&string_ad_len, sizeof(guint16));
+			g_string_append_c(string_seg, 0x01);		//Unknown FLAG
+			string_ad_len = htons(string_len);
+			g_string_append_len(string_seg, (gchar *)&string_ad_len, sizeof(guint16));
+			g_string_append_len(string_seg, start, string_len);
+		}
+
+		/* Append emoticon */
+		if ( !is_smiley_none && p )
+		{
+			if (string_seg->len  + 12 > QQ_MSG_IM_MAX) {
+				/* enough chars to send */
+				string_list = g_slist_append(string_list, string_seg);
+				string_seg = g_string_new("");
 			}
 			emoticon = emoticon_find(p);
 			if (emoticon != NULL) {
 				purple_debug_info("QQ", "found emoticon %s as 0x%02X\n",
 						emoticon->name, emoticon->symbol);
-				/* QQ emoticon code prevent converting from utf8 to QQ charset
-				 * convert append_utf8 to QQ charset
-				 * merge the result to dest
-				 * append qq QQ emoticon code to dest */
-				im_convert_and_merge(new_string, append_utf8);
-				g_string_append_c(new_string, 0x14);
-				g_string_append_c(new_string, emoticon->symbol);
-				start += strlen(emoticon->name);
+				/* Until Now, We haven't the new emoticon key database */
+				/* So Just Send a Settled V Gesture */
+				g_string_append_len(string_seg, em_v, sizeof(em_v));
+
+				//g_string_append_c(string_seg, 0x14);
+				//g_string_append_c(string_seg, emoticon->symbol);
+				p += strlen(emoticon->name);
 				continue;
 			} else {
 				purple_debug_info("QQ", "Not found emoticon %.20s\n", p);
 			}
 		}
-
-		/* Get next char */
-		start = g_utf8_next_char(p);
-		len = start - p;
-		if (new_string->len + append_utf8->len + len > QQ_MSG_IM_MAX) {
-			/* enough chars to send */
-			im_convert_and_merge(new_string, append_utf8);
-			string_list = g_slist_append(string_list, strdup(new_string->str));
-			g_string_set_size(new_string, 0);
-		}
-		g_string_append_len(append_utf8, p, len);
 	}
 
-	if (new_string->len + append_utf8->len > 0) {
-		im_convert_and_merge(new_string, append_utf8);
-		string_list = g_slist_append(string_list, strdup(new_string->str));
+	if (string_seg->len > 0) {
+		string_list = g_slist_append(string_list, string_seg);
 	}
-	g_string_free(new_string, TRUE);
-	g_string_free(append_utf8, TRUE);
 	return string_list;
 }
 
@@ -1251,8 +1163,8 @@ static GSList*  qq_grab_emoticons(const
 gint qq_send_im(PurpleConnection *gc, const gchar *who, const gchar *what, PurpleMessageFlags flags)
 {
 	qq_data *qd;
-	UID uid_to;
-	gint type;
+	guint32 uid_to;
+	guint8 type;
 	qq_im_format *fmt;
 	gchar *msg_stripped, *tmp;
 	GSList *segments, *it;
@@ -1260,13 +1172,13 @@ gint qq_send_im(PurpleConnection *gc, co
 	const gchar *start_invalid;
 	gboolean is_smiley_none;
 	guint8 frag_count, frag_index;
-	guint8 msg_id;
+	guint16 msg_id;
 
 	g_return_val_if_fail(NULL != gc && NULL != gc->proto_data, -1);
 	g_return_val_if_fail(who != NULL && what != NULL, -1);
 
 	qd = (qq_data *) gc->proto_data;
-	purple_debug_info("QQ", "Send IM to %s, len %" G_GSIZE_FORMAT ":\n%s\n", who, strlen(what), what);
+	purple_debug_info("QQ", "Send IM to %s, msg_len %" G_GSIZE_FORMAT ":\n%s\n", who, strlen(what), what);
 
 	uid_to = purple_name_to_uid(who);
 	if (uid_to == qd->uid) {
@@ -1306,17 +1218,13 @@ gint qq_send_im(PurpleConnection *gc, co
 	}
 
 	qd->send_im_id++;
-	msg_id = (guint8)(qd->send_im_id && 0xFF);
+	msg_id = qd->send_im_id;
 	fmt = qq_im_fmt_new_by_purple(what);
 	frag_count = g_slist_length(segments);
 	frag_index = 0;
 	for (it = segments; it; it = it->next) {
-		/*
-		request_send_im(gc, uid_to, type, fmt, (gchar *)it->data,
-			msg_id, frag_count, frag_index);
-		*/
-		request_send_im(gc, uid_to, type, fmt, (gchar *)it->data, 0, 0, 0);
-		g_free(it->data);
+		request_send_im(gc, uid_to, type, fmt, (GString *)it->data, msg_id, frag_count, frag_index);
+		g_string_free(it->data, TRUE);
 		frag_index++;
 	}
 	g_slist_free(segments);
diff -urp libpurple/protocols/qq/im.h libpurple/protocols/qq/im.h
--- libpurple/protocols/qq/im.h	2011-02-07 11:42:12.000000000 +0800
+++ libpurple/protocols/qq/im.h	2011-02-24 17:38:51.943460335 +0800
@@ -29,52 +29,55 @@
 #include "connection.h"
 
 enum {
-	QQ_MSG_TO_BUDDY = 0x0009,
+	QQ_MSG_BUDDY_09 = 0x0009,
 	QQ_MSG_TO_UNKNOWN = 0x000a,
 	QQ_MSG_SMS = 0x0014,	/* not sure */
 	QQ_MSG_NEWS = 0x0018,
-	QQ_MSG_QUN_IM_UNKNOWN = 0x0020,
-	QQ_MSG_ADD_TO_QUN = 0x0021,
-	QQ_MSG_DEL_FROM_QUN = 0x0022,
-	QQ_MSG_APPLY_ADD_TO_QUN = 0x0023,
-	QQ_MSG_APPROVE_APPLY_ADD_TO_QUN = 0x0024,
-	QQ_MSG_REJCT_APPLY_ADD_TO_QUN = 0x0025,
-	QQ_MSG_CREATE_QUN = 0x0026,
-	QQ_MSG_TEMP_QUN_IM = 0x002A,
-	QQ_MSG_QUN_IM = 0x002B,
-	QQ_MSG_SYS_30 = 0x0030,
-	QQ_MSG_SYS_4C = 0x004C,
-	QQ_MSG_EXTEND = 0x0084,
-	QQ_MSG_EXTEND_85 = 0x0085
+	QQ_MSG_ROOM_IM_UNKNOWN = 0x0020,
+	QQ_MSG_ADD_TO_ROOM = 0x0021,
+	QQ_MSG_DEL_FROM_ROOM = 0x0022,
+	QQ_MSG_APPLY_ADD_TO_ROOM = 0x0023,
+	QQ_MSG_APPROVE_APPLY_ADD_TO_ROOM = 0x0024,
+	QQ_MSG_REJCT_APPLY_ADD_TO_ROOM = 0x0025,
+	QQ_MSG_CREATE_ROOM = 0x0026,
+	QQ_MSG_TEMP_ROOM_IM = 0x002A,
+	QQ_MSG_ROOM_IM = 0x002B,
+	QQ_MSG_SYS = 0x0030,
+	QQ_MSG_BUDDY_78 = 0x0078,
+	QQ_MSG_BUDDY_84 = 0x0084,
+	QQ_MSG_BUDDY_A6 = 0x00A6,
+	QQ_MSG_BUDDY_85 = 0x0085,
+	QQ_MSG_ROOM_IM_52 = 0x0052,
+
+	QQ_MSG_ROOM_MEMBER_IM = 0x008C,
+	QQ_MSG_SOMEBODY = 0x008D,
+	QQ_MSG_WRITING = 0x0079,
+	QQ_MSG_STRANGER = 0x0031
+
 };
 
 typedef struct {
-	/* attr:
-		bit0-4 for font size, bit5 for bold,
-		bit6 for italic, bit7 for underline
-	*/
+	guint8 font_size;
 	guint8 attr;
 	guint8 rgb[3];
 	guint16 charset;
-	gchar *font;		/* Attension: font may NULL. font name is in QQ charset */
+	gchar *font;		/* Attension: font may NULL. old font name is in QQ charset */
 	guint8 font_len;
 } qq_im_format;
 
-gint qq_put_im_tail(guint8 *buf, qq_im_format *fmt);
 gint qq_get_im_tail(qq_im_format *fmt, guint8 *data, gint data_len);
 
-qq_im_format *qq_im_fmt_new(void);
+qq_im_format *qq_im_fmt_new_default(void);
 void qq_im_fmt_free(qq_im_format *fmt);
-void qq_im_fmt_reset_font(qq_im_format *fmt);
 qq_im_format *qq_im_fmt_new_by_purple(const gchar *msg);
-gchar *qq_im_fmt_to_purple(qq_im_format *fmt, gchar *text);
+gchar *qq_im_fmt_to_purple(qq_im_format *fmt, GString *text);
 gboolean qq_im_smiley_none(const gchar *msg);
 GSList *qq_im_get_segments(gchar *msg_stripped, gboolean is_smiley_none);
 
 void qq_got_message(PurpleConnection *gc, const gchar *msg);
 gint qq_send_im(PurpleConnection *gc, const gchar *who, const gchar *message, PurpleMessageFlags flags);
 
-void qq_process_im(PurpleConnection *gc, guint8 *data, gint len);
+void qq_process_im(PurpleConnection *gc, guint8 *data, gint len, guint16 msg_type);
 void qq_process_extend_im(PurpleConnection *gc, guint8 *data, gint len);
 
 gchar *qq_emoticon_to_purple(gchar *text);
diff -urp libpurple/protocols/qq/Makefile.mingw libpurple/protocols/qq/Makefile.mingw
--- libpurple/protocols/qq/Makefile.mingw	2011-01-08 23:19:45.000000000 +0800
+++ libpurple/protocols/qq/Makefile.mingw	2011-02-24 17:38:51.990127000 +0800
@@ -7,7 +7,7 @@
 PIDGIN_TREE_TOP := ../../..
 include $(PIDGIN_TREE_TOP)/libpurple/win32/global.mak
 
-TARGET = libqq
+TARGET = libqq\libqq
 TYPE = PLUGIN
 
 # Static or Plugin...
diff -urp libpurple/protocols/qq/packet_parse.c libpurple/protocols/qq/packet_parse.c
--- libpurple/protocols/qq/packet_parse.c	2011-01-08 23:19:45.000000000 +0800
+++ libpurple/protocols/qq/packet_parse.c	2011-02-24 17:38:51.986793667 +0800
@@ -100,7 +100,7 @@ gint qq_getdata(guint8 *data, gint datal
 /* read four bytes as "time_t" from buf,
  * return the number of bytes read if succeeds, otherwise return -1
  * This function is a wrapper around read_packet_dw() to avoid casting. */
-gint qq_getime(time_t *t, guint8 *buf)
+gint qq_gettime(time_t *t, guint8 *buf)
 {
 	guint32 dw_dest;
 	memcpy(&dw_dest, buf, sizeof(dw_dest));
@@ -159,7 +159,7 @@ gint qq_put32(guint8 *buf, guint32 dw)
     return sizeof(dw_porter);
 }
 
-gint qq_putime(guint8 *buf, time_t *t)
+gint qq_puttime(guint8 *buf, time_t *t)
 {
 	guint32 dw, dw_porter;
 	memcpy(&dw, t, sizeof(dw));
diff -urp libpurple/protocols/qq/packet_parse.h libpurple/protocols/qq/packet_parse.h
--- libpurple/protocols/qq/packet_parse.h	2011-01-08 23:19:45.000000000 +0800
+++ libpurple/protocols/qq/packet_parse.h	2011-02-24 17:38:51.986793667 +0800
@@ -30,7 +30,7 @@
 
 /* According to "UNIX Network Programming", all TCP/IP implementations
  * must support a minimum IP datagram size of 576 bytes, regardless of the MTU.
- * Assuming a 20 byte IP header and 8 byte UDP header, this leaves 548 bytes
+ * Assuming a 20 byte IP header and 8 byte UDP header, this leaves 548 bytes 
  * as a safe maximum size for UDP messages.
  *
  * TCP allows packet 64K
@@ -47,14 +47,14 @@ gint qq_get8(guint8 *b, guint8 *buf);
 gint qq_get16(guint16 *w, guint8 *buf);
 gint qq_get32(guint32 *dw,  guint8 *buf);
 gint qq_getIP(struct in_addr *ip, guint8 *buf);
-gint qq_getime(time_t *t, guint8 *buf);
+gint qq_gettime(time_t *t, guint8 *buf);
 gint qq_getdata(guint8 *data, gint datalen, guint8 *buf);
 
 gint qq_put8(guint8 *buf, guint8 b);
 gint qq_put16(guint8 *buf, guint16 w);
 gint qq_put32(guint8 *buf, guint32 dw);
 gint qq_putIP(guint8* buf, struct in_addr *ip);
-gint qq_putime(guint8 *buf, time_t *t);
+gint qq_puttime(guint8 *buf, time_t *t);
 gint qq_putdata(guint8 *buf, const guint8 *data, const int datalen);
 
 /*
diff -urp libpurple/protocols/qq/qq_base.c libpurple/protocols/qq/qq_base.c
--- libpurple/protocols/qq/qq_base.c	2011-02-07 11:42:12.000000000 +0800
+++ libpurple/protocols/qq/qq_base.c	2011-02-24 17:38:51.990127000 +0800
@@ -40,9 +40,10 @@
 #include "qq.h"
 #include "qq_network.h"
 #include "utils.h"
+#include "group_internal.h"
 
 /* generate a md5 key using uid and session_key */
-static void get_session_md5(guint8 *session_md5, UID uid, guint8 *session_key)
+static void get_session_md5(guint8 *session_md5, guint32 uid, guint8 *session_key)
 {
 	guint8 src[QQ_KEY_LENGTH + QQ_KEY_LENGTH];
 	gint bytes = 0;
@@ -53,391 +54,23 @@ static void get_session_md5(guint8 *sess
 	qq_get_md5(session_md5, QQ_KEY_LENGTH, src, bytes);
 }
 
-/* process login reply which says OK */
-static gint8 process_login_ok(PurpleConnection *gc, guint8 *data, gint len)
-{
-	qq_data *qd;
-	gint bytes;
-
-	guint8 ret;
-	UID uid;
-	struct in_addr ip;
-	guint16 port;
-	struct tm *tm_local;
-
-	qd = (qq_data *) gc->proto_data;
-	/* qq_show_packet("Login reply", data, len); */
-
-	if (len < 148) {
-		qq_show_packet("Login reply OK, but length < 139", data, len);
-		purple_connection_error_reason(gc,
-				PURPLE_CONNECTION_ERROR_ENCRYPTION_ERROR,
-				_("Unable to decrypt server reply"));
-		return QQ_LOGIN_REPLY_ERR;
-	}
-
-	bytes = 0;
-	bytes += qq_get8(&ret, data + bytes);
-	bytes += qq_getdata(qd->session_key, sizeof(qd->session_key), data + bytes);
-	get_session_md5(qd->session_md5, qd->uid, qd->session_key);
-	purple_debug_info("QQ", "Got session_key\n");
-	bytes += qq_get32(&uid, data + bytes);
-	if (uid != qd->uid) {
-		purple_debug_warning("QQ", "My uid in login reply is %u, not %u\n", uid, qd->uid);
-	}
-	bytes += qq_getIP(&qd->my_ip, data + bytes);
-	bytes += qq_get16(&qd->my_port, data + bytes);
-	purple_debug_info("QQ", "Internet IP: %s, %d\n", inet_ntoa(qd->my_ip), qd->my_port);
-
-	bytes += qq_getIP(&qd->my_local_ip, data + bytes);
-	bytes += qq_get16(&qd->my_local_port, data + bytes);
-	purple_debug_info("QQ", "Local IP: %s, %d\n", inet_ntoa(qd->my_local_ip), qd->my_local_port);
-
-	bytes += qq_getime(&qd->login_time, data + bytes);
-	tm_local = localtime(&qd->login_time);
-	purple_debug_info("QQ", "Login time: %d-%d-%d, %d:%d:%d\n",
-			(1900 +tm_local->tm_year), (1 + tm_local->tm_mon), tm_local->tm_mday,
-			tm_local->tm_hour, tm_local->tm_min, tm_local->tm_sec);
-	/* skip unknown 2 bytes, 0x(03 0a) */
-	bytes += 2;
-	/* skip unknown 24 bytes, maybe token to access Qun shared files */
-	bytes += 24;
-	/* unknow ip and port */
-	bytes += qq_getIP(&ip, data + bytes);
-	bytes += qq_get16(&port, data + bytes);
-	purple_debug_info("QQ", "Unknow IP: %s, %d\n", inet_ntoa(ip), port);
-	/* unknow ip and port */
-	bytes += qq_getIP(&ip, data + bytes);
-	bytes += qq_get16(&port, data + bytes);
-	purple_debug_info("QQ", "Unknow IP: %s, %d\n", inet_ntoa(ip), port);
-	/* unknown 4 bytes, 0x(00 81 00 00)*/
-	bytes += 4;
-	/* skip unknown 32 bytes, maybe key to access QQ Home */
-	bytes += 32;
-	/* skip unknown 16 bytes, 0x(00 00 00 00 00 00 00 00 00 00 00 40 00 00 00 00) */
-	bytes += 16;
-	/* time */
-	bytes += qq_getime(&qd->last_login_time[0], data + bytes);
-	tm_local = localtime(&qd->last_login_time[0]);
-	purple_debug_info("QQ", "Last login time: %d-%d-%d, %d:%d:%d\n",
-			(1900 +tm_local->tm_year), (1 + tm_local->tm_mon), tm_local->tm_mday,
-			tm_local->tm_hour, tm_local->tm_min, tm_local->tm_sec);
-	/* unknow time */
-	g_return_val_if_fail(sizeof(qd->last_login_time) / sizeof(time_t) > 1, QQ_LOGIN_REPLY_OK);
-	bytes += qq_getime(&qd->last_login_time[1], data + bytes);
-	tm_local = localtime(&qd->last_login_time[1]);
-	purple_debug_info("QQ", "Time: %d-%d-%d, %d:%d:%d\n",
-			(1900 +tm_local->tm_year), (1 + tm_local->tm_mon), tm_local->tm_mday,
-			tm_local->tm_hour, tm_local->tm_min, tm_local->tm_sec);
-
-	g_return_val_if_fail(sizeof(qd->last_login_time) / sizeof(time_t) > 2, QQ_LOGIN_REPLY_OK);
-	bytes += qq_getime(&qd->last_login_time[2], data + bytes);
-	tm_local = localtime(&qd->last_login_time[2]);
-	purple_debug_info("QQ", "Time: %d-%d-%d, %d:%d:%d\n",
-			(1900 +tm_local->tm_year), (1 + tm_local->tm_mon), tm_local->tm_mday,
-			tm_local->tm_hour, tm_local->tm_min, tm_local->tm_sec);
-	/* unknow 9 bytes, 0x(00 0a 00 0a 01 00 00 0e 10) */
-
-	if (len > 148) {
-		qq_show_packet("Login reply OK, but length > 139", data, len);
-	}
-	return QQ_LOGIN_REPLY_OK;
-}
-
-/* process login reply packet which includes redirected new server address */
-static gint8 process_login_redirect(PurpleConnection *gc, guint8 *data, gint len)
-{
-	qq_data *qd;
-	gint bytes;
-	struct {
-		guint8 result;
-		UID uid;
-		struct in_addr new_server_ip;
-		guint16 new_server_port;
-	} packet;
-
-
-	if (len < 11) {
-		purple_connection_error_reason(gc,
-				PURPLE_CONNECTION_ERROR_ENCRYPTION_ERROR,
-				_("Unable to decrypt server reply"));
-		return QQ_LOGIN_REPLY_ERR;
-	}
-
-	qd = (qq_data *) gc->proto_data;
-	bytes = 0;
-	/* 000-000: reply code */
-	bytes += qq_get8(&packet.result, data + bytes);
-	/* 001-004: login uid */
-	bytes += qq_get32(&packet.uid, data + bytes);
-	/* 005-008: redirected new server IP */
-	bytes += qq_getIP(&packet.new_server_ip, data + bytes);
-	/* 009-010: redirected new server port */
-	bytes += qq_get16(&packet.new_server_port, data + bytes);
-
-	if (len > 11) {
-		purple_debug_error("QQ", "Login redirect more than expected %d bytes, read %d bytes\n", 11, bytes);
-	}
-
-	/* redirect to new server, do not disconnect or connect here
-	 * those connect should be called at packet_process */
-	qd->redirect_ip.s_addr = packet.new_server_ip.s_addr;
-	qd->redirect_port = packet.new_server_port;
-	return QQ_LOGIN_REPLY_REDIRECT;
-}
-
-/* request before login */
-void qq_request_token(PurpleConnection *gc)
-{
-	qq_data *qd;
-	guint8 buf[16] = {0};
-	gint bytes = 0;
-
-	g_return_if_fail(gc != NULL && gc->proto_data != NULL);
-	qd = (qq_data *) gc->proto_data;
-
-	bytes += qq_put8(buf + bytes, 0);
-
-	qd->send_seq++;
-	qq_send_cmd_encrypted(gc, QQ_CMD_TOKEN, qd->send_seq, buf, bytes, TRUE);
-}
-
-/* send login packet to QQ server */
-void qq_request_login(PurpleConnection *gc)
-{
-	qq_data *qd;
-	guint8 *buf, *raw_data;
-	gint bytes;
-	guint8 *encrypted;
-	gint encrypted_len;
-
-	/* for QQ 2005? copy from lumaqq */
-	static const guint8 login_23_51[29] = {
-			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-			0x00, 0x00, 0x00, 0x00, 0x86, 0xcc, 0x4c, 0x35,
-			0x2c, 0xd3, 0x73, 0x6c, 0x14, 0xf6, 0xf6, 0xaf,
-			0xc3, 0xfa, 0x33, 0xa4, 0x01
-	};
-
-	static const guint8 login_53_68[16] = {
- 			0x8D, 0x8B, 0xFA, 0xEC, 0xD5, 0x52, 0x17, 0x4A,
- 			0x86, 0xF9, 0xA7, 0x75, 0xE6, 0x32, 0xD1, 0x6D
-	};
-
-	static const guint8 login_100_bytes[100] = {
-		0x40, 0x0B, 0x04, 0x02, 0x00, 0x01, 0x00, 0x00,
-		0x00, 0x00, 0x00, 0x03, 0x09, 0x00, 0x00, 0x00,
-		0x00, 0x00, 0x00, 0x00, 0x01, 0xE9, 0x03, 0x01,
-		0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xF3, 0x03,
-		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xED,
-		0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
-		0xEC, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-		0x03, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-		0x00, 0x03, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00,
-		0x00, 0x00, 0x01, 0xEE, 0x03, 0x00, 0x00, 0x00,
-		0x00, 0x00, 0x00, 0x01, 0xEF, 0x03, 0x00, 0x00,
-		0x00, 0x00, 0x00, 0x00, 0x01, 0xEB, 0x03, 0x00,
-		0x00, 0x00, 0x00, 0x00
-	};
-
-	g_return_if_fail(gc != NULL && gc->proto_data != NULL);
-	qd = (qq_data *) gc->proto_data;
-
-	g_return_if_fail(qd->ld.token != NULL && qd->ld.token_len > 0);
-
-	raw_data = g_newa(guint8, MAX_PACKET_SIZE - 17);
-	memset(raw_data, 0, MAX_PACKET_SIZE - 17);
-
-	encrypted = g_newa(guint8, MAX_PACKET_SIZE);	/* 17 bytes more */
-
-	bytes = 0;
-	/* now generate the encrypted data
-	 * 000-015 use password_twice_md5 as key to encrypt empty string */
-	encrypted_len = qq_encrypt(encrypted, (guint8 *) "", 0, qd->ld.pwd_twice_md5);
-	g_return_if_fail(encrypted_len == 16);
-	bytes += qq_putdata(raw_data + bytes, encrypted, encrypted_len);
-
-	/* 016-016 */
-	bytes += qq_put8(raw_data + bytes, 0x00);
-	/* 017-020, used to be IP, now zero */
-	bytes += qq_put32(raw_data + bytes, 0x00000000);
-	/* 021-022, used to be port, now zero */
-	bytes += qq_put16(raw_data + bytes, 0x0000);
-	/* 023-051, fixed value, unknown */
-	bytes += qq_putdata(raw_data + bytes, login_23_51, 29);
-	/* 052-052, login mode */
-	bytes += qq_put8(raw_data + bytes, qd->login_mode);
-	/* 053-068, fixed value, maybe related to per machine */
-	bytes += qq_putdata(raw_data + bytes, login_53_68, 16);
-	/* 069, login token length */
-	bytes += qq_put8(raw_data + bytes, qd->ld.token_len);
-	/* 070-093, login token, normally 24 bytes */
-	bytes += qq_putdata(raw_data + bytes, qd->ld.token, qd->ld.token_len);
-	/* 100 bytes unknown */
-	bytes += qq_putdata(raw_data + bytes, login_100_bytes, 100);
-	/* all zero left */
-	memset(raw_data + bytes, 0, 416 - bytes);
-	bytes = 416;
-
-	encrypted_len = qq_encrypt(encrypted, raw_data, bytes, qd->ld.random_key);
-
-	buf = g_newa(guint8, MAX_PACKET_SIZE);
-	memset(buf, 0, MAX_PACKET_SIZE);
-	bytes = 0;
-	bytes += qq_putdata(buf + bytes, qd->ld.random_key, QQ_KEY_LENGTH);
-	bytes += qq_putdata(buf + bytes, encrypted, encrypted_len);
-
-	qd->send_seq++;
-	qq_send_cmd_encrypted(gc, QQ_CMD_LOGIN, qd->send_seq, buf, bytes, TRUE);
-}
-
-guint8 qq_process_token(PurpleConnection *gc, guint8 *buf, gint buf_len)
-{
-	qq_data *qd;
-	gint bytes;
-	guint8 ret;
-	guint8 token_len;
-	gchar *msg;
-
-	g_return_val_if_fail(buf != NULL && buf_len != 0, QQ_LOGIN_REPLY_ERR);
-
-	g_return_val_if_fail(gc != NULL  && gc->proto_data != NULL, QQ_LOGIN_REPLY_ERR);
-	qd = (qq_data *) gc->proto_data;
-
-	bytes = 0;
-	bytes += qq_get8(&ret, buf + bytes);
-	bytes += qq_get8(&token_len, buf + bytes);
-
-	if (ret != QQ_LOGIN_REPLY_OK) {
-		qq_show_packet("Failed requesting token", buf, buf_len);
-
-		msg = g_strdup_printf( _("Failed requesting token, 0x%02X"), ret );
-		purple_connection_error_reason(gc,
-				PURPLE_CONNECTION_ERROR_AUTHENTICATION_FAILED,
-				msg);
-		g_free(msg);
-		return QQ_LOGIN_REPLY_ERR;
-	}
-
-	if (bytes + token_len < buf_len) {
-		msg = g_strdup_printf( _("Invalid token len, %d"), token_len);
-		purple_connection_error_reason(gc,
-				PURPLE_CONNECTION_ERROR_AUTHENTICATION_FAILED,
-				msg);
-		g_free(msg);
-		return QQ_LOGIN_REPLY_ERR;
-	}
-
-	if (bytes + token_len > buf_len) {
-		purple_debug_info("QQ", "Extra token data, %d %d\n", token_len, buf_len - bytes);
-	}
-	/* qq_show_packet("Got token", buf + bytes, buf_len - bytes); */
-
-	if (qd->ld.token != NULL) {
-		g_free(qd->ld.token);
-		qd->ld.token = NULL;
-		qd->ld.token_len = 0;
-	}
-	qd->ld.token = g_new0(guint8, token_len);
-	qd->ld.token_len = token_len;
-	g_memmove(qd->ld.token, buf + 2, qd->ld.token_len);
-	return ret;
-}
-
 /* send logout packets to QQ server */
 void qq_request_logout(PurpleConnection *gc)
 {
 	gint i;
 	qq_data *qd;
+	guint8 *logout_fill;
 
 	qd = (qq_data *) gc->proto_data;
+	logout_fill = (guint8 *) g_alloca(16);
+	memset(logout_fill, 0x00,16);
+
 	for (i = 0; i < 4; i++)
-		qq_send_cmd(gc, QQ_CMD_LOGOUT, qd->ld.pwd_twice_md5, QQ_KEY_LENGTH);
+		qq_send_cmd(gc, QQ_CMD_LOGOUT, logout_fill, QQ_KEY_LENGTH);
 
 	qd->is_login = FALSE;	/* update login status AFTER sending logout packets */
 }
 
-/* for QQ 2003iii 0117, fixed value */
-/* static const guint8 login_23_51[29] = {
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0xbf, 0x14, 0x11, 0x20,
-	0x03, 0x9d, 0xb2, 0xe6, 0xb3, 0x11, 0xb7, 0x13,
-	0x95, 0x67, 0xda, 0x2c, 0x01
-}; */
-
-/* for QQ 2003iii 0304, fixed value */
-/*
-static const guint8 login_23_51[29] = {
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x9a, 0x93, 0xfe, 0x85,
-	0xd3, 0xd9, 0x2a, 0x41, 0xc8, 0x0d, 0xff, 0xb6,
-	0x40, 0xb8, 0xac, 0x32, 0x01
-};
-*/
-
-/* fixed value, not affected by version, or mac address */
-/*
-static const guint8 login_53_68[16] = {
-	0x82, 0x2a, 0x91, 0xfd, 0xa5, 0xca, 0x67, 0x4c,
-	0xac, 0x81, 0x1f, 0x6f, 0x52, 0x05, 0xa7, 0xbf
-};
-*/
-
-/* process the login reply packet */
-guint8 qq_process_login( PurpleConnection *gc, guint8 *data, gint data_len)
-{
-	guint8 ret = data[0];
-	gchar *msg, *msg_utf8;
-	gchar *error;
-	PurpleConnectionError reason = PURPLE_CONNECTION_ERROR_AUTHENTICATION_FAILED;
-
-	g_return_val_if_fail(data != NULL && data_len != 0, QQ_LOGIN_REPLY_ERR);
-
-	switch (ret) {
-		case QQ_LOGIN_REPLY_OK:
-			purple_debug_info("QQ", "Login OK\n");
-			return process_login_ok(gc, data, data_len);
-		case QQ_LOGIN_REPLY_REDIRECT:
-			purple_debug_info("QQ", "Redirect new server\n");
-			return process_login_redirect(gc, data, data_len);
-
-		case 0x0A:		/* extend redirect used in QQ2006 */
-			error = g_strdup( _("Redirect_EX is not currently supported") );
-			reason = PURPLE_CONNECTION_ERROR_AUTHENTICATION_FAILED;
-			break;
-		case 0x05:		/* invalid password */
-			if (!purple_account_get_remember_password(gc->account)) {
-				purple_account_set_password(gc->account, NULL);
-			}
-			error = g_strdup( _("Incorrect password"));
-			reason = PURPLE_CONNECTION_ERROR_AUTHENTICATION_FAILED;
-			break;
-		case 0x06:		/* need activation */
-			error = g_strdup( _("Activation required"));
-			reason = PURPLE_CONNECTION_ERROR_AUTHENTICATION_FAILED;
-			break;
-
-		default:
-			qq_hex_dump(PURPLE_DEBUG_WARNING, "QQ", data, data_len,
-					">>> [default] decrypt and dump");
-			error = g_strdup_printf(
-						_("Unknown reply code when logging in (0x%02X)"),
-						ret );
-			reason = PURPLE_CONNECTION_ERROR_OTHER_ERROR;
-			break;
-	}
-
-	msg = g_strndup((gchar *)data + 1, data_len - 1);
-	msg_utf8 = qq_to_utf8(msg, QQ_CHARSET_DEFAULT);
-
-	purple_debug_error("QQ", "%s: %s\n", error, msg_utf8);
-	purple_connection_error_reason(gc, reason, msg_utf8);
-
-	g_free(error);
-	g_free(msg);
-	g_free(msg_utf8);
-	return QQ_LOGIN_REPLY_ERR;
-}
 
 /* send keep-alive packet to QQ server (it is a heart-beat) */
 void qq_request_keep_alive(PurpleConnection *gc)
@@ -445,115 +78,22 @@ void qq_request_keep_alive(PurpleConnect
 	qq_data *qd;
 	guint8 raw_data[16] = {0};
 	gint bytes= 0;
+	gchar qq[11];
+	gint len=0;
 
 	qd = (qq_data *) gc->proto_data;
 
 	/* In fact, we can send whatever we like to server
 	 * with this command, server return the same result including
 	 * the amount of online QQ users, my ip and port */
-	bytes += qq_put32(raw_data + bytes, qd->uid);
+	len = g_snprintf(qq, 11, "%u", qd->uid);
+	bytes += qq_putdata(raw_data + bytes, (guint8 *)qq, len);
 	qq_send_cmd(gc, QQ_CMD_KEEP_ALIVE, raw_data, bytes);
 }
 
-/* parse the return ofqq_process_keep_alive keep-alive packet, it includes some system information */
 gboolean qq_process_keep_alive(guint8 *data, gint data_len, PurpleConnection *gc)
 {
 	qq_data *qd;
-	gchar **segments;
-
-	g_return_val_if_fail(data != NULL, FALSE);
-	g_return_val_if_fail(data_len != 0, FALSE);
-
-	qd = (qq_data *) gc->proto_data;
-
-	/* qq_show_packet("Keep alive reply packet", data, len); */
-
-	/* the last one is 60, don't know what it is */
-	segments = split_data(data, data_len, "\x1f", 6);
-	if (segments == NULL)
-			return TRUE;
-
-	/* segments[0] and segment[1] are all 0x30 ("0") */
-	qd->online_total = strtol(segments[2], NULL, 10);
-	if(0 == qd->online_total) {
-		purple_connection_error_reason(gc,
-				PURPLE_CONNECTION_ERROR_NETWORK_ERROR,
-				_("Lost connection with server"));
-	}
-	qd->my_ip.s_addr = inet_addr(segments[3]);
-	qd->my_port = strtol(segments[4], NULL, 10);
-
-	purple_debug_info("QQ", "keep alive, %s:%d\n",
-		inet_ntoa(qd->my_ip), qd->my_port);
-
-	g_strfreev(segments);
-	return TRUE;
-}
-
-void qq_request_keep_alive_2007(PurpleConnection *gc)
-{
-	qq_data *qd;
-	guint8 raw_data[32] = {0};
-	gint bytes= 0;
-	gchar *uid_str;
-
-	qd = (qq_data *) gc->proto_data;
-
-	/* In fact, we can send whatever we like to server
-	 * with this command, server return the same result including
-	 * the amount of online QQ users, my ip and port */
-	uid_str = g_strdup_printf("%u", qd->uid);
-	bytes += qq_putdata(raw_data + bytes, (guint8 *)uid_str, strlen(uid_str));
-	qq_send_cmd(gc, QQ_CMD_KEEP_ALIVE, raw_data, bytes);
-
-	g_free(uid_str);
-}
-
-gboolean qq_process_keep_alive_2007(guint8 *data, gint data_len, PurpleConnection *gc)
-{
-	qq_data *qd;
-	gint bytes= 0;
-	guint8 ret;
-
-	g_return_val_if_fail(data != NULL && data_len != 0, FALSE);
-
-	qd = (qq_data *) gc->proto_data;
-
-	/* qq_show_packet("Keep alive reply packet", data, len); */
-
-	bytes = 0;
-	bytes += qq_get8(&ret, data + bytes);
-	bytes += qq_get32(&qd->online_total, data + bytes);
-	if(0 == qd->online_total) {
-		purple_connection_error_reason(gc,
-				PURPLE_CONNECTION_ERROR_NETWORK_ERROR,
-				_("Lost connection with server"));
-	}
-
-	bytes += qq_getIP(&qd->my_ip, data + bytes);
-	bytes += qq_get16(&qd->my_port, data + bytes);
-	return TRUE;
-}
-
-void qq_request_keep_alive_2008(PurpleConnection *gc)
-{
-	qq_data *qd;
-	guint8 raw_data[16] = {0};
-	gint bytes= 0;
-
-	qd = (qq_data *) gc->proto_data;
-
-	/* In fact, we can send whatever we like to server
-	 * with this command, server return the same result including
-	 * the amount of online QQ users, my ip and port */
-	bytes += qq_put32(raw_data + bytes, qd->uid);
-	bytes += qq_putime(raw_data + bytes, &qd->login_time);
-	qq_send_cmd(gc, QQ_CMD_KEEP_ALIVE, raw_data, bytes);
-}
-
-gboolean qq_process_keep_alive_2008(guint8 *data, gint data_len, PurpleConnection *gc)
-{
-	qq_data *qd;
 	gint bytes= 0;
 	guint8 ret;
 	time_t server_time;
@@ -572,13 +112,15 @@ gboolean qq_process_keep_alive_2008(guin
 		purple_connection_error_reason(gc,
 				PURPLE_CONNECTION_ERROR_NETWORK_ERROR,
 				_("Lost connection with server"));
+	} else {
+		purple_debug_info("QQ", "Online QQ Account Number : %d", qd->online_total);
 	}
 
 	bytes += qq_getIP(&qd->my_ip, data + bytes);
 	bytes += qq_get16(&qd->my_port, data + bytes);
-	/* skip 2 byytes, 0x(00 3c) */
+	/* skip 2 bytes, 0x(00 3c) */
 	bytes += 2;
-	bytes += qq_getime(&server_time, data + bytes);
+	bytes += qq_gettime(&server_time, data + bytes);
 	/* skip 5 bytes, all are 0 */
 
 	purple_debug_info("QQ", "keep alive, %s:%d\n",
@@ -596,8 +138,8 @@ gboolean qq_process_keep_alive_2008(guin
 	return TRUE;
 }
 
-/* For QQ2007/2008 */
-void qq_request_get_server(PurpleConnection *gc)
+/* For QQ2010 */
+void qq_request_touch_server(PurpleConnection *gc)
 {
 	qq_data *qd;
 	guint8 *buf, *raw_data;
@@ -608,12 +150,12 @@ void qq_request_get_server(PurpleConnect
 	g_return_if_fail(gc != NULL && gc->proto_data != NULL);
 	qd = (qq_data *) gc->proto_data;
 
-	raw_data = g_newa(guint8, 128);
-	memset(raw_data, 0, 128);
+	raw_data = g_newa(guint8, 1024);
+	memset(raw_data, 0, 1024);
 
-	encrypted = g_newa(guint8, 128 + 17);	/* 17 bytes more */
+	encrypted = g_newa(guint8, 1024);
 
-	bytes = 0;
+	bytes = qq_putdata(raw_data,touch_fill,sizeof(touch_fill));
 	if (qd->redirect == NULL) {
 		/* first packet to get server */
 		qd->redirect_len = 15;
@@ -624,21 +166,21 @@ void qq_request_get_server(PurpleConnect
 
 	encrypted_len = qq_encrypt(encrypted, raw_data, bytes, qd->ld.random_key);
 
-	buf = g_newa(guint8, MAX_PACKET_SIZE);
-	memset(buf, 0, MAX_PACKET_SIZE);
+	buf = g_newa(guint8, 1024);
+	memset(buf, 0, 1024);
 	bytes = 0;
 	bytes += qq_putdata(buf + bytes, qd->ld.random_key, QQ_KEY_LENGTH);
 	bytes += qq_putdata(buf + bytes, encrypted, encrypted_len);
 
 	qd->send_seq++;
-	qq_send_cmd_encrypted(gc, QQ_CMD_GET_SERVER, qd->send_seq, buf, bytes, TRUE);
+	qq_send_cmd_encrypted(gc, QQ_CMD_TOUCH_SERVER, qd->send_seq, buf, bytes, TRUE);
 }
 
-guint16 qq_process_get_server(PurpleConnection *gc, guint8 *data, gint data_len)
+guint16 qq_process_touch_server(PurpleConnection *gc, guint8 *data, gint data_len)
 {
 	qq_data *qd;
 	gint bytes;
-	guint16 ret;
+	guint8 ret;
 
 	g_return_val_if_fail (gc != NULL && gc->proto_data != NULL, QQ_LOGIN_REPLY_ERR);
 	qd = (qq_data *) gc->proto_data;
@@ -647,70 +189,87 @@ guint16 qq_process_get_server(PurpleConn
 
 	/* qq_show_packet("Get Server", data, data_len); */
 	bytes = 0;
-	bytes += qq_get16(&ret, data + bytes);
+	bytes += qq_get8(&ret, data+bytes);
+	if (ret != 0) {
+		purple_connection_error_reason(gc,
+			PURPLE_CONNECTION_ERROR_OTHER_ERROR,
+			_("Touch server failed"));
+		return QQ_LOGIN_REPLY_ERR;
+	}
+	bytes += qq_gettime(&qd->login_time,data+bytes);
+	bytes += qq_getIP(&qd->my_ip,data+bytes);
+	bytes += 8;	/* add 8 bytes fill  */
+	
+	/* qq_show_packet("Got token", data + bytes, data_len - bytes); */
+
+	if (qd->ld.token_touch != NULL) {
+		g_free(qd->ld.token_touch);
+		qd->ld.token_touch = NULL;
+		qd->ld.token_touch_len = 0;
+	}
+	bytes += qq_get16(&qd->ld.token_touch_len,data+bytes);
+
+	qd->ld.token_touch = g_new0(guint8, qd->ld.token_touch_len);
+	bytes += qq_getdata(qd->ld.token_touch,qd->ld.token_touch_len,data+bytes);
+
+	qq_get8(&ret,data+bytes);	/* redirect flag */
 	if (ret == 0) {
 		/* Notice: do not clear redirect_data here. It will be used in login*/
 		qd->redirect_ip.s_addr = 0;
 		return QQ_LOGIN_REPLY_OK;
 	}
-
-	if (data_len < 15) {
-		purple_connection_error_reason(gc,
-				PURPLE_CONNECTION_ERROR_ENCRYPTION_ERROR,
-				_("Unable to decrypt server reply"));
-		return QQ_LOGIN_REPLY_ERR;
-	}
-
-	qd->redirect_len = data_len;
+	qd->redirect_len = 15;
 	qd->redirect = g_realloc(qd->redirect, qd->redirect_len);
-	qq_getdata(qd->redirect, qd->redirect_len, data);
+	qd->redirect[0] = 0;	/* fill first 00 */
+	qq_getdata(qd->redirect+1, qd->redirect_len, data+bytes);
+	memset(qd->redirect+11,0xFF,4);		/* fill last 4 bytes(redirect_ip) into 0xFF*/
 	/* qq_show_packet("Redirect to", qd->redirect, qd->redirect_len); */
 
-	qq_getIP(&qd->redirect_ip, data + 11);
+	qq_get8(&qd->redirect_times,data+bytes+1);
+	qq_getIP(&qd->redirect_ip, data+bytes+10);
 	purple_debug_info("QQ", "Get server %s\n", inet_ntoa(qd->redirect_ip));
-	return QQ_LOGIN_REPLY_REDIRECT;
+	return QQ_TOUCH_REPLY_REDIRECT;
 }
 
-void qq_request_token_ex(PurpleConnection *gc)
+void qq_request_captcha(PurpleConnection *gc)
 {
 	qq_data *qd;
 	guint8 *buf, *raw_data;
 	gint bytes;
 	guint8 *encrypted;
 	gint encrypted_len;
+	static guint8 captcha_fill[] = {
+		0x03, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+	};
 
 	g_return_if_fail(gc != NULL && gc->proto_data != NULL);
 	qd = (qq_data *) gc->proto_data;
 
-	g_return_if_fail(qd->ld.token != NULL && qd->ld.token_len > 0);
+	g_return_if_fail(qd->ld.token_touch != NULL && qd->ld.token_touch_len > 0);
 
-	raw_data = g_newa(guint8, MAX_PACKET_SIZE - 17);
-	memset(raw_data, 0, MAX_PACKET_SIZE - 17);
+	raw_data = g_newa(guint8,  1024);
+	memset(raw_data, 0, 1024);
 
-	encrypted = g_newa(guint8, MAX_PACKET_SIZE);	/* 17 bytes more */
+	encrypted = g_newa(guint8, 1024);
 
-	bytes = 0;
-	bytes += qq_put8(raw_data + bytes, qd->ld.token_len);
-	bytes += qq_putdata(raw_data + bytes, qd->ld.token, qd->ld.token_len);
-	bytes += qq_put8(raw_data + bytes, 3); 		/* Subcommand */
-	bytes += qq_put16(raw_data + bytes, 5);
-	bytes += qq_put32(raw_data + bytes, 0);
-	bytes += qq_put8(raw_data + bytes, 0); 		/* fragment index */
-	bytes += qq_put16(raw_data + bytes, 0); 	/* captcha token */
+	bytes = qq_putdata(raw_data,touch_fill,sizeof(touch_fill));
+	bytes += qq_put16(raw_data + bytes, qd->ld.token_touch_len);
+	bytes += qq_putdata(raw_data + bytes, qd->ld.token_touch, qd->ld.token_touch_len);
+	bytes += qq_putdata(raw_data + bytes, captcha_fill,sizeof(captcha_fill)); 
 
 	encrypted_len = qq_encrypt(encrypted, raw_data, bytes, qd->ld.random_key);
 
-	buf = g_newa(guint8, MAX_PACKET_SIZE);
-	memset(buf, 0, MAX_PACKET_SIZE);
+	buf = g_newa(guint8, 1024);
+	memset(buf, 0, 1024);
 	bytes = 0;
 	bytes += qq_putdata(buf + bytes, qd->ld.random_key, QQ_KEY_LENGTH);
 	bytes += qq_putdata(buf + bytes, encrypted, encrypted_len);
 
 	qd->send_seq++;
-	qq_send_cmd_encrypted(gc, QQ_CMD_TOKEN_EX, qd->send_seq, buf, bytes, TRUE);
+	qq_send_cmd_encrypted(gc, QQ_CMD_CAPTCHA, qd->send_seq, buf, bytes, TRUE);
 }
 
-void qq_request_token_ex_next(PurpleConnection *gc)
+void qq_request_captcha_next(PurpleConnection *gc)
 {
 	qq_data *qd;
 	guint8 *buf, *raw_data;
@@ -721,16 +280,18 @@ void qq_request_token_ex_next(PurpleConn
 	g_return_if_fail(gc != NULL && gc->proto_data != NULL);
 	qd = (qq_data *) gc->proto_data;
 
-	g_return_if_fail(qd->ld.token != NULL && qd->ld.token_len > 0);
+	g_return_if_fail(qd->ld.token_touch != NULL && qd->ld.token_touch_len > 0);
 
-	raw_data = g_newa(guint8, MAX_PACKET_SIZE - 17);
-	memset(raw_data, 0, MAX_PACKET_SIZE - 17);
+	raw_data = g_newa(guint8, 1024);
+	memset(raw_data, 0, 1024);
 
-	encrypted = g_newa(guint8, MAX_PACKET_SIZE);	/* 17 bytes more */
+	encrypted = g_newa(guint8, 1024);
 
 	bytes = 0;
-	bytes += qq_put8(raw_data + bytes, qd->ld.token_len);
-	bytes += qq_putdata(raw_data + bytes, qd->ld.token, qd->ld.token_len);
+	bytes = qq_putdata(raw_data,touch_fill,sizeof(touch_fill));
+	bytes += qq_put16(raw_data + bytes, qd->ld.token_touch_len);
+	bytes += qq_putdata(raw_data + bytes, qd->ld.token_touch, qd->ld.token_touch_len);
+
 	bytes += qq_put8(raw_data + bytes, 3); 		/* Subcommand */
 	bytes += qq_put16(raw_data + bytes, 5);
 	bytes += qq_put32(raw_data + bytes, 0);
@@ -740,19 +301,19 @@ void qq_request_token_ex_next(PurpleConn
 
 	encrypted_len = qq_encrypt(encrypted, raw_data, bytes, qd->ld.random_key);
 
-	buf = g_newa(guint8, MAX_PACKET_SIZE);
-	memset(buf, 0, MAX_PACKET_SIZE);
+	buf = g_newa(guint8, 1024);
+	memset(buf, 0, 1024);
 	bytes = 0;
 	bytes += qq_putdata(buf + bytes, qd->ld.random_key, QQ_KEY_LENGTH);
 	bytes += qq_putdata(buf + bytes, encrypted, encrypted_len);
 
 	qd->send_seq++;
-	qq_send_cmd_encrypted(gc, QQ_CMD_TOKEN_EX, qd->send_seq, buf, bytes, TRUE);
+	qq_send_cmd_encrypted(gc, QQ_CMD_CAPTCHA, qd->send_seq, buf, bytes, TRUE);
 
 	purple_connection_update_progress(gc, _("Requesting captcha"), 3, QQ_CONNECT_STEPS);
 }
 
-static void request_token_ex_code(PurpleConnection *gc,
+static void qq_request_captcha_submit(PurpleConnection *gc,
 		guint8 *token, guint16 token_len, guint8 *code, guint16 code_len)
 {
 	qq_data *qd;
@@ -764,35 +325,37 @@ static void request_token_ex_code(Purple
 	g_return_if_fail(gc != NULL && gc->proto_data != NULL);
 	qd = (qq_data *) gc->proto_data;
 
-	g_return_if_fail(qd->ld.token != NULL && qd->ld.token_len > 0);
+	g_return_if_fail(qd->ld.token_touch != NULL && qd->ld.token_touch_len > 0);
 	g_return_if_fail(code != NULL && code_len > 0);
 
-	raw_data = g_newa(guint8, MAX_PACKET_SIZE - 17);
-	memset(raw_data, 0, MAX_PACKET_SIZE - 17);
+	raw_data = g_newa(guint8, 1024);
+	memset(raw_data, 0, 1024);
 
-	encrypted = g_newa(guint8, MAX_PACKET_SIZE);	/* 17 bytes more */
+	encrypted = g_newa(guint8, 1024);	
 
 	bytes = 0;
-	bytes += qq_put8(raw_data + bytes, qd->ld.token_len);
-	bytes += qq_putdata(raw_data + bytes, qd->ld.token, qd->ld.token_len);
+	bytes = qq_putdata(raw_data,touch_fill,sizeof(touch_fill));
+	bytes += qq_put16(raw_data + bytes, qd->ld.token_touch_len);
+	bytes += qq_putdata(raw_data + bytes, qd->ld.token_touch, qd->ld.token_touch_len);
+
 	bytes += qq_put8(raw_data + bytes, 4); 		/* Subcommand */
 	bytes += qq_put16(raw_data + bytes, 5);
 	bytes += qq_put32(raw_data + bytes, 0);
 	bytes += qq_put16(raw_data + bytes, code_len);
 	bytes += qq_putdata(raw_data + bytes, code, code_len);
-	bytes += qq_put16(raw_data + bytes, qd->ld.token_ex_len); 	/* login token ex */
-	bytes += qq_putdata(raw_data + bytes, qd->ld.token_ex, qd->ld.token_ex_len);
+	bytes += qq_put16(raw_data + bytes, qd->ld.token_captcha_len); 	/* login token ex */
+	bytes += qq_putdata(raw_data + bytes, qd->ld.token_captcha, qd->ld.token_captcha_len);
 
 	encrypted_len = qq_encrypt(encrypted, raw_data, bytes, qd->ld.random_key);
 
-	buf = g_newa(guint8, MAX_PACKET_SIZE);
-	memset(buf, 0, MAX_PACKET_SIZE);
+	buf = g_newa(guint8, 1024);
+	memset(buf, 0, 1024);
 	bytes = 0;
 	bytes += qq_putdata(buf + bytes, qd->ld.random_key, QQ_KEY_LENGTH);
 	bytes += qq_putdata(buf + bytes, encrypted, encrypted_len);
 
 	qd->send_seq++;
-	qq_send_cmd_encrypted(gc, QQ_CMD_TOKEN_EX, qd->send_seq, buf, bytes, TRUE);
+	qq_send_cmd_encrypted(gc, QQ_CMD_CAPTCHA, qd->send_seq, buf, bytes, TRUE);
 
 	purple_connection_update_progress(gc, _("Checking captcha"), 3, QQ_CONNECT_STEPS);
 }
@@ -836,7 +399,7 @@ static void captcha_input_ok_cb(qq_captc
 		return;
 	}
 
-	request_token_ex_code(captcha_req->gc,
+	qq_request_captcha_submit(captcha_req->gc,
 			captcha_req->token, captcha_req->token_len,
 			(guint8 *)code, strlen(code));
 
@@ -886,14 +449,13 @@ void qq_captcha_input_dialog(PurpleConne
 		captcha_req);
 }
 
-guint8 qq_process_token_ex(PurpleConnection *gc, guint8 *data, gint data_len)
+guint8 qq_process_captcha(PurpleConnection *gc, guint8 *data, gint data_len)
 {
 	qq_data *qd;
 	int bytes;
-	guint8 ret;
-	guint8 sub_cmd;
-	guint8 reply;
-	guint16 captcha_len;
+	guint8 captcha_cmd;
+	guint8 need_captcha;
+	guint16 png_len;
 	guint8 curr_index;
 
 	g_return_val_if_fail(data != NULL && data_len != 0, QQ_LOGIN_REPLY_ERR);
@@ -901,29 +463,28 @@ guint8 qq_process_token_ex(PurpleConnect
 	g_return_val_if_fail(gc != NULL  && gc->proto_data != NULL, QQ_LOGIN_REPLY_ERR);
 	qd = (qq_data *) gc->proto_data;
 
-	ret = data[0];
-
 	bytes = 0;
-	bytes += qq_get8(&sub_cmd, data + bytes); /* 03: ok; 04: need verifying */
+	bytes += qq_get8(&captcha_cmd, data + bytes); 
 	bytes += 2;	/* 0x(00 05) */
-	bytes += qq_get8(&reply, data + bytes);
+	bytes += qq_get8(&need_captcha, data + bytes);
+	bytes += 4;		/* 00 00 01 23 */
 
-	bytes += qq_get16(&(qd->ld.token_ex_len), data + bytes);
-	qd->ld.token_ex = g_realloc(qd->ld.token_ex, qd->ld.token_ex_len);
-	bytes += qq_getdata(qd->ld.token_ex, qd->ld.token_ex_len, data + bytes);
+	bytes += qq_get16(&(qd->ld.token_captcha_len), data + bytes);
+	qd->ld.token_captcha = g_realloc(qd->ld.token_captcha, qd->ld.token_captcha_len);
+	bytes += qq_getdata(qd->ld.token_captcha, qd->ld.token_captcha_len, data + bytes);
 	/* qq_show_packet("Get token ex", qd->ld.token_ex, qd->ld.token_ex_len); */
 
-	if(reply != 1)
+	if(!need_captcha)
 	{
-		purple_debug_info("QQ", "Captcha verified, result %d\n", reply);
+		purple_debug_info("QQ", "Captcha verified, result %d\n", need_captcha);
 		return QQ_LOGIN_REPLY_OK;
 	}
 
-	bytes += qq_get16(&captcha_len, data + bytes);
+	bytes += qq_get16(&png_len, data + bytes);
 
-	qd->captcha.data = g_realloc(qd->captcha.data, qd->captcha.data_len + captcha_len);
-	bytes += qq_getdata(qd->captcha.data + qd->captcha.data_len, captcha_len, data + bytes);
-	qd->captcha.data_len += captcha_len;
+	qd->captcha.data = g_realloc(qd->captcha.data, qd->captcha.data_len + png_len);
+	bytes += qq_getdata(qd->captcha.data + qd->captcha.data_len, png_len, data + bytes);
+	qd->captcha.data_len += png_len;
 
 	bytes += qq_get8(&curr_index, data + bytes);
 	bytes += qq_get8(&qd->captcha.next_index, data + bytes);
@@ -934,10 +495,10 @@ guint8 qq_process_token_ex(PurpleConnect
 	/* qq_show_packet("Get captcha token", qd->captcha.token, qd->captcha.token_len); */
 
 	purple_debug_info("QQ", "Request next captcha %d, new %d, total %d\n",
-			qd->captcha.next_index, captcha_len, qd->captcha.data_len);
+			qd->captcha.next_index, png_len, qd->captcha.data_len);
 	if(qd->captcha.next_index > 0)
 	{
-		return QQ_LOGIN_REPLY_NEXT_TOKEN_EX;
+		return QQ_LOGIN_REPLY_NEXT_CAPTCHA;
 	}
 
 	return QQ_LOGIN_REPLY_CAPTCHA_DLG;
@@ -980,86 +541,108 @@ static guint32 crc32(guint32 crc, const
 	return crc ^ 0xffffffffL;
 }
 
-void qq_request_check_pwd(PurpleConnection *gc)
+void qq_request_auth(PurpleConnection *gc)
 {
 	qq_data *qd;
 	guint8 *buf, *raw_data;
 	gint bytes;
 	guint8 *encrypted;
 	gint encrypted_len;
-	static guint8 header[] = {
-			0x00, 0x5F, 0x00, 0x00, 0x08, 0x04, 0x01, 0xE0
-	};
-	static guint8 unknown[] = {
-			0xDB, 0xB9, 0xF3, 0x0B, 0xF9, 0x13, 0x87, 0xB2,
-			0xE6, 0x20, 0x43, 0xBE, 0x53, 0xCA, 0x65, 0x03
-	};
+	time_t now = time(NULL);
 
 	g_return_if_fail(gc != NULL && gc->proto_data != NULL);
 	qd = (qq_data *) gc->proto_data;
 
-	g_return_if_fail(qd->ld.token_ex != NULL && qd->ld.token_ex_len > 0);
+	g_return_if_fail(qd->ld.token_captcha != NULL && qd->ld.token_captcha_len > 0);
 
-	raw_data = g_newa(guint8, MAX_PACKET_SIZE - 17);
-	memset(raw_data, 0, MAX_PACKET_SIZE - 17);
+	raw_data = g_newa(guint8, 1024);
+	memset(raw_data, 0, 1024);
 
-	encrypted = g_newa(guint8, MAX_PACKET_SIZE);	/* 17 bytes more */
+	encrypted = g_newa(guint8, 1024);	
 
 	/* Encrypted password and put in encrypted */
 	bytes = 0;
+	bytes += qq_put32(raw_data + bytes, 0x1B9BCCD9);
+
+	raw_data[bytes++]=0x00;	raw_data[bytes++]=0x01;
+		
+	bytes += qq_put32(raw_data + bytes, qd->uid);
+	bytes += qq_putdata(raw_data + bytes, touch_fill + 8, 12);	/* touch_fill Data2 */
+
+	raw_data[bytes++]=0x00;	raw_data[bytes++]=0x00; raw_data[bytes++]=0x01;
+
 	bytes += qq_putdata(raw_data + bytes, qd->ld.pwd_md5, sizeof(qd->ld.pwd_md5));
-	bytes += qq_put16(raw_data + bytes, 0);
-	bytes += qq_put16(raw_data + bytes, rand() & 0xffff);
+	
+	bytes += qq_puttime(raw_data + bytes, &now);
+	
+	memset(raw_data + bytes, 0x00, 13);
+	bytes += 13;
+
+	bytes += qq_putIP(raw_data + bytes, &qd->my_ip);
+	
+	memset(raw_data + bytes, 0x00, 8);
+	bytes += 8;
+
+	bytes += qq_put16(raw_data + bytes, sizeof(auth_key[0]));
+	bytes += qq_putdata(raw_data + bytes, auth_key[0], sizeof(auth_key[0]));
+	bytes += qq_putdata(raw_data + bytes, auth_key[1], sizeof(auth_key[1]));
 
 	encrypted_len = qq_encrypt(encrypted, raw_data, bytes, qd->ld.pwd_twice_md5);
 
 	/* create packet */
 	bytes = 0;
-	bytes += qq_putdata(raw_data + bytes, header, sizeof(header));
-	/* token get from qq_request_token_ex */
-	bytes += qq_put8(raw_data + bytes, (guint8)(qd->ld.token_ex_len & 0xff));
-	bytes += qq_putdata(raw_data + bytes, qd->ld.token_ex, qd->ld.token_ex_len);
-	/* password encrypted */
+	bytes += qq_put32(raw_data + bytes, 0x00DE0001);
+	bytes += qq_putdata(raw_data + bytes, touch_fill+2, sizeof(touch_fill)-2);
+	/* token get from qq_request_captcha */
+	bytes += qq_put16(raw_data + bytes, qd->ld.token_captcha_len);
+	bytes += qq_putdata(raw_data + bytes, qd->ld.token_captcha, qd->ld.token_captcha_len);
+	/* add password encrypted  packet */
 	bytes += qq_put16(raw_data + bytes, encrypted_len);
 	bytes += qq_putdata(raw_data + bytes, encrypted, encrypted_len);
-	/* len of unknown + len of CRC32 */
-	bytes += qq_put16(raw_data + bytes, sizeof(unknown) + 4);
-	bytes += qq_putdata(raw_data + bytes, unknown, sizeof(unknown));
-	bytes += qq_put32(
-			raw_data + bytes, crc32(0xFFFFFFFF, unknown, sizeof(unknown)));
-
-	/* put length into first 2 bytes */
-	qq_put8(raw_data + 1, bytes - 2);
-
-	/* tail */
-	bytes += qq_put16(raw_data + bytes, 0x0003);
-	bytes += qq_put8(raw_data + bytes, 0);
-	bytes += qq_put8(raw_data + bytes, qd->ld.pwd_md5[1]);
-	bytes += qq_put8(raw_data + bytes, qd->ld.pwd_md5[2]);
+	/* len of random + len of CRC32, wrong */
+	bytes += qq_put16(raw_data + bytes, sizeof(qd->ld.random_key) + 4);
+	bytes += qq_putdata(raw_data + bytes, qd->ld.random_key, sizeof(qd->ld.random_key));
+	bytes += qq_put32(raw_data + bytes, crc32(0xFFFFFFFF, qd->ld.random_key, sizeof(qd->ld.random_key)));
+
+	bytes += qq_put32(raw_data + bytes, 0x01772E01);
+	bytes += qq_put32(raw_data + bytes, 0xBCA75E24);
+
+	bytes += qq_put16(raw_data +bytes, sizeof(auth_key[1]));
+	bytes += qq_putdata(raw_data +bytes, auth_key[1], sizeof(auth_key[1]));
+
+	raw_data[bytes++]=0x02;
+	bytes += qq_put32(raw_data + bytes, 0xAD98B7D2);
+
+	bytes += qq_put16(raw_data + bytes, sizeof(auth_key[2]));
+	bytes += qq_putdata(raw_data + bytes, auth_key[2], sizeof(auth_key[2]));
+
+	/* 00 fill */
+	memset(raw_data + bytes, 0x00, 328);
+	bytes += 328;
 
-	/* qq_show_packet("Check password", raw_data, bytes); */
 	/* Encrypted by random key*/
 	encrypted_len = qq_encrypt(encrypted, raw_data, bytes, qd->ld.random_key);
 
-	buf = g_newa(guint8, MAX_PACKET_SIZE);
-	memset(buf, 0, MAX_PACKET_SIZE);
+	buf = g_newa(guint8, 1024);
+	memset(buf, 0, 1024);
 	bytes = 0;
 	bytes += qq_putdata(buf + bytes, qd->ld.random_key, QQ_KEY_LENGTH);
 	bytes += qq_putdata(buf + bytes, encrypted, encrypted_len);
 
 	qd->send_seq++;
-	qq_send_cmd_encrypted(gc, QQ_CMD_CHECK_PWD, qd->send_seq, buf, bytes, TRUE);
+	qq_send_cmd_encrypted(gc, QQ_CMD_AUTH, qd->send_seq, buf, bytes, TRUE);
 }
 
-guint8 qq_process_check_pwd( PurpleConnection *gc, guint8 *data, gint data_len)
+guint8 qq_process_auth( PurpleConnection *gc, guint8 *data, gint data_len)
 {
 	qq_data *qd;
 	int bytes;
 	guint8 ret;
 	gchar *error = NULL;
-	guint16 unknow_token_len;
-	gchar *msg, *msg_utf8;
+	guint16 length;
+	gchar *msg;
 	guint16 msg_len;
+	guint8 i;
 	PurpleConnectionError reason = PURPLE_CONNECTION_ERROR_AUTHENTICATION_FAILED;
 
 	g_return_val_if_fail(data != NULL && data_len != 0, QQ_LOGIN_REPLY_ERR);
@@ -1067,29 +650,38 @@ guint8 qq_process_check_pwd( PurpleConne
 	g_return_val_if_fail(gc != NULL  && gc->proto_data != NULL, QQ_LOGIN_REPLY_ERR);
 	qd = (qq_data *) gc->proto_data;
 
-	/* qq_show_packet("Check password reply", data, data_len); */
+	/* qq_show_packet("Check password reply", data, data_len); */ 
 
 	bytes = 0;
-	bytes += qq_get16(&unknow_token_len, data + bytes);	/* maybe total length */
+	bytes += qq_get16(&length, data + bytes);	/* total length - header(2) - tail(2) */
 	bytes += qq_get8(&ret, data + bytes);
-	bytes += 4; /* 0x(00 00 6d b9) */
-	/* unknow_token_len may 0 when not reply ok*/
-	bytes += qq_get16(&unknow_token_len, data + bytes);	/* 0x0020 */
-	bytes += unknow_token_len;
-	bytes += qq_get16(&unknow_token_len, data + bytes);	/* 0x0020 */
-	bytes += unknow_token_len;
 
 	if (ret == 0) {
-		/* get login_token */
-		bytes += qq_get16(&qd->ld.login_token_len, data + bytes);
-		if (qd->ld.login_token != NULL) g_free(qd->ld.login_token);
-		qd->ld.login_token = g_new0(guint8, qd->ld.login_token_len);
-		bytes += qq_getdata(qd->ld.login_token, qd->ld.login_token_len, data + bytes);
+		/* get token_auth */
+		if (qd->ld.token_auth == NULL) qd->ld.token_auth = g_new0(guint8 *,3);
+
+		for (i=0; i<3; ++i)
+		{
+			if (qd->ld.token_auth[i] != NULL) g_free(qd->ld.token_auth[i]);
+
+			if (i==1)	 /* length and time*/
+			{
+				bytes +=4;		/* bypass 00 09 00 02 */
+				bytes += qq_gettime(&qd->login_time, data+bytes);
+			}
+			
+			bytes += qq_get16(&qd->ld.token_auth_len[i], data + bytes);
+			qd->ld.token_auth[i] = g_new0(guint8, qd->ld.token_auth_len[i]);
+
+			bytes += qq_getdata(qd->ld.token_auth[i], qd->ld.token_auth_len[i], data + bytes);
+		}
+
+		/* Key Used in verify_E5 Packet */
+		bytes += qq_getdata(qd->ld.keys[0], sizeof(qd->ld.keys[0]), data+bytes);
+		bytes += 2;
+		qq_getdata(qd->ld.keys[1], sizeof(qd->ld.keys[1]), data+bytes);
 		/* qq_show_packet("Get login token", qd->ld.login_token, qd->ld.login_token_len); */
 
-		/* get login_key */
-		bytes += qq_getdata(qd->ld.login_key, sizeof(qd->ld.login_key), data + bytes);
-		/* qq_show_packet("Get login key", qd->ld.login_key, sizeof(qd->ld.login_key)); */
 		return QQ_LOGIN_REPLY_OK;
 	}
 
@@ -1121,316 +713,289 @@ guint8 qq_process_check_pwd( PurpleConne
 			break;
 	}
 
+	bytes += 8;	/* bypass some fillings */
 	bytes += qq_get16(&msg_len, data + bytes);
 
 	msg = g_strndup((gchar *)data + bytes, msg_len);
-	msg_utf8 = qq_to_utf8(msg, QQ_CHARSET_DEFAULT);
 
-	purple_debug_error("QQ", "%s: %s\n", error, msg_utf8);
-	purple_connection_error_reason(gc, reason, msg_utf8);
+	purple_debug_error("QQ", "%s: %s\n", error, msg);
+	purple_connection_error_reason(gc, reason, msg);
 
 	g_free(error);
 	g_free(msg);
-	g_free(msg_utf8);
 	return QQ_LOGIN_REPLY_ERR;
 }
 
-void qq_request_login_2007(PurpleConnection *gc)
+
+void qq_request_verify_E5(PurpleConnection *gc)
 {
 	qq_data *qd;
 	guint8 *buf, *raw_data;
-	gint bytes;
+	gint bytes = 0;
 	guint8 *encrypted;
 	gint encrypted_len;
-	static const guint8 login_1_16[] = {
-			0x56, 0x4E, 0xC8, 0xFB, 0x0A, 0x4F, 0xEF, 0xB3,
-			0x7A, 0x5D, 0xD8, 0x86, 0x0F, 0xAC, 0xE5, 0x1A
-	};
-	static const guint8 login_2_16[] = {
-			0x5E, 0x22, 0x3A, 0xBE, 0x13, 0xBF, 0xDA, 0x4C,
-			0xA9, 0xB7, 0x0B, 0x43, 0x63, 0x51, 0x8E, 0x28
-	};
-	static const guint8 login_3_83[] = {
-			0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00,
-			0x00, 0x00, 0x01, 0x40, 0x01, 0x01, 0x58, 0x83,
-			0xD0, 0x00, 0x10, 0x9D, 0x14, 0x64, 0x0A, 0x2E,
-			0xE2, 0x11, 0xF7, 0x90, 0xF0, 0xB5, 0x5F, 0x16,
-			0xFB, 0x41, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00,
-			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-			0x00, 0x00, 0x00, 0x00, 0x02, 0x76, 0x3C, 0xEE,
-			0x4A, 0x00, 0x10, 0x86, 0x81, 0xAD, 0x1F, 0xC8,
-			0xC9, 0xCC, 0xCF, 0xCA, 0x9F, 0xFF, 0x88, 0xC0,
-			0x5C, 0x88, 0xD5
-	};
+
 	g_return_if_fail(gc != NULL && gc->proto_data != NULL);
 	qd = (qq_data *) gc->proto_data;
 
-	g_return_if_fail(qd->ld.token != NULL && qd->ld.token_len > 0);
+	g_return_if_fail(qd->ld.token_captcha != NULL && qd->ld.token_captcha_len > 0);
+	g_return_if_fail(qd->ld.token_auth[0] != NULL && qd->ld.token_auth_len[0] > 0);
+	g_return_if_fail(qd->ld.token_auth[1] != NULL && qd->ld.token_auth_len[1] > 0);
+	g_return_if_fail(qd->ld.keys[0] != NULL);
 
-	raw_data = g_newa(guint8, MAX_PACKET_SIZE - 17);
-	memset(raw_data, 0, MAX_PACKET_SIZE - 17);
+	raw_data = g_newa(guint8, 1024);
+	memset(raw_data, 0, 1024);
+	encrypted = g_newa(guint8, 1024);	
 
-	encrypted = g_newa(guint8, MAX_PACKET_SIZE);	/* 17 bytes more */
+	bytes += qq_put32(raw_data + bytes, 0x010E0001);
+	bytes += qq_putdata(raw_data + bytes, touch_fill + 1, sizeof(touch_fill) - 1);
 
-	/* Encrypted password and put in encrypted */
-	bytes = 0;
-	bytes += qq_putdata(raw_data + bytes, qd->ld.pwd_md5, sizeof(qd->ld.pwd_md5));
-	bytes += qq_put16(raw_data + bytes, 0);
-	bytes += qq_put16(raw_data + bytes, 0xffff);
+	bytes += qq_put16(raw_data+bytes, qd->ld.token_captcha_len);
+	bytes += qq_putdata(raw_data+bytes, qd->ld.token_captcha, qd->ld.token_captcha_len);
+	bytes += qq_put16(raw_data+bytes, qd->ld.token_auth_len[0]);
+	bytes += qq_putdata(raw_data+bytes, qd->ld.token_auth[0], qd->ld.token_auth_len[0]);
 
-	encrypted_len = qq_encrypt(encrypted, raw_data, bytes, qd->ld.pwd_twice_md5);
-
-	/* create packet */
-	bytes = 0;
-	bytes += qq_put16(raw_data + bytes, 0);		/* Unknow */
-	/* password encrypted */
-	bytes += qq_put16(raw_data + bytes, encrypted_len);
-	bytes += qq_putdata(raw_data + bytes, encrypted, encrypted_len);
-	/* put data which NULL string encrypted by key pwd_twice_md5 */
-	encrypted_len = qq_encrypt(encrypted, (guint8 *) "", 0, qd->ld.pwd_twice_md5);
-	g_return_if_fail(encrypted_len == 16);
-	bytes += qq_putdata(raw_data + bytes, encrypted, encrypted_len);
-	/* unknow fill 0 */
-	memset(raw_data + bytes, 0, 19);
-	bytes += 19;
-	bytes += qq_putdata(raw_data + bytes, login_1_16, sizeof(login_1_16));
+	bytes += qq_put16(raw_data+bytes, 0x0098);
+	bytes += qq_put16(raw_data+bytes,0x0002);
+	bytes += qq_puttime(raw_data+bytes, &qd->login_time);
 
-	bytes += qq_put8(raw_data + bytes, rand() & 0xff);
-	bytes += qq_put8(raw_data + bytes, qd->login_mode);
-	/* unknow 10 bytes zero filled*/
-	memset(raw_data + bytes, 0, 10);
-	bytes += 10;
-	/* redirect data, 15 bytes */
-	/* qq_show_packet("Redirect", qd->redirect, qd->redirect_len); */
-	bytes += qq_putdata(raw_data + bytes, qd->redirect, qd->redirect_len);
-	/* unknow fill */
-	bytes += qq_putdata(raw_data + bytes, login_2_16, sizeof(login_2_16));
-	/* captcha token get from qq_process_token_ex */
-	bytes += qq_put8(raw_data + bytes, (guint8)(qd->ld.token_ex_len & 0xff));
-	bytes += qq_putdata(raw_data + bytes, qd->ld.token_ex, qd->ld.token_ex_len);
-	/* unknow fill */
-	bytes += qq_putdata(raw_data + bytes, login_3_83, sizeof(login_3_83));
-	memset(raw_data + bytes, 0, 332 - sizeof(login_3_83));
-	bytes += 332 - sizeof(login_3_83);
+	bytes += qq_put16(raw_data+bytes, qd->ld.token_auth_len[1]);
+	bytes += qq_putdata(raw_data+bytes, qd->ld.token_auth[1], qd->ld.token_auth_len[1]);
 
-	/* qq_show_packet("Login", raw_data, bytes); */
+	memset(raw_data+bytes, 0x00, 7);
+	*(raw_data+bytes+2) = 0x01;
+	bytes += 7;
 
-	encrypted_len = qq_encrypt(encrypted, raw_data, bytes, qd->ld.login_key);
+	encrypted_len = qq_encrypt(encrypted, raw_data, bytes, qd->ld.keys[0]);
 
-	buf = g_newa(guint8, MAX_PACKET_SIZE);
-	memset(buf, 0, MAX_PACKET_SIZE);
+	buf = g_newa(guint8, 1024);
+	memset(buf, 0, 1024);
 	bytes = 0;
-	/* logint token get from qq_process_check_pwd_2007 */
-	bytes += qq_put16(buf + bytes, qd->ld.login_token_len);
-	bytes += qq_putdata(buf + bytes, qd->ld.login_token, qd->ld.login_token_len);
+	bytes += qq_put16(buf+bytes, qd->ld.token_auth_len[2]);
+	bytes += qq_putdata(buf+bytes, qd->ld.token_auth[2], qd->ld.token_auth_len[2]);
 	bytes += qq_putdata(buf + bytes, encrypted, encrypted_len);
 
 	qd->send_seq++;
-	qq_send_cmd_encrypted(gc, QQ_CMD_LOGIN, qd->send_seq, buf, bytes, TRUE);
+	qq_send_cmd_encrypted(gc, QQ_CMD_VERIFY_E5, qd->send_seq, buf, bytes, TRUE);
+
 }
 
-/* process the login reply packet */
-guint8 qq_process_login_2007( PurpleConnection *gc, guint8 *data, gint data_len)
+guint8 qq_process_verify_E5( PurpleConnection *gc, guint8 *data, gint data_len )
 {
 	qq_data *qd;
-	gint bytes;
-	guint8 ret;
-	UID uid;
-	gchar *error;
-	gchar *msg;
-	gchar *msg_utf8;
+	int bytes;
 
 	g_return_val_if_fail(data != NULL && data_len != 0, QQ_LOGIN_REPLY_ERR);
 
+	g_return_val_if_fail(gc != NULL  && gc->proto_data != NULL, QQ_LOGIN_REPLY_ERR);
 	qd = (qq_data *) gc->proto_data;
 
-	bytes = 0;
-	bytes += qq_get8(&ret, data + bytes);
-	if (ret != 0) {
-		msg = g_strndup((gchar *)data + bytes, data_len - bytes);
-		msg_utf8 = qq_to_utf8(msg, QQ_CHARSET_DEFAULT);
-		g_free(msg);
-
-		switch (ret) {
-			case 0x05:
-				purple_debug_error("QQ", "Server busy for %s\n", msg_utf8);
-				return QQ_LOGIN_REPLY_REDIRECT;
-			case 0x0A:
-				/* 0a 2d 9a 4b 9a 01 01 00 00 00 05 00 00 00 00 79 0e 5f fd */
-				/* Missing get server before login*/
-			default:
-				error = g_strdup_printf(
-						_("Unknown reply code when logging in (0x%02X):\n%s"),
-						ret, msg_utf8);
-				break;
-		}
+	bytes = 4;
+	bytes += qq_getdata(qd->ld.keys[2], QQ_KEY_LENGTH, data+bytes);
+	bytes += 8;
+	bytes += qq_get32(&qd->ld.login_fill, data+bytes);
+	bytes += qq_gettime(&qd->login_time, data+bytes);
+	bytes += qq_getIP(&qd->my_ip, data+bytes);
+	bytes += 8;
+
+	if (qd->ld.token_verify == NULL) qd->ld.token_verify = g_new0(guint8 *, 3);
+
+	bytes += qq_get16(&qd->ld.token_verify_len[0], data+bytes);
+	if (qd->ld.token_verify[0] != NULL) g_free(qd->ld.token_verify[0]);
+	qd->ld.token_verify[0] = g_new0(guint8, qd->ld.token_verify_len[0]);
+	bytes += qq_getdata(qd->ld.token_verify[0], qd->ld.token_verify_len[0], data+bytes);
+
+	bytes += qq_getdata(qd->ld.keys[3], QQ_KEY_LENGTH, data+bytes);
+
+	bytes += qq_get16(&qd->ld.token_verify_len[1], data+bytes);
+	if (qd->ld.token_verify[1] != NULL) g_free(qd->ld.token_verify[1]);
+	qd->ld.token_verify[1] = g_new0(guint8, qd->ld.token_verify_len[1]);
+	bytes += qq_getdata(qd->ld.token_verify[1], qd->ld.token_verify_len[1], data+bytes);
+
+	bytes += 41;
+
+	bytes += qq_get16(&qd->ld.token_verify_len[2], data+bytes);
+	if (qd->ld.token_verify[2] != NULL) g_free(qd->ld.token_verify[2]);
+	qd->ld.token_verify[2] = g_new0(guint8, qd->ld.token_verify_len[2]);
+	bytes += qq_getdata(qd->ld.token_verify[2], qd->ld.token_verify_len[2], data+bytes);
 
-		purple_debug_error("QQ", "%s\n", error);
-		purple_connection_error_reason(gc,
-				PURPLE_CONNECTION_ERROR_OTHER_ERROR,
-				error);
+	return QQ_LOGIN_REPLY_OK;
+}
 
-		qq_hex_dump(PURPLE_DEBUG_WARNING, "QQ", data, data_len, error);
 
-		g_free(error);
-		g_free(msg_utf8);
-		return QQ_LOGIN_REPLY_ERR;
-	}
+void qq_request_verify_E3( PurpleConnection *gc )
+{
+	qq_data *qd;
+	guint8 *buf, *raw_data;
+	gint bytes = 0;
+	guint8 *encrypted;
+	gint encrypted_len;
 
-	bytes += qq_getdata(qd->session_key, sizeof(qd->session_key), data + bytes);
-	purple_debug_info("QQ", "Got session_key\n");
-	get_session_md5(qd->session_md5, qd->uid, qd->session_key);
-
-	bytes += qq_get32(&uid, data + bytes);
-	if (uid != qd->uid) {
-		purple_debug_warning("QQ", "My uid in login reply is %u, not %u\n", uid, qd->uid);
-	}
-	bytes += qq_getIP(&qd->my_ip, data + bytes);
-	bytes += qq_get16(&qd->my_port, data + bytes);
-	bytes += qq_getIP(&qd->my_local_ip, data + bytes);
-	bytes += qq_get16(&qd->my_local_port, data + bytes);
-	bytes += qq_getime(&qd->login_time, data + bytes);
-	/* skip unknow 50 byte */
-	bytes += 50;
-	/* skip client key 32 byte */
+	g_return_if_fail(gc != NULL && gc->proto_data != NULL);
+	qd = (qq_data *) gc->proto_data;
+
+	g_return_if_fail(qd->ld.token_captcha != NULL && qd->ld.token_captcha_len > 0);
+	g_return_if_fail(qd->ld.token_verify[1] != NULL && qd->ld.token_verify_len[0] > 0);
+	g_return_if_fail(qd->ld.token_auth[2] != NULL && qd->ld.token_auth_len[2] > 0);
+	g_return_if_fail(qd->ld.keys[0] != NULL);
+
+	raw_data = g_newa(guint8, 1024);
+	memset(raw_data, 0, 1024);
+	encrypted = g_newa(guint8, 1024);	
+
+	bytes += qq_put16(raw_data + bytes, 0x00C8);
+	bytes += qq_putdata(raw_data + bytes, touch_fill, sizeof(touch_fill));
+
+	bytes += qq_put16(raw_data+bytes, qd->ld.token_captcha_len);
+	bytes += qq_putdata(raw_data+bytes, qd->ld.token_captcha, qd->ld.token_captcha_len);
+	bytes += qq_put16(raw_data+bytes, qd->ld.token_verify_len[1]);
+	bytes += qq_putdata(raw_data+bytes, qd->ld.token_verify[1], qd->ld.token_verify_len[1]);
+
+	bytes += qq_put32(raw_data+bytes, 0x00000020);
+	memset(raw_data+bytes, 0x00, 32);
 	bytes += 32;
-	/* skip unknow 12 byte */
-	bytes += 12;
-	/* last login */
-	bytes += qq_getIP(&qd->last_login_ip, data + bytes);
-	bytes += qq_getime(&qd->last_login_time[0], data + bytes);
-	purple_debug_info("QQ", "Last Login: %s, %s\n",
-			inet_ntoa(qd->last_login_ip), ctime(&qd->last_login_time[0]));
+
+	encrypted_len = qq_encrypt(encrypted, raw_data, bytes, qd->ld.keys[0]);
+
+	buf = g_newa(guint8, 1024);
+	memset(buf, 0, 1024);
+
+	bytes = 0;
+	bytes += qq_put16(buf+bytes, qd->ld.token_auth_len[2]);
+	bytes += qq_putdata(buf+bytes, qd->ld.token_auth[2], qd->ld.token_auth_len[2]);
+	bytes += qq_putdata(buf + bytes, encrypted, encrypted_len);
+
+	qd->send_seq++;
+	qq_send_cmd_encrypted(gc, QQ_CMD_VERIFY_E3, qd->send_seq, buf, bytes, TRUE);
+}
+
+
+guint8 qq_process_verify_E3( PurpleConnection *gc, guint8 *data, gint data_len )
+{
+	qq_data *qd;
+	int bytes;
+	guint8 ret;
+	guint8 len;
+
+	g_return_val_if_fail(data != NULL && data_len != 0, QQ_LOGIN_REPLY_ERR);
+
+	g_return_val_if_fail(gc != NULL  && gc->proto_data != NULL, QQ_LOGIN_REPLY_ERR);
+	qd = (qq_data *) gc->proto_data;
+
+	bytes = 7;
+	bytes += qq_get8(&len, data+bytes);
+	qd->nickname = g_strndup((gchar *)data + bytes, len);
+	bytes += len;
+
+	bytes += qq_get8(&ret, data+bytes);
+
 	return QQ_LOGIN_REPLY_OK;
+	//return QQ_LOGIN_REPLY_ERR;
 }
 
-void qq_request_login_2008(PurpleConnection *gc)
+
+void qq_request_login(PurpleConnection *gc)
 {
 	qq_data *qd;
 	guint8 *buf, *raw_data;
 	gint bytes;
 	guint8 *encrypted;
 	gint encrypted_len;
-	guint8 index, count;
 
-	static const guint8 login_1_16[] = {
-			0xD2, 0x41, 0x75, 0x12, 0xC2, 0x86, 0x57, 0x10,
-			0x78, 0x57, 0xDC, 0x24, 0x8C, 0xAA, 0x8F, 0x4E
+	static const guint8 login_1[] = {
+			0xA9, 0x07, 0x23, 0x4B, 0xEB, 0x3A, 0x68, 0xEA, 
+			0x66, 0x9A, 0x0D, 0xEB, 0x79, 0x3E, 0xEF, 0x70
 	};
 
-	static const guint8 login_2_16[] = {
-			0x94, 0x0B, 0x73, 0x7A, 0xA2, 0x51, 0xF0, 0x4B,
-			0x95, 0x2F, 0xC6, 0x0A, 0x5B, 0xF6, 0x76, 0x52
-	};
-	static const guint8 login_3_18[] = {
-			0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00,
-			0x00, 0x00, 0x01, 0x40, 0x01, 0x1b, 0x02, 0x84,
-			0x50, 0x00
+	static const guint8 login_2[] = {
+			0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00,
+			0x08, 0x04, 0x10, 0x00, 0x01, 0x40, 0x01, 0xBC, 
+			0xA7, 0x5E, 0x24, 0x00, 0x10, 0x14, 0x82, 0x79, 
+			0x84, 0x1A, 0x79, 0xD0, 0xD4, 0xFD, 0x11, 0x26, 
+			0x38, 0x39, 0xEC, 0xF6, 0x39
 	};
-	static const guint8 login_4_16[] = {
-			0x2D, 0x49, 0x15, 0x55, 0x78, 0xFC, 0xF3, 0xD4,
-			0x53, 0x55, 0x60, 0x9C, 0x37, 0x9F, 0xE9, 0x59
-	};
-	static const guint8 login_5_6[] = {
-			0x02, 0x68, 0xe8, 0x07, 0x83, 0x00
-	};
-	static const guint8 login_6_16[] = {
-			0x3B, 0xCE, 0x43, 0xF1, 0x8B, 0xA4, 0x2B, 0xB5,
-			0xB3, 0x51, 0x57, 0xF7, 0x06, 0x4B, 0x18, 0xFC
+	static const guint8 login_3[] = {
+			0x02, 0xAD, 0x98, 0xB7, 0xD2,
+			0x00, 0x10,	/* size of data below */
+			0x7E, 0xD6, 0xF3, 0x98, 0xB1, 0x03, 0xE9, 0xC8,
+			0x96, 0x32, 0x72, 0x4F, 0x7E, 0x2E, 0x7B, 0xD0
 	};
+
 	g_return_if_fail(gc != NULL && gc->proto_data != NULL);
 	qd = (qq_data *) gc->proto_data;
 
-	g_return_if_fail(qd->ld.token != NULL && qd->ld.token_len > 0);
+	g_return_if_fail(qd->ld.token_auth[2] != NULL && qd->ld.token_auth_len[2] > 0);
 
-	raw_data = g_newa(guint8, MAX_PACKET_SIZE - 17);
-	memset(raw_data, 0, MAX_PACKET_SIZE - 17);
+	raw_data = g_newa(guint8, 1024);
+	memset(raw_data, 0, 1024);
 
-	encrypted = g_newa(guint8, MAX_PACKET_SIZE);	/* 17 bytes more */
+	encrypted = g_newa(guint8, 1024);	
 
-	/* Encrypted password and put in encrypted */
+	
 	bytes = 0;
-	bytes += qq_putdata(raw_data + bytes, qd->ld.pwd_md5, sizeof(qd->ld.pwd_md5));
-	bytes += qq_put16(raw_data + bytes, 0);
-	bytes += qq_put16(raw_data + bytes, 0xffff);
+	bytes += qq_put16(raw_data+bytes, 0x0001);
+	bytes += qq_putdata(raw_data+bytes, touch_fill+8, sizeof(touch_fill)-8);
 
-	encrypted_len = qq_encrypt(encrypted, raw_data, bytes, qd->ld.pwd_twice_md5);
+	bytes += qq_put32(raw_data+bytes, qd->ld.login_fill);
+	bytes += qq_puttime(raw_data+bytes, &qd->login_time);
+	bytes += qq_putIP(raw_data+bytes, &qd->my_ip);
+	
+	memset(raw_data+bytes, 0x00, 8);
+	bytes += 8;
+	
+	bytes += qq_put16(raw_data+bytes, qd->ld.token_verify_len[0]);
+	bytes += qq_putdata(raw_data+bytes, qd->ld.token_verify[0], qd->ld.token_verify_len[0]);
 
-	/* create packet */
-	bytes = 0;
-	bytes += qq_put16(raw_data + bytes, 0);		/* Unknow */
-	/* password encrypted */
-	bytes += qq_put16(raw_data + bytes, encrypted_len);
-	bytes += qq_putdata(raw_data + bytes, encrypted, encrypted_len);
-	/* put data which NULL string encrypted by key pwd_twice_md5 */
-	encrypted_len = qq_encrypt(encrypted, (guint8 *) "", 0, qd->ld.pwd_twice_md5);
-	g_return_if_fail(encrypted_len == 16);
-	bytes += qq_putdata(raw_data + bytes, encrypted, encrypted_len);
-	/* unknow 19 bytes zero filled*/
-	memset(raw_data + bytes, 0, 19);
-	bytes += 19;
-	bytes += qq_putdata(raw_data + bytes, login_1_16, sizeof(login_1_16));
-
-	index = rand() % 3;	  /* can be set as 1 */
-	for( count = 0; count < encrypted_len;  count++ )
-		index ^= encrypted[count];
-	for( count = 0; count < sizeof(login_1_16);  count++ )
-		index ^= login_1_16[count];
-	bytes += qq_put8(raw_data + bytes, index);	/* random in QQ 2007*/
+	memset(raw_data+bytes, 0x00, 35);
+	bytes += 35;
+	bytes += qq_putdata(raw_data+bytes, login_1, sizeof(login_1));
 
+	bytes += qq_put8(raw_data + bytes, 0xCC);	
 	bytes += qq_put8(raw_data + bytes, qd->login_mode);
-	/* unknow 10 bytes zero filled*/
-	memset(raw_data + bytes, 0, 10);
-	bytes += 10;
-	/* redirect data, 15 bytes */
-	bytes += qq_putdata(raw_data + bytes, qd->redirect, qd->redirect_len);
-	/* unknow fill */
-	bytes += qq_putdata(raw_data + bytes, login_2_16, sizeof(login_2_16));
-	/* captcha token get from qq_process_token_ex */
-	bytes += qq_put8(raw_data + bytes, (guint8)(qd->ld.token_ex_len & 0xff));
-	bytes += qq_putdata(raw_data + bytes, qd->ld.token_ex, qd->ld.token_ex_len);
-	/* unknow fill */
-	bytes += qq_putdata(raw_data + bytes, login_3_18, sizeof(login_3_18));
-	bytes += qq_put8(raw_data + bytes , sizeof(login_4_16));
-	bytes += qq_putdata(raw_data + bytes, login_4_16, sizeof(login_4_16));
-	/* unknow 10 bytes zero filled*/
-	memset(raw_data + bytes, 0, 10);
-	bytes += 10;
-	/* redirect data, 15 bytes */
-	bytes += qq_putdata(raw_data + bytes, qd->redirect, qd->redirect_len);
-	/* unknow fill */
-	bytes += qq_putdata(raw_data + bytes, login_5_6, sizeof(login_5_6));
-	bytes += qq_put8(raw_data + bytes , sizeof(login_6_16));
-	bytes += qq_putdata(raw_data + bytes, login_6_16, sizeof(login_6_16));
-	/* unknow 249 bytes zero filled*/
+
+	memset(raw_data + bytes, 0, 25);
+	bytes += 25;
+	bytes += qq_putdata(raw_data+bytes, touch_fill+2, 6);
+	memset(raw_data + bytes, 0, 16);
+	bytes += 16;
+
+	/* captcha token get from qq_process_captcha */
+	bytes += qq_put16(raw_data + bytes, qd->ld.token_captcha_len);
+	bytes += qq_putdata(raw_data + bytes, qd->ld.token_captcha, qd->ld.token_captcha_len);
+	
+	bytes += qq_putdata(raw_data + bytes, login_2, sizeof(login_2));
+
+	memset(raw_data + bytes, 0, 25);
+	bytes += 25;
+	
+	bytes += qq_putdata(raw_data + bytes, login_3, sizeof(login_3));
+
+	/* 249 bytes zero filled*/
 	memset(raw_data + bytes, 0, 249);
 	bytes += 249;
 
 	/* qq_show_packet("Login request", raw_data, bytes); */
-	encrypted_len = qq_encrypt(encrypted, raw_data, bytes, qd->ld.login_key);
+	encrypted_len = qq_encrypt(encrypted, raw_data, bytes, qd->ld.keys[0]);
 
-	buf = g_newa(guint8, MAX_PACKET_SIZE);
-	memset(buf, 0, MAX_PACKET_SIZE);
+	buf = g_newa(guint8, 1024);
+	memset(buf, 0, 1024);
 	bytes = 0;
-	/* logint token get from qq_process_check_pwd_2007 */
-	bytes += qq_put16(buf + bytes, qd->ld.login_token_len);
-	bytes += qq_putdata(buf + bytes, qd->ld.login_token, qd->ld.login_token_len);
+	/* login token get from qq_process_auth */
+	bytes += qq_put16(buf + bytes, qd->ld.token_auth_len[2]);
+	bytes += qq_putdata(buf + bytes, qd->ld.token_auth[2], qd->ld.token_auth_len[2]);
 	bytes += qq_putdata(buf + bytes, encrypted, encrypted_len);
 
 	qd->send_seq++;
 	qq_send_cmd_encrypted(gc, QQ_CMD_LOGIN, qd->send_seq, buf, bytes, TRUE);
 }
 
-guint8 qq_process_login_2008( PurpleConnection *gc, guint8 *data, gint data_len)
+/* process the login reply packet */
+guint8 qq_process_login( PurpleConnection *gc, guint8 *data, gint data_len)
 {
 	qq_data *qd;
 	gint bytes;
 	guint8 ret;
-	UID uid;
-	gchar *error;
-	gchar *msg;
-	gchar *msg_utf8;
+	guint32 uid;
 
 	g_return_val_if_fail(data != NULL && data_len != 0, QQ_LOGIN_REPLY_ERR);
 
@@ -1438,54 +1003,165 @@ guint8 qq_process_login_2008( PurpleConn
 
 	bytes = 0;
 	bytes += qq_get8(&ret, data + bytes);
-	if (ret != 0) {
-		msg = g_strndup((gchar *)data + bytes, data_len - bytes);
-		msg_utf8 = qq_to_utf8(msg, QQ_CHARSET_DEFAULT);
-		g_free(msg);
-
-		switch (ret) {
-			case 0x05:
-				purple_debug_error("QQ", "Server busy for %s\n", msg_utf8);
-				return QQ_LOGIN_REPLY_REDIRECT;
-				break;
-			default:
-				error = g_strdup_printf(
-						_("Unknown reply code when logging in (0x%02X):\n%s"),
-						ret, msg_utf8);
-				break;
-		}
+	if (ret == 0) {
+			bytes += qq_getdata(qd->session_key, sizeof(qd->session_key), data + bytes);
+			purple_debug_info("QQ", "Got session_key\n");
+			get_session_md5(qd->session_md5, qd->uid, qd->session_key);
+
+			bytes += qq_get32(&uid, data + bytes);
+			if (uid != qd->uid) {
+				purple_debug_warning("QQ", "My uid in login reply is %u, not %u\n", uid, qd->uid);
+			}
+			bytes += qq_getIP(&qd->my_ip, data + bytes);
+			bytes += qq_get16(&qd->my_port, data + bytes);
+			bytes += qq_gettime(&qd->login_time, data + bytes);
+			bytes += qq_getIP(&qd->my_local_ip, data + bytes);
+			bytes += 42;
+			bytes += qq_get16(&qd->ld.token_login_len, data + bytes);
+			qd->ld.token_login = g_realloc(qd->ld.token_login, qd->ld.token_login_len);
+			bytes += qq_getdata(qd->ld.token_login, qd->ld.token_login_len, data + bytes);
+			/*purple_debug_info("QQ", "Last Login: %s, %s\n",
+					inet_ntoa(qd->last_login_ip), ctime(&qd->last_login_time[0]));*/
+			return QQ_LOGIN_REPLY_OK;
+	}
+	return QQ_TOUCH_REPLY_REDIRECT;
+}
 
-		purple_debug_error("QQ", "%s\n", error);
-		purple_connection_error_reason(gc,
-				PURPLE_CONNECTION_ERROR_OTHER_ERROR,
-				error);
+void qq_request_login_E9( PurpleConnection *gc )
+{
+	qq_data *qd;
+	guint8 raw_data[4] = {0};
+	gint bytes= 0;
 
-		qq_hex_dump(PURPLE_DEBUG_WARNING, "QQ", data, data_len, error);
+	qd = (qq_data *) gc->proto_data;
 
-		g_free(error);
-		g_free(msg_utf8);
-		return QQ_LOGIN_REPLY_ERR;
+	bytes += qq_put16(raw_data, 0x0101);
+	qq_send_cmd(gc, QQ_CMD_LOGIN_E9, raw_data, bytes);
+}
+
+void qq_request_login_EA( PurpleConnection *gc )
+{
+	qq_data *qd;
+	guint8 raw_data[2] = {0};
+	gint bytes= 0;
+
+	qd = (qq_data *) gc->proto_data;
+
+	bytes += qq_put8(raw_data, 0x01);
+	qq_send_cmd(gc, QQ_CMD_LOGIN_EA, raw_data, bytes);
+}
+
+void qq_request_login_getlist( PurpleConnection *gc )
+{
+	qq_data *qd;
+	guint8 raw_data[16] = {0};
+	gint bytes= 0;
+
+	qd = (qq_data *) gc->proto_data;
+
+	bytes += qq_put32(raw_data+bytes, 0x01000000);
+	
+	bytes += qq_put8(raw_data+bytes,0x00);
+	bytes += qq_put32(raw_data+bytes, 0x00000000);	
+	/* first login is all zero, while response a hash like 02 4D 5D CF AE
+		02 list entry number, 4D 5D CF AE update time
+		next time request with it, to verify if list has changed	*/
+
+	bytes += qq_put16(raw_data+bytes, 0x0001);
+	qq_send_cmd(gc, QQ_CMD_LOGIN_GETLIST, raw_data, bytes);
+}
+
+void qq_request_login_ED( PurpleConnection *gc )
+{
+	qq_data *qd;
+	guint8 raw_data[2] = {0};
+	gint bytes= 0;
+
+	qd = (qq_data *) gc->proto_data;
+
+	bytes += qq_put8(raw_data, 0x01);
+	qq_send_cmd(gc, QQ_CMD_LOGIN_ED, raw_data, bytes);
+}
+
+
+void qq_request_login_EC( PurpleConnection *gc )
+{
+	qq_data *qd;
+	guint8 raw_data[4] = {0};
+	gint bytes= 0;
+
+	qd = (qq_data *) gc->proto_data;
+
+	bytes += qq_put16(raw_data, 0x0100);
+	bytes += qq_put8(raw_data+bytes, qd->login_mode);
+	qq_send_cmd(gc, QQ_CMD_LOGIN_EC, raw_data, bytes);
+}
+
+guint8 qq_process_login_getlist( PurpleConnection *gc, guint8 *data, gint data_len )
+{
+	qq_data *qd;
+	gint bytes;
+	guint8 ret;
+	guint16 num;
+	guint i;
+	guint32 uid;
+	guint16 type;
+	PurpleBuddy *buddy;
+	qq_room_data *rmd;
+
+	g_return_val_if_fail(data != NULL && data_len != 0, QQ_LOGIN_REPLY_ERR);
+
+	qd = (qq_data *) gc->proto_data;
+
+	bytes = 1;
+	qq_get8(&ret, data + bytes);
+	if (ret) {
+		purple_debug_info("QQ", "No Need to Refresh List");
+		return QQ_LOGIN_REPLY_OK;
 	}
+	qq_clean_buddy_list(gc);
 
-	bytes += qq_getdata(qd->session_key, sizeof(qd->session_key), data + bytes);
-	purple_debug_info("QQ", "Got session_key\n");
-	get_session_md5(qd->session_md5, qd->uid, qd->session_key);
-
-	bytes += qq_get32(&uid, data + bytes);
-	if (uid != qd->uid) {
-		purple_debug_warning("QQ", "My uid in login reply is %u, not %u\n", uid, qd->uid);
+	bytes = 18;
+	bytes += qq_get16(&num, data+bytes);
+	
+	for (i=0; i<num; i++) {
+		bytes += qq_get32(&uid, data+bytes);
+		bytes += qq_get16(&type, data+bytes);
+
+		if (type == 0x0100)		//buddy
+		{
+			buddy = qq_buddy_find_or_new(gc, uid);
+		} else if (type == 0x0400) {
+			rmd = qq_room_data_find(gc, uid);
+			if(rmd == NULL) {
+				purple_debug_info("QQ", "Unknown room uid %u\n", uid);
+				qq_send_room_cmd_only(gc, QQ_ROOM_CMD_GET_INFO, uid);
+			} else {
+				rmd->my_role = QQ_ROOM_ROLE_YES;
+			}
+		}
 	}
-	bytes += qq_getIP(&qd->my_ip, data + bytes);
-	bytes += qq_get16(&qd->my_port, data + bytes);
-	bytes += qq_getIP(&qd->my_local_ip, data + bytes);
-	bytes += qq_get16(&qd->my_local_port, data + bytes);
-	bytes += qq_getime(&qd->login_time, data + bytes);
-	/* skip 1 byte, always 0x03 */
-	/* skip 1 byte, login mode */
-	bytes = 131;
-	bytes += qq_getIP(&qd->last_login_ip, data + bytes);
-	bytes += qq_getime(&qd->last_login_time[0], data + bytes);
-	purple_debug_info("QQ", "Last Login: %s, %s\n",
-			inet_ntoa(qd->last_login_ip), ctime(&qd->last_login_time[0]));
 	return QQ_LOGIN_REPLY_OK;
 }
+
+void qq_clean_buddy_list( PurpleConnection *gc )
+{
+	PurpleBuddy * bd;
+	GSList * list;
+	g_return_if_fail(gc != NULL || gc->account != NULL);
+
+	for ( list=purple_find_buddies(gc->account, NULL); list; list=list->next )
+	{
+		bd = (PurpleBuddy *)list->data;
+		if (bd->account)
+		{
+		}
+		
+		qq_buddy_free(bd);
+	}
+	
+	qq_buddy_free(NULL);
+	g_free(list);
+}
+
+
diff -urp libpurple/protocols/qq/qq_base.h libpurple/protocols/qq/qq_base.h
--- libpurple/protocols/qq/qq_base.h	2011-02-07 11:42:12.000000000 +0800
+++ libpurple/protocols/qq/qq_base.h	2011-02-24 17:38:51.993460334 +0800
@@ -28,12 +28,12 @@
 #include <glib.h>
 #include "connection.h"
 
-#define QQ_LOGIN_REPLY_OK				0x00
-#define QQ_LOGIN_REPLY_REDIRECT				0x01
+#define QQ_LOGIN_REPLY_OK							0x00
+#define QQ_TOUCH_REPLY_REDIRECT				0x01
 /* defined by myself */
 #define QQ_LOGIN_REPLY_CAPTCHA_DLG			0xfd
-#define QQ_LOGIN_REPLY_NEXT_TOKEN_EX			0xfe
-#define QQ_LOGIN_REPLY_ERR				0xff
+#define QQ_LOGIN_REPLY_NEXT_CAPTCHA		0xfe
+#define QQ_LOGIN_REPLY_ERR							0xff
 
 #define QQ_LOGIN_MODE_NORMAL		0x0a
 #define QQ_LOGIN_MODE_AWAY	    	0x1e
@@ -41,10 +41,22 @@
 
 #define QQ_UPDATE_ONLINE_INTERVAL   300	/* in sec */
 
-void qq_request_token(PurpleConnection *gc);
-guint8 qq_process_token(PurpleConnection *gc, guint8 *buf, gint buf_len);
-
-void qq_request_login(PurpleConnection *gc);
+static guint8 header_fill[] = {
+	0x02, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x00, 0x00, 0x64,
+	0x1F	/* varies by versions */
+};
+
+static guint8 touch_fill[] = {
+	0x00, 0x01,
+	0x00, 0x00, 0x04, 0x09, 0x01, 0xE0,		/* touch Data1*/
+	0x00, 0x00, 0x03, 0x30, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x0B, 0xC5		/* touch Data2 */
+};
+
+static guint8 auth_key[][16] = {
+	{ 0x31, 0x84, 0xFD, 0x03, 0xDB, 0x59, 0x5A, 0x4A, 0xA6, 0x71, 0x1B, 0x11, 0x41, 0x3A, 0x87, 0x91 },
+	{ 0xC5, 0xF6, 0xF7, 0xEC, 0x10, 0xCB, 0x98, 0xE2, 0xE2, 0x75, 0x77, 0xF3, 0xE7, 0x06, 0x28, 0xF3 },
+	{ 0x7E, 0xD6, 0xF3, 0x98, 0xB1, 0x03, 0xE9, 0xC8, 0x96, 0x32, 0x72, 0x4F, 0x7E, 0x2E, 0x7B, 0xD0 }
+};
 guint8 qq_process_login( PurpleConnection *gc, guint8 *data, gint data_len);
 
 void qq_request_logout(PurpleConnection *gc);
@@ -52,28 +64,35 @@ void qq_request_logout(PurpleConnection
 void qq_request_keep_alive(PurpleConnection *gc);
 gboolean qq_process_keep_alive(guint8 *data, gint data_len, PurpleConnection *gc);
 
-void qq_request_keep_alive_2007(PurpleConnection *gc);
-gboolean qq_process_keep_alive_2007(guint8 *data, gint data_len, PurpleConnection *gc);
+/* for QQ2010 */
+void qq_request_touch_server(PurpleConnection *gc);
+guint16 qq_process_touch_server(PurpleConnection *gc, guint8 *rcved, gint rcved_len);
+
+void qq_request_captcha(PurpleConnection *gc);
+void qq_request_captcha_next(PurpleConnection *gc);
+guint8 qq_process_captcha(PurpleConnection *gc, guint8 *buf, gint buf_len);
+void qq_captcha_input_dialog(PurpleConnection *gc,qq_captcha_data *captcha);
 
-void qq_request_keep_alive_2008(PurpleConnection *gc);
-gboolean qq_process_keep_alive_2008(guint8 *data, gint data_len, PurpleConnection *gc);
+void qq_request_auth(PurpleConnection *gc);
+guint8 qq_process_auth( PurpleConnection *gc, guint8 *data, gint data_len);
 
-/* for QQ2007/2008 */
-void qq_request_get_server(PurpleConnection *gc);
-guint16 qq_process_get_server(PurpleConnection *gc, guint8 *rcved, gint rcved_len);
-
-void qq_request_token_ex(PurpleConnection *gc);
-void qq_request_token_ex_next(PurpleConnection *gc);
-guint8 qq_process_token_ex(PurpleConnection *gc, guint8 *buf, gint buf_len);
-void qq_captcha_input_dialog(PurpleConnection *gc,qq_captcha_data *captcha);
+void qq_request_verify_E5(PurpleConnection *gc);
+guint8 qq_process_verify_E5(PurpleConnection *gc, guint8 *data, gint data_len);
 
-void qq_request_check_pwd(PurpleConnection *gc);
-guint8 qq_process_check_pwd( PurpleConnection *gc, guint8 *data, gint data_len);
+void qq_request_verify_E3(PurpleConnection *gc);
+guint8 qq_process_verify_E3(PurpleConnection *gc, guint8 *data, gint data_len);
 
-void qq_request_login_2007(PurpleConnection *gc);
-guint8 qq_process_login_2007( PurpleConnection *gc, guint8 *data, gint data_len);
+void qq_request_login(PurpleConnection *gc);
+guint8 qq_process_login( PurpleConnection *gc, guint8 *data, gint data_len);
 
-void qq_request_login_2008(PurpleConnection *gc);
-guint8 qq_process_login_2008( PurpleConnection *gc, guint8 *data, gint data_len);
+void qq_request_login_E9(PurpleConnection *gc);
+void qq_request_login_EA(PurpleConnection *gc);
+void qq_request_login_getlist(PurpleConnection *gc);
+void qq_request_login_EC(PurpleConnection *gc);
+void qq_request_login_ED(PurpleConnection *gc);
+
+guint8 qq_process_login_getlist(PurpleConnection *gc, guint8 *data, gint data_len);
+void qq_clean_buddy_list(PurpleConnection *gc);
+extern void qq_buddy_free(PurpleBuddy *buddy);
+extern void qq_room_remove(PurpleConnection *gc, guint32 id);
 #endif
-
diff -urp libpurple/protocols/qq/qq.c libpurple/protocols/qq/qq.c
--- libpurple/protocols/qq/qq.c	2011-02-07 11:42:12.000000000 +0800
+++ libpurple/protocols/qq/qq.c	2011-02-24 17:38:51.943460335 +0800
@@ -157,29 +157,20 @@ static void qq_login(PurpleAccount *acco
 	purple_debug_info("QQ", "Server list has %d\n", g_list_length(qd->servers));
 
 	version_str = purple_account_get_string(account, "client_version", NULL);
-	qd->client_tag = QQ_CLIENT_115B;	/* set default as QQ2008 */
-	qd->client_version = 2008;
+	qd->client_tag = QQ_CLIENT_1E0D;	/* set default as QQ2010 */
+	qd->client_version = 2010;
 	if (version_str != NULL && strlen(version_str) != 0) {
-		if (strcmp(version_str, "qq2005") == 0) {
-			qd->client_tag = QQ_CLIENT_0D55;
-			qd->client_version = 2005;
-		} else if (strcmp(version_str, "qq2007") == 0) {
-			qd->client_tag = QQ_CLIENT_111D;
-			qd->client_version = 2007;
+		if (strcmp(version_str, "qq2010") == 0) {
+			qd->client_tag = QQ_CLIENT_1E0D;
+			qd->client_version = 2010;
 		}
-	}
+	}
+
 
 	qd->is_show_notice = purple_account_get_bool(account, "show_notice", TRUE);
 	qd->is_show_news = purple_account_get_bool(account, "show_news", TRUE);
 	qd->is_show_chat = purple_account_get_bool(account, "show_chat", TRUE);
 
-	if (purple_account_get_bool(account, "default_font", FALSE)) {
-		qd->custom = QQ_CUSTOM_USE_DEFAULT_FONT;
-	}
-	else {
-		qd->custom = QQ_CUSTOM_NONE;
-	}
-
 	qd->resend_times = purple_prefs_get_int("/plugins/prpl/qq/resend_times");
 	if (qd->resend_times <= 1) qd->itv_config.resend = 4;
 
@@ -211,6 +202,7 @@ static void qq_login(PurpleAccount *acco
 static void qq_close(PurpleConnection *gc)
 {
 	qq_data *qd;
+	guint8 i;
 
 	g_return_if_fail(gc != NULL  && gc->proto_data);
 	qd = gc->proto_data;
@@ -231,10 +223,21 @@ static void qq_close(PurpleConnection *g
 	qq_disconnect(gc);
 
 	if (qd->redirect) g_free(qd->redirect);
-	if (qd->ld.token) g_free(qd->ld.token);
-	if (qd->ld.token_ex) g_free(qd->ld.token_ex);
+	if (qd->ld.token_touch) g_free(qd->ld.token_touch);
+	if (qd->ld.token_captcha) g_free(qd->ld.token_captcha);
 	if (qd->captcha.token) g_free(qd->captcha.token);
 	if (qd->captcha.data) g_free(qd->captcha.data);
+	if (qd->ld.token_auth) {
+		for (i=0; i<3; ++i) if (qd->ld.token_auth[i]) g_free(qd->ld.token_auth[i]);
+		g_free(qd->ld.token_auth);
+	}
+	if (qd->ld.token_verify) {
+		for (i=0; i<3; ++i) if (qd->ld.token_verify[i]) g_free(qd->ld.token_verify[i]);
+		if (qd->ld.token_verify) g_free(qd->ld.token_verify);
+	}
+	if (qd->ld.token_login) g_free(qd->ld.token_login);
+	
+	
 
 	server_list_remove_all(qd);
 
@@ -450,7 +453,7 @@ static void qq_change_status(PurpleAccou
 /* send packet to get who's detailed information */
 static void qq_show_buddy_info(PurpleConnection *gc, const gchar *who)
 {
-	UID uid;
+	guint32 uid;
 	qq_data *qd;
 
 	qd = gc->proto_data;
@@ -462,9 +465,7 @@ static void qq_show_buddy_info(PurpleCon
 		return;
 	}
 
-	if (qd->client_version >= 2007) {
-		qq_request_get_level_2007(gc, uid);
-	} else {
+	if (qd->client_version >= 2010) {
 		qq_request_get_level(gc, uid);
 	}
 	qq_request_buddy_info(gc, uid, 0, QQ_BUDDY_INFO_DISPLAY);
@@ -645,13 +646,14 @@ static void action_about_openq(PurplePlu
 	g_string_append(info, "ccpaging : maintainer since 2007<br>\n");
 	g_string_append(info, "icesky : maintainer since 2007<br>\n");
 	g_string_append(info, "csyfek : faces, maintainer since 2007<br>\n");
+	g_string_append(info, "V.E.O : maintainer since 2011<br>\n");
 	g_string_append(info, "<br>\n");
 
 	g_string_append(info, _("<p><b>Lovely Patch Writers</b>:<br>\n"));
 	g_string_append(info, "gnap : message displaying, documentation<br>\n");
-	g_string_append(info, "manphiz : qun processing<br>\n");
-	g_string_append(info, "moo : qun processing<br>\n");
-	g_string_append(info, "Coly Li : qun processing<br>\n");
+	g_string_append(info, "manphiz : room processing<br>\n");
+	g_string_append(info, "moo : room processing<br>\n");
+	g_string_append(info, "Coly Li : room processing<br>\n");
 	g_string_append(info, "Emil Alexiev : captcha verification on login based on LumaQQ for MAC (2007), login, add buddy, remove buddy, message exchange and logout<br>\n");
 	g_string_append(info, "Chengming Wang : buddy memo<br>\n");
 	g_string_append(info, "lonicerae : chat room window bugfix, server list bugfix, buddy memo<br>\n");
@@ -667,6 +669,7 @@ static void action_about_openq(PurplePlu
 	g_string_append(info, "Pidgin Team : http://www.pidgin.im<br>\n");
 	g_string_append(info, "Huang Guan : http://home.xxsyzx.com<br>\n");
 	g_string_append(info, "OpenQ Google Group : http://groups.google.com/group/openq<br>\n");
+	g_string_append(info, "LibQQ Google code : http://libqq-pidgin.googlecode.com<br>\n");
 	g_string_append(info, "<br>\n");
 
 	g_string_append(info, _("<p><b>Scrupulous Testers</b>:<br>\n"));
@@ -830,7 +833,7 @@ static void qq_modify_buddy_memo_from_me
 	PurpleBuddy *buddy;
 	qq_buddy_data *bd;
 	PurpleConnection *gc;
-	UID bd_uid;
+	guint32 bd_uid;
 
 	g_return_if_fail(PURPLE_BLIST_NODE_IS_BUDDY(node));
 
@@ -847,7 +850,7 @@ static void qq_modify_buddy_memo_from_me
 	/* param: gc, uid, update_class, action
 	 * here, update_class is set to bd_uid. because some memo packages returned
 	 * without uid, which will make us confused */
-	qq_request_buddy_memo(gc, bd_uid, bd_uid, QQ_BUDDY_MEMO_MODIFY);
+	qq_request_buddy_memo(gc, bd_uid, 0, QQ_BUDDY_MEMO_MODIFY);
 }
 
 static GList *qq_buddy_menu(PurpleBuddy *buddy)
@@ -865,7 +868,7 @@ static GList *qq_buddy_menu(PurpleBuddy
 	}
 
 
-	act = purple_menu_action_new(_("Modify Buddy Memo"),
+	act = purple_menu_action_new(_("Modify Buddy Alias"),
 			PURPLE_CALLBACK(qq_modify_buddy_memo_from_menu_cb),
 			NULL, NULL);
 	m = g_list_append(m, act);
@@ -934,7 +937,7 @@ static void qq_get_chat_buddy_info(Purpl
 {
 	qq_data *qd;
 	gchar *uid_str;
-	UID uid;
+	guint32 uid;
 
 	purple_debug_info("QQ", "Get chat buddy info of %s\n", who);
 	g_return_if_fail(who != NULL);
@@ -954,9 +957,6 @@ static void qq_get_chat_buddy_info(Purpl
 		return;
 	}
 
-	if (qd->client_version < 2007) {
-		qq_request_get_level(gc, uid);
-	}
 	qq_request_buddy_info(gc, uid, 0, QQ_BUDDY_INFO_DISPLAY);
 }
 
@@ -1120,18 +1120,8 @@ static void init_plugin(PurplePlugin *pl
 	prpl_info.protocol_options = g_list_append(prpl_info.protocol_options, option);
 
 	kvp = g_new0(PurpleKeyValuePair, 1);
-	kvp->key = g_strdup(_("QQ2008"));
-	kvp->value = g_strdup("qq2008");
-	version_kv_list = g_list_append(version_kv_list, kvp);
-
-	kvp = g_new0(PurpleKeyValuePair, 1);
-	kvp->key = g_strdup(_("QQ2007"));
-	kvp->value = g_strdup("qq2007");
-	version_kv_list = g_list_append(version_kv_list, kvp);
-
-	kvp = g_new0(PurpleKeyValuePair, 1);
-	kvp->key = g_strdup(_("QQ2005"));
-	kvp->value = g_strdup("qq2005");
+	kvp->key = g_strdup(_("QQ2010"));
+	kvp->value = g_strdup("qq2010");
 	version_kv_list = g_list_append(version_kv_list, kvp);
 
 	option = purple_account_option_list_new(_("Client Version"), "client_version", version_kv_list);
@@ -1149,9 +1139,6 @@ static void init_plugin(PurplePlugin *pl
 	option = purple_account_option_bool_new(_("Show chat room when msg comes"), "show_chat", TRUE);
 	prpl_info.protocol_options = g_list_append(prpl_info.protocol_options, option);
 
-	option = purple_account_option_bool_new(_("Use default font"), "default_font", FALSE);
-	prpl_info.protocol_options = g_list_append(prpl_info.protocol_options, option);
-
 	option = purple_account_option_int_new(_("Keep alive interval (seconds)"), "keep_alive_interval", 60);
 	prpl_info.protocol_options = g_list_append(prpl_info.protocol_options, option);
 
diff -urp libpurple/protocols/qq/qq_crypt.c libpurple/protocols/qq/qq_crypt.c
--- libpurple/protocols/qq/qq_crypt.c	2011-01-08 23:19:45.000000000 +0800
+++ libpurple/protocols/qq/qq_crypt.c	2011-02-24 17:38:51.903460334 +0800
@@ -24,7 +24,7 @@
  *
  * QQ encryption algorithm
  * Convert from ASM code provided by PerlOICQ
- *
+ * 
  * Puzzlebird, Nov-Dec 2002
  */
 
@@ -34,8 +34,8 @@ IN : 64  bits of data in v[0] - v[1].
 OUT: 64  bits of data in w[0] - w[1].
 KEY: 128 bits of key  in k[0] - k[3].
 
-delta is chosen to be the real part of
-the golden ratio: Sqrt(5/4) - 1/2 ~ 0.618034 multiplied by 2^32.
+delta is chosen to be the real part of 
+the golden ratio: Sqrt(5/4) - 1/2 ~ 0.618034 multiplied by 2^32. 
 
 0x61C88647 is what we can track on the ASM codes.!!
 */
@@ -53,7 +53,7 @@ void show_binary(char *psztitle, const g
 	for (i = 0; i < bytes; i += 16) {
 		/* length label */
 		printf("%07x: ", i);
-
+		
 		/* dump hex value */
 		for (j = 0; j < 16; j++) {
 			if (j == 8) {
@@ -64,10 +64,10 @@ void show_binary(char *psztitle, const g
 			else
 				printf("   ");
 		}
-
+		
 		printf("  ");
-
-
+		
+		
 		/* dump ascii value */
 		for (j = 0; j < 16 && (i + j) < bytes; j++) {
 			ch = buffer[i + j] & 127;
@@ -82,26 +82,26 @@ void show_binary(char *psztitle, const g
 }
 #else
 
-#define show_binary(args... )		/* nothing */
+#define show_binary		/* nothing */
 
 #endif
 
 /********************************************************************
- * encryption
+ * encryption 
  *******************************************************************/
 
 /* Tiny Encryption Algorithm (TEA) */
 static inline void qq_encipher(guint32 *const v, const guint32 *const k, guint32 *const w)
 {
 	register guint32
-		y = g_ntohl(v[0]),
-		 z = g_ntohl(v[1]),
-		 a = g_ntohl(k[0]),
-		 b = g_ntohl(k[1]),
-		 c = g_ntohl(k[2]),
-		 d = g_ntohl(k[3]),
-		 n = 0x10,
-		 sum = 0,
+		y = g_ntohl(v[0]), 
+		 z = g_ntohl(v[1]), 
+		 a = g_ntohl(k[0]), 
+		 b = g_ntohl(k[1]), 
+		 c = g_ntohl(k[2]), 
+		 d = g_ntohl(k[3]), 
+		 n = 0x10, 
+		 sum = 0, 
 		 delta = 0x9E3779B9;	/*  0x9E3779B9 - 0x100000000 = -0x61C88647 */
 
 	while (n-- > 0) {
@@ -117,8 +117,8 @@ static inline void qq_encipher(guint32 *
 /* it can be the real random seed function */
 /* override with number, convenient for debug */
 #ifdef DEBUG
-static gint crypt_rand(void) {
-	return 0xdead;
+static gint crypt_rand(void) {	
+	return 0xdead; 
 }
 #else
 #include <stdlib.h>
@@ -126,7 +126,7 @@ static gint crypt_rand(void) {
 #endif
 
 /* 64-bit blocks and some kind of feedback mode of operation */
-static inline void encrypt_out(guint8 *crypted, const gint crypted_len, const guint8 *key)
+static inline void encrypt_out(guint8 *crypted, const gint crypted_len, const guint8 *key) 
 {
 	/* ships in encipher */
 	guint32 plain32[2];
@@ -134,34 +134,34 @@ static inline void encrypt_out(guint8 *c
 	guint32 key32[4];
 	guint32 crypted32[2];
 	guint32 c32_prev[2];
-
+	
 	guint8 *crypted_ptr;
 	gint count64;
-
+	
 	/* prepare at first */
 	crypted_ptr = crypted;
-
+	
 	memcpy(crypted32, crypted_ptr, sizeof(crypted32));
 	c32_prev[0] = crypted32[0]; c32_prev[1] = crypted32[1];
-
+	
 	p32_prev[0] = 0; p32_prev[1] = 0;
 	plain32[0] = crypted32[0] ^ p32_prev[0]; plain32[1] = crypted32[1] ^ p32_prev[1];
-
+	
 	g_memmove(key32, key, 16);
 	count64 = crypted_len / 8;
 	while (count64-- > 0){
 		/* encrypt it */
 		qq_encipher(plain32, key32, crypted32);
-
+		
 		crypted32[0] ^= p32_prev[0]; crypted32[1] ^= p32_prev[1];
-
+		
 		/* store curr 64 bits crypted */
 		g_memmove(crypted_ptr, crypted32, sizeof(crypted32));
-
+		
 		/* set prev */
 		p32_prev[0] = plain32[0]; p32_prev[1] = plain32[1];
 		c32_prev[0] = crypted32[0]; c32_prev[1] = crypted32[1];
-
+		
 		/* set next 64 bits want to crypt*/
 		if (count64 > 0) {
 			crypted_ptr += 8;
@@ -181,7 +181,7 @@ gint qq_encrypt(guint8* crypted, const g
 {
 	guint8 *crypted_ptr = crypted;		/* current position of dest */
 	gint pos, padding;
-
+	
 	padding = (plain_len + 10) % 8;
 	if (padding) {
 		padding = 8 - padding;
@@ -223,20 +223,20 @@ gint qq_encrypt(guint8* crypted, const g
 	return pos;
 }
 
-/********************************************************************
- * decryption
+/******************************************************************** 
+ * decryption 
  ********************************************************************/
 
 static inline void qq_decipher(guint32 *const v, const guint32 *const k, guint32 *const w)
 {
 	register guint32
-		y = g_ntohl(v[0]),
-		z = g_ntohl(v[1]),
-		a = g_ntohl(k[0]),
-		b = g_ntohl(k[1]),
-		c = g_ntohl(k[2]),
-		d = g_ntohl(k[3]),
-		n = 0x10,
+		y = g_ntohl(v[0]), 
+		z = g_ntohl(v[1]), 
+		a = g_ntohl(k[0]), 
+		b = g_ntohl(k[1]), 
+		c = g_ntohl(k[2]), 
+		d = g_ntohl(k[3]), 
+		n = 0x10, 
 		sum = 0xE3779B90,	/* why this ? must be related with n value */
 		delta = 0x9E3779B9;
 
@@ -251,7 +251,7 @@ static inline void qq_decipher(guint32 *
 	w[1] = g_htonl(z);
 }
 
-static inline gint decrypt_out(guint8 *dest, gint crypted_len, const guint8* const key)
+static inline gint decrypt_out(guint8 *dest, gint crypted_len, const guint8* const key) 
 {
 	gint plain_len;
 	guint32 key32[4];
@@ -280,7 +280,7 @@ static inline gint decrypt_out(guint8 *d
 	if( plain_len < 0 )	{
 		return -2;
 	}
-
+	
 	count64 = crypted_len / 8;
 	while (--count64 > 0){
 		c32_prev[0] = crypted32[0]; c32_prev[1] = crypted32[1];
@@ -290,7 +290,7 @@ static inline gint decrypt_out(guint8 *d
 		p32_prev[0] ^= crypted32[0]; p32_prev[1] ^= crypted32[1];
 
 		qq_decipher(p32_prev, key32, p32_prev);
-
+		
 		plain32[0] = p32_prev[0] ^ c32_prev[0]; plain32[1] = p32_prev[1] ^ c32_prev[1];
 		memcpy(crypted_ptr, plain32, sizeof(plain32));
 	}
@@ -306,7 +306,7 @@ gint qq_decrypt(guint8 *plain, const gui
 	gint pos;
 
 	/* at least 16 bytes and %8 == 0 */
-	if ((crypted_len % 8) || (crypted_len < 16)) {
+	if ((crypted_len % 8) || (crypted_len < 16)) { 
 		return -1;
 	}
 
diff -urp libpurple/protocols/qq/qq_crypt.h libpurple/protocols/qq/qq_crypt.h
--- libpurple/protocols/qq/qq_crypt.h	2011-01-08 23:19:45.000000000 +0800
+++ libpurple/protocols/qq/qq_crypt.h	2011-02-24 17:38:51.943460335 +0800
@@ -28,6 +28,6 @@
 #include <glib.h>
 
 gint qq_encrypt(guint8* crypted, const guint8* const plain, const gint plain_len, const guint8* const key);
-
+		
 gint qq_decrypt(guint8 *plain, const guint8* const crypted, const gint crypted_len, const guint8* const key);
 #endif
diff -urp libpurple/protocols/qq/qq_define.c libpurple/protocols/qq/qq_define.c
--- libpurple/protocols/qq/qq_define.c	2011-02-07 11:42:12.000000000 +0800
+++ libpurple/protocols/qq/qq_define.c	2011-02-24 17:38:51.983460334 +0800
@@ -44,18 +44,22 @@
 #define QQ_CLIENT_0C21 0x0C21	/* QQ2004 */
 #define QQ_CLIENT_0C49 0x0C49	/* QQ2004II */
 #define QQ_CLIENT_0D05 0x0D05	/* QQ2005 beta1 */
-#define QQ_CLIENT_0D51 0x0D51	/* QQ2005 beta2 */
+#define QQ_CLIENT_0D51 0x0D51	/* QQ2005 beta2 */
+#define QQ_CLIENT_0D55 0x0d55	/* QQ2005 used by openq before */
 #define QQ_CLIENT_0D61 0x0D61	/* QQ2005 */
 #define QQ_CLIENT_05A5 0x05A5	/* ? */
 #define QQ_CLIENT_05F1 0x0F15	/* QQ2006 Spring Festival */
 #define QQ_CLIENT_0F4B 0x0F4B	/* QQ2006 Beta 3  */
 
-#define QQ_CLIENT_1105 0x1105	/* QQ2007 beta4*/
+#define QQ_CLIENT_1105 0x1105	/* QQ2007 beta4*/
+#define QQ_CLIENT_111D 0x111D	/* QQ2007 */
+#define QQ_CLIENT_115B 0x115B	/* QQ2008 He Sui*/
 #define QQ_CLIENT_1203 0x1203	/* QQ2008 */
 #define QQ_CLIENT_1205 0x1205	/* QQ2008 Qi Fu */
 #define QQ_CLIENT_120B 0x120B	/* QQ2008 July 8.0.978.400 */
 #define QQ_CLIENT_1412 0x1412	/* QQMac 1.0 preview1 build 670 */
 #define QQ_CLIENT_1441 0x1441	/* QQ2009 preview2 */
+
 
 #define QQ_SERVER_0100 0x0100	/* server */
 
@@ -118,8 +122,6 @@ const gchar *qq_get_ver_desc(gint source
 		return "QQMac 1.0 preview1 build 670";
 	case QQ_CLIENT_1441:
 		return "QQ2009 preview2";
-	case QQ_CLIENT_1663:
-		return "QQ2009";
 	case QQ_SERVER_0100:
 		return "QQ Server 0100";
 	default:
@@ -155,34 +157,46 @@ const gchar *qq_get_cmd_desc(gint cmd)
 		return "CMD_SEND_IM";
 	case QQ_CMD_RECV_IM:
 		return "CMD_RECV_IM";
+	case QQ_CMD_RECV_IM_CE:
+		return "CMD_RECV_IM_CE";
 	case QQ_CMD_REMOVE_ME:
 		return "CMD_REMOVE_ME";
 	case QQ_CMD_LOGIN:
 		return "CMD_LOGIN";
+	case QQ_CMD_LOGIN_E9:
+		return "QQ_CMD_LOGIN_E9";
+	case QQ_CMD_LOGIN_EA:
+		return "QQ_CMD_LOGIN_EA";
+	case QQ_CMD_LOGIN_GETLIST:
+		return "QQ_CMD_LOGIN_GETLIST";
+	case QQ_CMD_LOGIN_EC:
+		return "QQ_CMD_LOGIN_EC";
+	case QQ_CMD_LOGIN_ED:
+		return "QQ_CMD_LOGIN_ED";
 	case QQ_CMD_GET_BUDDIES_LIST:
 		return "CMD_GET_BUDDIES_LIST";
 	case QQ_CMD_GET_BUDDIES_ONLINE:
 		return "CMD_GET_BUDDIES_ONLINE";
 	case QQ_CMD_ROOM:
 		return "CMD_ROOM";
-	case QQ_CMD_GET_BUDDIES_AND_ROOMS:
-		return "CMD_GET_BUDDIES_AND_ROOMS";
 	case QQ_CMD_GET_LEVEL:
 		return "CMD_GET_LEVEL";
-	case QQ_CMD_TOKEN:
-		return "CMD_TOKEN";
-	case QQ_CMD_RECV_MSG_SYS:
+	case QQ_CMD_RECV_NOTIFY:
 		return "CMD_RECV_MSG_SYS";
 	case QQ_CMD_BUDDY_CHANGE_STATUS:
 		return "CMD_BUDDY_CHANGE_STATUS";
-	case QQ_CMD_GET_SERVER:
-		return "CMD_GET_SERVER";
-	case QQ_CMD_TOKEN_EX:
-		return "CMD_TOKEN_EX";
-	case QQ_CMD_CHECK_PWD:
-		return "CMD_CHECK_PWD";
-	case QQ_CMD_AUTH_CODE:
-		return "CMD_AUTH_CODE";
+	case QQ_CMD_TOUCH_SERVER:
+		return "CMD_TOUCH_SERVER";
+	case QQ_CMD_CAPTCHA:
+		return "QQ_CMD_CAPTCHA";
+	case QQ_CMD_AUTH:
+		return "CMD_AUTH";
+	case QQ_CMD_VERIFY_E5:
+		return "CMD_VERIFY_E5";
+	case QQ_CMD_VERIFY_E3:
+		return "CMD_VERIFY_E3";
+	case QQ_CMD_AUTH_TOKEN:
+		return "CMD_AUTH_TOKEN";
 	case QQ_CMD_ADD_BUDDY_NO_AUTH_EX:
 		return "CMD_ADD_BUDDY_NO_AUTH_EX";
 	case QQ_CMD_ADD_BUDDY_AUTH_EX:
@@ -194,7 +208,7 @@ const gchar *qq_get_cmd_desc(gint cmd)
 	case QQ_CMD_BUDDY_MEMO:
 		return "CMD_BUDDY_MEMO";
 	default:
-		return "CMD_UNKNOW";
+		return "CMD_UNKNOWN";
 	}
 }
 
@@ -250,7 +264,7 @@ const gchar *qq_get_room_cmd_desc(gint r
 	case QQ_ROOM_CMD_TEMP_GET_MEMBERS:
 		return "ROOM_CMD_TEMP_GET_MEMBERS";
 	default:
-		return "ROOM_CMD_UNKNOW";
+		return "ROOM_CMD_UNKNOWN";
 	}
 }
 
diff -urp libpurple/protocols/qq/qq_define.h libpurple/protocols/qq/qq_define.h
--- libpurple/protocols/qq/qq_define.h	2011-02-07 11:42:12.000000000 +0800
+++ libpurple/protocols/qq/qq_define.h	2011-02-24 17:38:51.986793667 +0800
@@ -33,48 +33,51 @@
 #define QQ_PACKET_TAG			0x02	/* all QQ text packets starts with it */
 #define QQ_PACKET_TAIL			0x03	/* all QQ text packets end with it */
 
-#define QQ_CLIENT_0D55 0x0d55	/* QQ2005 used by openq before */
-#define QQ_CLIENT_111D 0x111D	/* QQ2007 */
-#define QQ_CLIENT_115B 0x115B	/* QQ2008 He Sui */
-#define QQ_CLIENT_1663 0x1663	/* QQ2009 Release */
-#define QQ_CLIENT_1801 0x1801	/* QQ2009 International Beta1 */
-
+#define QQ_CLIENT_1E0D 0x1E0D   /* QQ2010 Intl */
 const gchar *qq_get_ver_desc(gint source);
 
 /* list of known QQ commands */
 enum {
-	QQ_CMD_LOGOUT = 0x0001,				/* log out */
-	QQ_CMD_KEEP_ALIVE = 0x0002,			/* get onlines from tencent */
+	QQ_CMD_LOGOUT = 0x0062,				/* log out */
+				/* get onlines from tencent */
 	QQ_CMD_UPDATE_INFO = 0x0004,			/* update information */
 	QQ_CMD_SEARCH_USER = 0x0005,			/* search for user */
-	QQ_CMD_GET_BUDDY_INFO = 0x0006,			/* get user information */
+	QQ_CMD_GET_BUDDY_INFO = 0x003C,			/* get user information */
 	QQ_CMD_ADD_BUDDY_NO_AUTH = 0x0009,		/* add buddy without auth */
 	QQ_CMD_REMOVE_BUDDY = 0x000a,			/* delete a buddy  */
 	QQ_CMD_ADD_BUDDY_AUTH = 0x000b,			/* buddy authentication */
 	QQ_CMD_CHANGE_STATUS = 0x000d,		/* change my online status */
 	QQ_CMD_ACK_SYS_MSG = 0x0012,			/* ack system message */
-	QQ_CMD_SEND_IM = 0x0016,			/* send message */
+	QQ_CMD_SEND_IM = 0x00CD,			/* send message */
 	QQ_CMD_RECV_IM = 0x0017,			/* receive message */
+	QQ_CMD_RECV_IM_CE = 0x00CE,
 	QQ_CMD_REMOVE_ME = 0x001c,			/* remove self */
 	QQ_CMD_REQUEST_KEY = 0x001d,			/* request key for file transfer */
 	QQ_CMD_CELL_PHONE_1 = 0x0021,			/* cell phone 1 */
-	QQ_CMD_LOGIN = 0x0022,				/* login */
-	QQ_CMD_GET_BUDDIES_LIST = 0x0026,		/* get buddies list */
+	QQ_CMD_GET_BUDDIES_LIST = 0x0126,		/* get buddies list */
 	QQ_CMD_GET_BUDDIES_ONLINE = 0x0027,		/* get online buddies list */
 	QQ_CMD_CELL_PHONE_2 = 0x0029,			/* cell phone 2 */
-	QQ_CMD_ROOM = 0x0030,			/* room command */
-	QQ_CMD_GET_BUDDIES_AND_ROOMS = 0x0058,
+	QQ_CMD_ROOM = 0x0031,			/* room command */
 	QQ_CMD_GET_LEVEL = 0x005C,			/* get level for one or more buddies */
-	QQ_CMD_TOKEN  = 0x0062, 		/* get login token */
-	QQ_CMD_RECV_MSG_SYS = 0x0080,			/* receive a system message */
+	QQ_CMD_RECV_NOTIFY = 0x0080,			/* receive a system message */
 	QQ_CMD_BUDDY_CHANGE_STATUS = 0x0081,	/* buddy change status */
 	QQ_CMD_BUDDY_MEMO = 0x003E,    /* the message about buddy memo */
 
-    /* for QQ2007*/
-	QQ_CMD_GET_SERVER = 0x0091,					/* select login server */
-	QQ_CMD_TOKEN_EX = 0x00BA,						/* get LOGIN token */
-	QQ_CMD_CHECK_PWD = 0x00DD,				/* Password verify */
-	QQ_CMD_AUTH_CODE = 0x00AE,				/* the request verification of information */
+    /* for QQ2010*/
+	QQ_CMD_TOUCH_SERVER = 0x0091,					/* touch login server */
+	QQ_CMD_CAPTCHA = 0x00BA,						/* verify LOGIN captcha */
+	QQ_CMD_AUTH = 0x00DD,				/* Password verify */
+	QQ_CMD_VERIFY_E5 = 0x00E5,
+	QQ_CMD_VERIFY_E3 = 0x00E3,
+	QQ_CMD_LOGIN = 0x0030,
+	QQ_CMD_LOGIN_E9 = 0x00E9,
+	QQ_CMD_LOGIN_EA = 0x00EA,
+	QQ_CMD_LOGIN_GETLIST = 0x00EB,
+	QQ_CMD_LOGIN_EC = 0x00EC,
+	QQ_CMD_LOGIN_ED = 0x00ED,
+	QQ_CMD_KEEP_ALIVE = 0x0058,
+
+	QQ_CMD_AUTH_TOKEN = 0x00AE,				/* the request verification of information */
 	QQ_CMD_ADD_BUDDY_NO_AUTH_EX = 0x00A7,			/* add friend without auth */
 	QQ_CMD_ADD_BUDDY_AUTH_EX = 0x00A8, 				/* add buddy with auth */
 	QQ_CMD_BUDDY_CHECK_CODE =  0x00B5,
@@ -84,10 +87,10 @@ enum {
 const gchar *qq_get_cmd_desc(gint type);
 
 enum {
-	QQ_ROOM_CMD_CREATE = 0x01,
+	QQ_ROOM_CMD_GET_INFO = 0x01,
+	QQ_ROOM_CMD_CREATE = 0x04,	//Deprecated
 	QQ_ROOM_CMD_MEMBER_OPT = 0x02,
 	QQ_ROOM_CMD_CHANGE_INFO = 0x03,
-	QQ_ROOM_CMD_GET_INFO = 0x04,
 	QQ_ROOM_CMD_ACTIVATE = 0x05,
 	QQ_ROOM_CMD_SEARCH = 0x06,
 	QQ_ROOM_CMD_JOIN = 0x07,
diff -urp libpurple/protocols/qq/qq.h libpurple/protocols/qq/qq.h
--- libpurple/protocols/qq/qq.h	2011-02-07 11:42:12.000000000 +0800
+++ libpurple/protocols/qq/qq.h	2011-02-24 17:38:51.943460335 +0800
@@ -39,49 +39,63 @@
 #define qq_strlen(s) ((s)!=NULL?strlen(s):0)
 #define qq_strcmp(s1,s2) ((s1)!=NULL && (s2)!=NULL?strcmp(s1,s2):0)
 
-/* business logic layer */
-typedef guint32 UPDCLS;
-typedef guint32 UID;
+typedef struct _qq_data qq_data;
+typedef struct _qq_buddy_data qq_buddy_data;
+typedef struct _qq_interval qq_interval;
+typedef struct _qq_net_stat qq_net_stat;
+typedef struct _qq_login_data qq_login_data;
+typedef struct _qq_captcha_data qq_captcha_data;
 
-typedef struct _qq_captcha_data {
+struct _qq_captcha_data {
 	guint8 *token;
 	guint16 token_len;
 	guint8 next_index;
 	guint8 *data;
 	guint16 data_len;
-} qq_captcha_data;
+};
 
-typedef struct _qq_login_data {
+struct _qq_login_data {
 	guint8 random_key[QQ_KEY_LENGTH];			/* first encrypt key generated by client */
-	guint8 *token;				/* get from server */
-	guint8 token_len;
-	guint8 *token_ex;			/* get from server */
-	guint16 token_ex_len;
+	guint8 *token_touch;				/* get from server */
+	guint16 token_touch_len;
+	guint8 *token_captcha;			/* get from server */
+	guint16 token_captcha_len;
 
 	guint8 pwd_md5[QQ_KEY_LENGTH];			/* password in md5 (or md5' md5) */
 	guint8 pwd_twice_md5[QQ_KEY_LENGTH];
 
-	guint8 *login_token;
-	guint16 login_token_len;
-	guint8 login_key[QQ_KEY_LENGTH];
-} qq_login_data;
+	guint8 **token_auth;
+	guint16 token_auth_len[3];
+	guint8 keys[4][QQ_KEY_LENGTH];	/* 0,Key to VerifyE5&VerifyE3&Login Request,
+																			Sometimes to Login Response;
+																		1,Key to VerifyE5 Response;
+																		2,Key to Login Response;
+																		3,Key to VerifyE3 Response */
+
+	guint8 **token_verify;
+	guint16 token_verify_len[3];
+	guint32 login_fill;
+
+	guint8 *token_login;
+	guint16 token_login_len;
+};
 
-typedef struct _qq_interval {
+struct _qq_interval {
 	gint resend;
 	gint keep_alive;
 	gint update;
-} qq_interval;
+};
 
-typedef struct _qq_net_stat {
+struct _qq_net_stat {
 	glong sent;
 	glong resend;
 	glong lost;
 	glong rcved;
 	glong rcved_dup;
-} qq_net_stat;
+};
 
-typedef struct _qq_buddy_data {
-	UID uid;
+struct _qq_buddy_data {
+	guint32 uid;
 	guint16 face;		/* index: 0 - 299 */
 	guint8 age;
 	guint8 gender;
@@ -101,7 +115,7 @@ typedef struct _qq_buddy_data {
 	gchar** memo;
 
 	gint8  role;		/* role in group, used only in group->members list */
-} qq_buddy_data;
+};
 
 typedef struct _qq_connection qq_connection;
 struct _qq_connection {
@@ -115,7 +129,7 @@ struct _qq_connection {
 	int tcp_rxlen;
 };
 
-typedef struct _qq_data {
+struct _qq_data {
 	PurpleConnection *gc;
 
 	GSList *openconns;
@@ -134,10 +148,12 @@ typedef struct _qq_data {
 	guint16 client_tag;
 	gint client_version;
 
+
 	struct in_addr redirect_ip;
 	guint16 redirect_port;
 	guint8 *redirect;
 	guint8 redirect_len;
+	guint8 redirect_times;
 
 	guint check_watcher;
 	guint connect_watcher;
@@ -150,7 +166,8 @@ typedef struct _qq_data {
 
 	GList *transactions;	/* check ack packet and resend */
 
-	UID uid;			/* QQ number */
+	guint32 uid;			/* QQ number */
+	gchar * nickname;	/* QQ nickname */
 
 	qq_login_data ld;
 	qq_captcha_data captcha;
@@ -166,7 +183,7 @@ typedef struct _qq_data {
 
 	/* get from login reply packet */
 	struct in_addr my_local_ip;			/* my local ip address detected by server */
-	guint16 my_local_port;		/* my lcoal port detected by server */
+	//guint16 my_local_port;		/* my lcoal port detected by server */
 	time_t login_time;
 	time_t last_login_time[3];
 	struct in_addr last_login_ip;
@@ -176,6 +193,9 @@ typedef struct _qq_data {
 	guint16 my_icon;		/* my icon index */
 	guint32 online_total;		/* the number of online QQ users */
 	time_t online_last_update;		/* last time send get_friends_online packet */
+	guint8 onlineTime;
+	guint16 level;
+	guint16 activeDays;
 
 	PurpleRoomlist *roomlist;
 
@@ -184,9 +204,8 @@ typedef struct _qq_data {
 	gboolean is_show_notice;
 	gboolean is_show_news;
 	gboolean is_show_chat;
-	guint32 custom;
 
 	guint16 send_im_id;		/* send IM sequence number */
-} qq_data;
+};
 
 #endif
diff -urp libpurple/protocols/qq/qq_network.c libpurple/protocols/qq/qq_network.c
--- libpurple/protocols/qq/qq_network.c	2011-02-07 11:42:12.000000000 +0800
+++ libpurple/protocols/qq/qq_network.c	2011-02-24 17:38:51.983460334 +0800
@@ -42,11 +42,11 @@
 #define QQ_DEFAULT_PORT					8000
 
 /* set QQ_CONNECT_MAX to 1, when test reconnecting */
-#define QQ_CONNECT_MAX				3
+#define QQ_CONNECT_MAX						3
 #define QQ_CONNECT_INTERVAL			2
-#define QQ_CONNECT_CHECK			5
-#define QQ_KEEP_ALIVE_INTERVAL			60
-#define QQ_TRANS_INTERVAL			10
+#define QQ_CONNECT_CHECK					5
+#define QQ_KEEP_ALIVE_INTERVAL		60
+#define QQ_TRANS_INTERVAL				10
 
 gboolean connect_to_server(PurpleConnection *gc, gchar *server, gint port);
 
@@ -63,7 +63,6 @@ static qq_connection *connection_find(qq
 
 static qq_connection *connection_create(qq_data *qd, int fd) {
 	qq_connection *ret = g_new0(qq_connection, 1);
-	g_return_val_if_fail(ret != NULL, NULL);
 	ret->fd = fd;
 	qd->openconns = g_slist_append(qd->openconns, ret);
 	return ret;
@@ -145,6 +144,7 @@ static gint packet_get_header(guint8 *he
 	bytes += qq_get16(source_tag, buf + bytes);
 	bytes += qq_get16(cmd, buf + bytes);
 	bytes += qq_get16(seq, buf + bytes);
+	bytes += 7;	/* add 4 bytes qq num and 3 bytes fill 00 00 00 */
 	return bytes;
 }
 
@@ -161,7 +161,7 @@ static gboolean connect_check(gpointer d
 		qd->connect_watcher = 0;
 	}
 
-	if (qd->fd >= 0 && qd->ld.token != NULL && qd->ld.token_len > 0) {
+	if (qd->fd >= 0 && qd->ld.token_touch != NULL && qd->ld.token_touch_len > 0) {
 		purple_debug_info("QQ", "Connect ok\n");
 		return FALSE;
 	}
@@ -264,12 +264,12 @@ static gboolean packet_process(PurpleCon
 	gint bytes, bytes_not_read;
 
 	guint8 header_tag;
-	guint16 source_tag;
+	guint16 version_tag;
 	guint16 cmd;
 	guint16 seq;		/* May be ack_seq or send_seq, depends on cmd */
 	guint8 room_cmd;
 	guint32 room_id;
-	UPDCLS update_class;
+	guint32 update_class;
 	guint32 ship32;
 	int ret;
 
@@ -284,15 +284,16 @@ static gboolean packet_process(PurpleCon
 
 	/* Len, header and tail tag have been checked before */
 	bytes = 0;
-	bytes += packet_get_header(&header_tag, &source_tag, &cmd, &seq, buf + bytes);
+	bytes += packet_get_header(&header_tag, &version_tag, &cmd, &seq, buf + bytes);
 
 #if 1
-		purple_debug_info("QQ", "==> [%05d] %s 0x%04X, source tag 0x%04X len %d\n",
-				seq, qq_get_cmd_desc(cmd), cmd, source_tag, buf_len);
+		purple_debug_info("QQ", "==> [%05d] %s 0x%04X, version tag 0x%04X len %d\n",
+				seq, qq_get_cmd_desc(cmd), cmd, version_tag, buf_len);
+		
 #endif
 	/* this is the length of all the encrypted data (also remove tail tag) */
 	bytes_not_read = buf_len - bytes - 1;
-
+	
 	/* ack packet, we need to update send tranactions */
 	/* we do not check duplication for server ack */
 	trans = qq_trans_find_rcved(gc, cmd, seq);
@@ -320,14 +321,20 @@ static gboolean packet_process(PurpleCon
 	}
 
 	switch (cmd) {
-		case QQ_CMD_TOKEN:
-		case QQ_CMD_GET_SERVER:
-		case QQ_CMD_TOKEN_EX:
-		case QQ_CMD_CHECK_PWD:
+		case QQ_CMD_TOUCH_SERVER:
+		case QQ_CMD_CAPTCHA:
+		case QQ_CMD_AUTH:
+		case QQ_CMD_VERIFY_E5:
+		case QQ_CMD_VERIFY_E3:
 		case QQ_CMD_LOGIN:
+		case QQ_CMD_LOGIN_E9:
+		case QQ_CMD_LOGIN_EA:
+		case QQ_CMD_LOGIN_GETLIST:
+		case QQ_CMD_LOGIN_ED:
+		case QQ_CMD_LOGIN_EC:
 			ret = qq_proc_login_cmds(gc, cmd, seq, buf + bytes, bytes_not_read, update_class, ship32);
 			if (ret != QQ_LOGIN_REPLY_OK) {
-				if (ret == QQ_LOGIN_REPLY_REDIRECT) {
+				if (ret == QQ_TOUCH_REPLY_REDIRECT) {
 					redirect_server(gc);
 				}
 				return FALSE;	/* do nothing after this function and return now */
@@ -677,11 +684,7 @@ static gboolean network_timeout(gpointer
 	qd->itv_count.keep_alive--;
 	if (qd->itv_count.keep_alive <= 0) {
 		qd->itv_count.keep_alive = qd->itv_config.keep_alive;
-		if (qd->client_version >= 2008) {
-			qq_request_keep_alive_2008(gc);
-		} else if (qd->client_version >= 2007) {
-			qq_request_keep_alive_2007(gc);
-		} else {
+		if (qd->client_version >= 2010) {
 			qq_request_keep_alive(gc);
 		}
 		return TRUE;
@@ -773,14 +776,9 @@ static void connect_cb(gpointer data, gi
 	}
 
 	/* _qq_show_socket("Got login socket", source); */
-	/* ok, already connected to the server */
 	qd->fd = source;
 	conn = connection_create(qd, source);
-	g_return_if_fail( conn != NULL );
-
 	if (qd->use_tcp) {
-		/* events which match "PURPLE_INPUT_READ" of
-		 * "source" would trigger the callback function */
 		conn->input_handler = purple_input_add(source, PURPLE_INPUT_READ, tcp_pending, gc);
 	} else {
 		conn->input_handler = purple_input_add(source, PURPLE_INPUT_READ, udp_pending, gc);
@@ -791,14 +789,11 @@ static void connect_cb(gpointer data, gi
 
 	set_all_keys( gc );
 
-	if (qd->client_version >= 2007) {
+	if (qd->client_version >= 2010) {
 		purple_connection_update_progress(gc, _("Getting server"), 2, QQ_CONNECT_STEPS);
-		qq_request_get_server(gc);
+		qq_request_touch_server(gc);
 		return;
 	}
-
-	purple_connection_update_progress(gc, _("Requesting token"), 2, QQ_CONNECT_STEPS);
-	qq_request_token(gc);
 }
 
 #ifndef purple_proxy_connect_udp
@@ -1043,12 +1038,10 @@ void qq_disconnect(PurpleConnection *gc)
 	memset(qd->ld.random_key, 0, sizeof(qd->ld.random_key));
 	memset(qd->ld.pwd_md5, 0, sizeof(qd->ld.pwd_md5));
 	memset(qd->ld.pwd_twice_md5, 0, sizeof(qd->ld.pwd_twice_md5));
-	memset(qd->ld.login_key, 0, sizeof(qd->ld.login_key));
 	memset(qd->session_key, 0, sizeof(qd->session_key));
 	memset(qd->session_md5, 0, sizeof(qd->session_md5));
 
 	qd->my_local_ip.s_addr = 0;
-	qd->my_local_port = 0;
 	qd->my_ip.s_addr = 0;
 	qd->my_port = 0;
 
@@ -1071,11 +1064,15 @@ static gint packet_encap(qq_data *qd, gu
 	/* now comes the normal QQ packet as UDP */
 	bytes += qq_put8(buf + bytes, QQ_PACKET_TAG);
 	bytes += qq_put16(buf + bytes, qd->client_tag);
+	
 	bytes += qq_put16(buf + bytes, cmd);
 
 	bytes += qq_put16(buf + bytes, seq);
 
 	bytes += qq_put32(buf + bytes, qd->uid);
+
+	bytes += qq_putdata(buf + bytes,header_fill,sizeof(header_fill));
+
 	bytes += qq_putdata(buf + bytes, data, data_len);
 	bytes += qq_put8(buf + bytes, QQ_PACKET_TAIL);
 
@@ -1137,7 +1134,7 @@ gint qq_send_cmd_encrypted(PurpleConnect
 /* Encrypt data with session_key, and send packet out */
 static gint send_cmd_detail(PurpleConnection *gc, guint16 cmd, guint16 seq,
 	guint8 *data, gint data_len, gboolean is_save2trans,
-        UPDCLS update_class, guint32 ship32)
+        guint32 update_class, guint32 ship32)
 {
 	qq_data *qd;
 	guint8 *encrypted;
@@ -1167,7 +1164,7 @@ static gint send_cmd_detail(PurpleConnec
 }
 
 gint qq_send_cmd_mess(PurpleConnection *gc, guint16 cmd, guint8 *data, gint data_len,
-		UPDCLS update_class, guint32 ship32)
+		guint32 update_class, guint32 ship32)
 {
 	qq_data *qd;
 	guint16 seq;
@@ -1241,7 +1238,7 @@ gint qq_send_server_reply(PurpleConnecti
 }
 
 static gint send_room_cmd(PurpleConnection *gc, guint8 room_cmd, guint32 room_id,
-		guint8 *data, gint data_len, UPDCLS update_class, guint32 ship32)
+		guint8 *data, gint data_len, guint32 update_class, guint32 ship32)
 {
 	qq_data *qd;
 	guint8 *buf;
@@ -1254,11 +1251,11 @@ static gint send_room_cmd(PurpleConnecti
 	g_return_val_if_fail(gc != NULL && gc->proto_data != NULL, -1);
 	qd = (qq_data *) gc->proto_data;
 
-	buf = g_newa(guint8, MAX_PACKET_SIZE);
-	memset(buf, 0, MAX_PACKET_SIZE);
+	buf = g_newa(guint8, 16+data_len);
+	memset(buf, 0, 16+data_len);
 
 	/* encap room_cmd and room id to buf*/
-	buf_len = 0;
+	buf_len = qq_put8(buf, 0x1F);
 	buf_len += qq_put8(buf + buf_len, room_cmd);
 	if (room_id != 0) {
 		/* id 0 is for QQ Demo Group, now they are closed*/
@@ -1295,7 +1292,7 @@ static gint send_room_cmd(PurpleConnecti
 }
 
 gint qq_send_room_cmd_mess(PurpleConnection *gc, guint8 room_cmd, guint32 room_id,
-		guint8 *data, gint data_len, UPDCLS update_class, guint32 ship32)
+		guint8 *data, gint data_len, guint32 update_class, guint32 ship32)
 {
 	g_return_val_if_fail(room_cmd > 0, -1);
 	return send_room_cmd(gc, room_cmd, room_id, data, data_len, update_class, ship32);
diff -urp libpurple/protocols/qq/qq_network.h libpurple/protocols/qq/qq_network.h
--- libpurple/protocols/qq/qq_network.h	2011-02-07 11:42:12.000000000 +0800
+++ libpurple/protocols/qq/qq_network.h	2011-02-24 17:38:51.986793667 +0800
@@ -39,7 +39,7 @@ gint qq_send_cmd_encrypted(PurpleConnect
 		guint8 *encrypted_data, gint encrypted_len, gboolean is_save2trans);
 gint qq_send_cmd(PurpleConnection *gc, guint16 cmd, guint8 *data, gint datalen);
 gint qq_send_cmd_mess(PurpleConnection *gc, guint16 cmd, guint8 *data, gint data_len,
-		UPDCLS update_class, guint32 ship32);
+		guint32 update_class, guint32 ship32);
 
 gint qq_send_server_reply(PurpleConnection *gc, guint16 cmd, guint16 seq,
 		guint8 *data, gint data_len);
@@ -47,7 +47,7 @@ gint qq_send_server_reply(PurpleConnecti
 gint qq_send_room_cmd(PurpleConnection *gc, guint8 room_cmd, guint32 room_id,
 		guint8 *data, gint data_len);
 gint qq_send_room_cmd_mess(PurpleConnection *gc, guint8 room_cmd, guint32 room_id,
-		guint8 *data, gint data_len, UPDCLS update_class, guint32 ship32);
+		guint8 *data, gint data_len, guint32 update_class, guint32 ship32);
 gint qq_send_room_cmd_only(PurpleConnection *gc, guint8 room_cmd, guint32 room_id);
 gint qq_send_room_cmd_noid(PurpleConnection *gc, guint8 room_cmd,
 		guint8 *data, gint data_len);
diff -urp libpurple/protocols/qq/qq_process.c libpurple/protocols/qq/qq_process.c
--- libpurple/protocols/qq/qq_process.c	2011-02-07 11:42:12.000000000 +0800
+++ libpurple/protocols/qq/qq_process.c	2011-02-24 17:38:51.943460335 +0800
@@ -56,7 +56,7 @@ enum {
 };
 
 /* default process, decrypt and dump */
-static void process_unknow_cmd(PurpleConnection *gc,const gchar *title, guint8 *data, gint data_len, guint16 cmd, guint16 seq)
+static void process_unknown_cmd(PurpleConnection *gc,const gchar *title, guint8 *data, gint data_len, guint16 cmd, guint16 seq)
 {
 	gchar *msg;
 
@@ -69,8 +69,8 @@ static void process_unknow_cmd(PurpleCon
 			">>> [%d] %s -> [default] decrypt and dump",
 			seq, qq_get_cmd_desc(cmd));
 
-	msg = g_strdup_printf("Unknow command 0x%02X, %s", cmd, qq_get_cmd_desc(cmd));
-	purple_notify_info(gc, _("QQ Error"), title, msg);
+	msg = g_strdup_printf("Unknown command 0x%02X, %s", cmd, qq_get_cmd_desc(cmd));
+	//purple_notify_info(gc, _("QQ Error"), title, msg);
 	g_free(msg);
 }
 
@@ -101,9 +101,9 @@ static void do_server_news(PurpleConnect
 
 	bytes = 4;	/* skip unknown 4 bytes */
 
-	bytes += qq_get_vstr(&title, QQ_CHARSET_DEFAULT, data + bytes);
-	bytes += qq_get_vstr(&brief, QQ_CHARSET_DEFAULT, data + bytes);
-	bytes += qq_get_vstr(&url, QQ_CHARSET_DEFAULT, data + bytes);
+	bytes += qq_get_vstr(&title, QQ_CHARSET_DEFAULT, sizeof(guint8), data + bytes);
+	bytes += qq_get_vstr(&brief, QQ_CHARSET_DEFAULT, sizeof(guint8), data + bytes);
+	bytes += qq_get_vstr(&url, QQ_CHARSET_DEFAULT, sizeof(guint8), data + bytes);
 
 	content = g_strdup_printf(_("Server News:\n%s\n%s\n%s"), title, brief, url);
 
@@ -152,110 +152,73 @@ static void do_got_sms(PurpleConnection
 	g_free(mobile);
 }
 
-static void do_msg_sys_30(PurpleConnection *gc, guint8 *data, gint data_len)
+static void do_msg_sys(PurpleConnection *gc, guint8 *data, gint data_len)
 {
-	gint len;
 	guint8 reply;
-	gchar **segments, *msg_utf8;
+	gchar *msg;
 
 	g_return_if_fail(data != NULL && data_len != 0);
 
-	len = data_len;
-
-	if (NULL == (segments = split_data(data, len, "\x2f", 2)))
-		return;
+	qq_get8(&reply, data+4);
+	qq_get_vstr(&msg, NULL, sizeof(guint8), data+5);
 
-	reply = strtol(segments[0], NULL, 10);
-	if (reply == 1)
+	if (reply == 0x01)
 		purple_debug_warning("QQ", "We are kicked out by QQ server\n");
 
-	msg_utf8 = qq_to_utf8(segments[1], QQ_CHARSET_DEFAULT);
-	qq_got_message(gc, msg_utf8);
-}
-
-static void do_msg_sys_4c(PurpleConnection *gc, guint8 *data, gint data_len)
-{
-	gint bytes;
-	gint msg_len;
-	GString *content;
-	gchar *msg = NULL;
-
-	g_return_if_fail(data != NULL && data_len > 0);
-
-	bytes = 6; /* skip 0x(06 00 01 1e 01 1c)*/
-
-	content = g_string_new("");
-	while (bytes < data_len) {
-		msg_len = qq_get_vstr(&msg, QQ_CHARSET_DEFAULT, data + bytes);
-		g_string_append(content, msg);
-		g_string_append(content, "\n");
-		g_free(msg);
-
-		if (msg_len <= 1) {
-			break;
-		}
-		bytes += msg_len;
-	}
-	if (bytes != data_len) {
-		purple_debug_warning("QQ", "Failed to read QQ_MSG_SYS_4C\n");
-		qq_show_packet("do_msg_sys_4c", data, data_len);
-	}
-	qq_got_message(gc, content->str);
-	g_string_free(content, FALSE);
+	qq_got_message(gc, msg);
 }
 
 static const gchar *get_im_type_desc(gint type)
 {
 	switch (type) {
-		case QQ_MSG_TO_BUDDY:
-			return "QQ_MSG_TO_BUDDY";
+		case QQ_MSG_BUDDY_09:
+			return "QQ_MSG_BUDDY_09";
 		case QQ_MSG_TO_UNKNOWN:
 			return "QQ_MSG_TO_UNKNOWN";
-		case QQ_MSG_QUN_IM_UNKNOWN:
-			return "QQ_MSG_QUN_IM_UNKNOWN";
-		case QQ_MSG_ADD_TO_QUN:
-			return "QQ_MSG_ADD_TO_QUN";
-		case QQ_MSG_DEL_FROM_QUN:
-			return "QQ_MSG_DEL_FROM_QUN";
-		case QQ_MSG_APPLY_ADD_TO_QUN:
-			return "QQ_MSG_APPLY_ADD_TO_QUN";
-		case QQ_MSG_CREATE_QUN:
-			return "QQ_MSG_CREATE_QUN";
-		case QQ_MSG_SYS_30:
-			return "QQ_MSG_SYS_30";
-		case QQ_MSG_SYS_4C:
-			return "QQ_MSG_SYS_4C";
-		case QQ_MSG_APPROVE_APPLY_ADD_TO_QUN:
-			return "QQ_MSG_APPROVE_APPLY_ADD_TO_QUN";
-		case QQ_MSG_REJCT_APPLY_ADD_TO_QUN:
-			return "QQ_MSG_REJCT_APPLY_ADD_TO_QUN";
-		case QQ_MSG_TEMP_QUN_IM:
-			return "QQ_MSG_TEMP_QUN_IM";
-		case QQ_MSG_QUN_IM:
-			return "QQ_MSG_QUN_IM";
+		case QQ_MSG_ROOM_IM_UNKNOWN:
+			return "QQ_MSG_ROOM_IM_UNKNOWN";
+		case QQ_MSG_ADD_TO_ROOM:
+			return "QQ_MSG_ADD_TO_ROOM";
+		case QQ_MSG_DEL_FROM_ROOM:
+			return "QQ_MSG_DEL_FROM_ROOM";
+		case QQ_MSG_APPLY_ADD_TO_ROOM:
+			return "QQ_MSG_APPLY_ADD_TO_ROOM";
+		case QQ_MSG_CREATE_ROOM:
+			return "QQ_MSG_CREATE_ROOM";
+		case QQ_MSG_SYS:
+			return "QQ_MSG_SYS";
+		case QQ_MSG_APPROVE_APPLY_ADD_TO_ROOM:
+			return "QQ_MSG_APPROVE_APPLY_ADD_TO_ROOM";
+		case QQ_MSG_REJCT_APPLY_ADD_TO_ROOM:
+			return "QQ_MSG_REJCT_APPLY_ADD_TO_ROOM";
+		case QQ_MSG_TEMP_ROOM_IM:
+			return "QQ_MSG_TEMP_ROOM_IM";
+		case QQ_MSG_ROOM_IM:
+			return "QQ_MSG_ROOM_IM";
 		case QQ_MSG_NEWS:
 			return "QQ_MSG_NEWS";
 		case QQ_MSG_SMS:
 			return "QQ_MSG_SMS";
-		case QQ_MSG_EXTEND:
-			return "QQ_MSG_EXTEND";
-		case QQ_MSG_EXTEND_85:
-			return "QQ_MSG_EXTEND_85";
+		case QQ_MSG_BUDDY_84:
+			return "QQ_MSG_BUDDY_84";
+		case QQ_MSG_BUDDY_85:
+			return "QQ_MSG_BUDDY_85";
 		default:
 			return "QQ_MSG_UNKNOWN";
 	}
 }
 
 /* I receive a message, mainly it is text msg,
- * but we need to proess other types (group etc) */
+ * but we need to process other types (group etc) */
 static void process_private_msg(guint8 *data, gint data_len, guint16 seq, PurpleConnection *gc)
 {
 	qq_data *qd;
 	gint bytes;
-
+	guint16 len;
+	guint8 tmp8;
 	struct {
-		UID uid_from;
-		UID uid_to;
+		guint32 uid_from;
+		guint32 uid_to;
 		guint32 seq;
 		struct in_addr ip_from;
 		guint16 port_from;
@@ -303,70 +266,78 @@ static void process_private_msg(guint8 *
 	}
 
 	switch (header.msg_type) {
-		case QQ_MSG_NEWS:
-			do_server_news(gc, data + bytes, data_len - bytes);
-			break;
-		case QQ_MSG_SMS:
-			do_got_sms(gc, data + bytes, data_len - bytes);
-			break;
-		case QQ_MSG_EXTEND:
-		case QQ_MSG_EXTEND_85:
-			purple_debug_info("QQ", "MSG from buddy [%d]\n", header.uid_from);
-			qq_process_extend_im(gc, data + bytes, data_len - bytes);
-			break;
-		case QQ_MSG_TO_UNKNOWN:
-		case QQ_MSG_TO_BUDDY:
-			purple_debug_info("QQ", "MSG from buddy [%d]\n", header.uid_from);
-			qq_process_im(gc, data + bytes, data_len - bytes);
-			break;
-		case QQ_MSG_QUN_IM_UNKNOWN:
-		case QQ_MSG_TEMP_QUN_IM:
-		case QQ_MSG_QUN_IM:
-			purple_debug_info("QQ", "MSG from room [%d]\n", header.uid_from);
-			qq_process_room_im(data + bytes, data_len - bytes, header.uid_from, gc, header.msg_type);
-			break;
-		case QQ_MSG_ADD_TO_QUN:
-			purple_debug_info("QQ", "Notice from [%d], Added\n", header.uid_from);
-			/* uid_from is group id
-			 * we need this to create a dummy group and add to blist */
-			qq_process_room_buddy_joined(data + bytes, data_len - bytes, header.uid_from, gc);
-			break;
-		case QQ_MSG_DEL_FROM_QUN:
-			purple_debug_info("QQ", "Notice from room [%d], Removed\n", header.uid_from);
-			/* uid_from is group id */
-			qq_process_room_buddy_removed(data + bytes, data_len - bytes, header.uid_from, gc);
-			break;
-		case QQ_MSG_APPLY_ADD_TO_QUN:
-			purple_debug_info("QQ", "Notice from room [%d], Joined\n", header.uid_from);
-			/* uid_from is group id */
-			qq_process_room_buddy_request_join(data + bytes, data_len - bytes, header.uid_from, gc);
-			break;
-		case QQ_MSG_APPROVE_APPLY_ADD_TO_QUN:
-			purple_debug_info("QQ", "Notice from room [%d], Confirm add in\n",
-					header.uid_from);
-			/* uid_from is group id */
-			qq_process_room_buddy_approved(data + bytes, data_len - bytes, header.uid_from, gc);
-			break;
-		case QQ_MSG_REJCT_APPLY_ADD_TO_QUN:
-			purple_debug_info("QQ", "Notice from room [%d], Refuse add in\n",
-					header.uid_from);
-			/* uid_from is group id */
-			qq_process_room_buddy_rejected(data + bytes, data_len - bytes, header.uid_from, gc);
-			break;
-		case QQ_MSG_SYS_30:
-			do_msg_sys_30(gc, data + bytes, data_len - bytes);
-			break;
-		case QQ_MSG_SYS_4C:
-			do_msg_sys_4c(gc, data + bytes, data_len - bytes);
-			break;
-		default:
-			purple_debug_warning("QQ", "MSG from %u, unknown type %s [0x%04X]\n",
-					header.uid_from, get_im_type_desc(header.msg_type), header.msg_type);
-			qq_show_packet("MSG header", data, bytes);
-			if (data_len - bytes > 0) {
-				qq_show_packet("MSG data", data + bytes, data_len - bytes);
-			}
-			break;
+	case QQ_MSG_BUDDY_84:
+	case QQ_MSG_BUDDY_85:
+		purple_debug_info("QQ", "MSG from buddy [%d]\n", header.uid_from);
+		qq_process_im(gc, data + bytes, data_len - bytes, header.msg_type);
+		break;
+	case QQ_MSG_TO_UNKNOWN:
+	case QQ_MSG_BUDDY_09:		
+	case QQ_MSG_BUDDY_A6:
+	case QQ_MSG_BUDDY_78:
+		purple_debug_info("QQ	", "MSG from buddy [%d]\n", header.uid_from);
+		bytes += 1;
+		qq_get8(&tmp8, data+bytes);
+		while (tmp8 == 0)
+		{
+			bytes += 1;
+			bytes += qq_get16(&len, data+bytes);
+			bytes += len;
+			qq_get8(&tmp8, data+bytes);
+		}
+		qq_process_im(gc, data + bytes, data_len - bytes, header.msg_type);
+		break;
+	case QQ_MSG_NEWS:
+		do_server_news(gc, data + bytes, data_len - bytes);
+		break;
+	case QQ_MSG_SMS:
+		do_got_sms(gc, data + bytes, data_len - bytes);
+		break;
+	case QQ_MSG_ROOM_IM_UNKNOWN:
+	case QQ_MSG_TEMP_ROOM_IM:
+	case QQ_MSG_ROOM_IM:
+		purple_debug_info("QQ", "MSG from room [%d]\n", header.uid_from);
+		qq_process_room_im(data + bytes, data_len - bytes, header.uid_from, gc, header.msg_type);
+		break;
+	case QQ_MSG_ADD_TO_ROOM:
+		purple_debug_info("QQ", "Notice from [%d], Added\n", header.uid_from);
+		/* uid_from is group id
+		* we need this to create a dummy group and add to blist */
+		qq_process_room_buddy_joined(data + bytes, data_len - bytes, header.uid_from, gc);
+		break;
+	case QQ_MSG_DEL_FROM_ROOM:
+		purple_debug_info("QQ", "Notice from room [%d], Removed\n", header.uid_from);
+		/* uid_from is group id */
+		qq_process_room_buddy_removed(data + bytes, data_len - bytes, header.uid_from, gc);
+		break;
+	case QQ_MSG_APPLY_ADD_TO_ROOM:
+		purple_debug_info("QQ", "Notice from room [%d], Joined\n", header.uid_from);
+		/* uid_from is group id */
+		qq_process_room_buddy_request_join(data + bytes, data_len - bytes, header.uid_from, gc);
+		break;
+	case QQ_MSG_APPROVE_APPLY_ADD_TO_ROOM:
+		purple_debug_info("QQ", "Notice from room [%d], Confirm add in\n",
+			header.uid_from);
+		/* uid_from is group id */
+		qq_process_room_buddy_approved(data + bytes, data_len - bytes, header.uid_from, gc);
+		break;
+	case QQ_MSG_REJCT_APPLY_ADD_TO_ROOM:
+		purple_debug_info("QQ", "Notice from room [%d], Refuse add in\n",
+			header.uid_from);
+		/* uid_from is group id */
+		qq_process_room_buddy_rejected(data + bytes, data_len - bytes, header.uid_from, gc);
+		break;
+	case QQ_MSG_SYS:
+		do_msg_sys(gc, data + bytes, data_len - bytes);
+		break;
+	default:
+		purple_debug_warning("QQ", "MSG from %u, unknown type %s [0x%04X]\n",
+			header.uid_from, get_im_type_desc(header.msg_type), header.msg_type);
+		qq_show_packet("MSG header", data, bytes);
+		if (data_len - bytes > 0) {
+			qq_show_packet("MSG data", data + bytes, data_len - bytes);
+		}
+		break;
 	}
 }
 
@@ -521,17 +492,18 @@ void qq_proc_server_cmd(PurpleConnection
 
 	/* now process the packet */
 	switch (cmd) {
+		case QQ_CMD_RECV_IM_CE:
 		case QQ_CMD_RECV_IM:
 			process_private_msg(data, data_len, seq, gc);
 			break;
-		case QQ_CMD_RECV_MSG_SYS:
+		case QQ_CMD_RECV_NOTIFY:
 			process_server_msg(gc, data, data_len, seq);
 			break;
 		case QQ_CMD_BUDDY_CHANGE_STATUS:
 			qq_process_buddy_change_status(data, data_len, gc);
 			break;
 		default:
-			process_unknow_cmd(gc, _("Unknown SERVER CMD"), data, data_len, cmd, seq);
+			process_unknown_cmd(gc, _("Unknown SERVER CMD"), data, data_len, cmd, seq);
 			break;
 	}
 }
@@ -647,18 +619,13 @@ void qq_update_all(PurpleConnection *gc,
 			qq_request_change_status(gc, QQ_CMD_CLASS_UPDATE_ALL);
 			break;
 		case QQ_CMD_CHANGE_STATUS:
-			qq_request_get_buddies(gc, 0, QQ_CMD_CLASS_UPDATE_ALL);
+			qq_request_get_buddies_list(gc, 0, QQ_CMD_CLASS_UPDATE_ALL);
 			break;
 		case QQ_CMD_GET_BUDDIES_LIST:
-			qq_request_get_buddies_and_rooms(gc, 0, QQ_CMD_CLASS_UPDATE_ALL);
+			qq_request_buddy_memo(gc, 0, QQ_CMD_CLASS_UPDATE_ALL, QQ_BUDDY_MEMO_ALIAS);
 			break;
-		case QQ_CMD_GET_BUDDIES_AND_ROOMS:
-			if (qd->client_version >= 2007) {
-				/* QQ2007/2008 can not get buddies level*/
-				qq_request_get_buddies_online(gc, 0, QQ_CMD_CLASS_UPDATE_ALL);
-			} else {
-				qq_request_get_buddies_level(gc, QQ_CMD_CLASS_UPDATE_ALL);
-			}
+		case QQ_CMD_BUDDY_MEMO:
+			qq_request_get_buddies_level(gc, QQ_CMD_CLASS_UPDATE_ALL);
 			break;
 		case QQ_CMD_GET_LEVEL:
 			qq_request_get_buddies_online(gc, 0, QQ_CMD_CLASS_UPDATE_ALL);
@@ -725,7 +692,7 @@ void qq_update_online(PurpleConnection *
 
 void qq_proc_room_cmds(PurpleConnection *gc, guint16 seq,
 		guint8 room_cmd, guint32 room_id, guint8 *rcved, gint rcved_len,
-		UPDCLS update_class, guint32 ship32)
+		guint32 update_class, guint32 ship32)
 {
 	qq_data *qd;
 	guint8 *data;
@@ -840,7 +807,7 @@ void qq_proc_room_cmds(PurpleConnection
 		qq_process_room_cmd_get_buddies(data + bytes, data_len - bytes, gc);
 		break;
 	default:
-		purple_debug_warning("QQ", "Unknow room cmd 0x%02X %s\n",
+		purple_debug_warning("QQ", "Unknown room cmd 0x%02X %s\n",
 			   reply_cmd, qq_get_room_cmd_desc(reply_cmd));
 	}
 
@@ -861,7 +828,7 @@ void qq_proc_room_cmds(PurpleConnection
 }
 
 guint8 qq_proc_login_cmds(PurpleConnection *gc,  guint16 cmd, guint16 seq,
-		guint8 *rcved, gint rcved_len, UPDCLS update_class, guint32 ship32)
+		guint8 *rcved, gint rcved_len, guint32 update_class, guint32 ship32)
 {
 	qq_data *qd;
 	guint8 *data = NULL;
@@ -875,57 +842,47 @@ guint8 qq_proc_login_cmds(PurpleConnecti
 	data = g_newa(guint8, rcved_len);
 
 	switch (cmd) {
-		case QQ_CMD_TOKEN:
-			if (qq_process_token(gc, rcved, rcved_len) == QQ_LOGIN_REPLY_OK) {
-				if (qd->client_version >= 2007) {
-					qq_request_token_ex(gc);
-				} else {
-					qq_request_login(gc);
-				}
-				return QQ_LOGIN_REPLY_OK;
-			}
-			return QQ_LOGIN_REPLY_ERR;
-		case QQ_CMD_GET_SERVER:
-		case QQ_CMD_TOKEN_EX:
+		case QQ_CMD_TOUCH_SERVER:
+		case QQ_CMD_CAPTCHA:
 			data_len = qq_decrypt(data, rcved, rcved_len, qd->ld.random_key);
 			break;
-		case QQ_CMD_CHECK_PWD:
-			/* May use password_twice_md5 in the past version like QQ2005 */
+		case QQ_CMD_AUTH:
 			data_len = qq_decrypt(data, rcved, rcved_len, qd->ld.random_key);
 			if (data_len >= 0) {
 				purple_debug_warning("QQ", "Decrypt login packet by random_key, %d bytes\n", data_len);
 			} else {
-				data_len = qq_decrypt(data, rcved, rcved_len, qd->ld.pwd_twice_md5);
+				data_len = qq_decrypt(data, rcved, rcved_len, auth_key[1]);
 				if (data_len >= 0) {
-					purple_debug_warning("QQ", "Decrypt login packet by pwd_twice_md5, %d bytes\n", data_len);
+					purple_debug_warning("QQ", "Decrypt login packet by auth_key1, %d bytes\n", data_len);
 				}
 			}
 			break;
+		case QQ_CMD_VERIFY_E5:
+			data_len = qq_decrypt(data, rcved, rcved_len, qd->ld.keys[1]);
+			break;
+		case QQ_CMD_VERIFY_E3:
+			data_len = qq_decrypt(data, rcved, rcved_len, qd->ld.keys[3]);
+			break;
 		case QQ_CMD_LOGIN:
-		default:
-			if (qd->client_version >= 2007) {
-				data_len = qq_decrypt(data, rcved, rcved_len, qd->ld.pwd_twice_md5);
-				if (data_len >= 0) {
-					purple_debug_warning("QQ", "Decrypt login packet by pwd_twice_md5\n");
-				} else {
-					data_len = qq_decrypt(data, rcved, rcved_len, qd->ld.login_key);
-					if (data_len >= 0) {
-						purple_debug_warning("QQ", "Decrypt login packet by login_key\n");
-					}
-				}
+			data_len = qq_decrypt(data, rcved, rcved_len, qd->ld.keys[2]);
+			if (data_len >= 0) {
+				purple_debug_warning("QQ", "Decrypt login packet by Key0_VerifyE5\n");
 			} else {
-				/* May use password_twice_md5 in the past version like QQ2005 */
-				data_len = qq_decrypt(data, rcved, rcved_len, qd->ld.random_key);
+				/* network condition may has changed. please sign in again. */
+				data_len = qq_decrypt(data, rcved, rcved_len, qd->ld.keys[0]);	
 				if (data_len >= 0) {
-					purple_debug_warning("QQ", "Decrypt login packet by random_key\n");
-				} else {
-					data_len = qq_decrypt(data, rcved, rcved_len, qd->ld.pwd_twice_md5);
-					if (data_len >= 0) {
-						purple_debug_warning("QQ", "Decrypt login packet by pwd_twice_md5\n");
-					}
+					purple_debug_warning("QQ", "Decrypt login packet rarely by Key2_Auth\n");
 				}
 			}
 			break;
+		case QQ_CMD_LOGIN_E9:
+		case QQ_CMD_LOGIN_EA:
+		case QQ_CMD_LOGIN_GETLIST:
+		case QQ_CMD_LOGIN_ED:
+		case QQ_CMD_LOGIN_EC:
+		default:
+			data_len = qq_decrypt(data, rcved, rcved_len, qd->session_key);
+			break;
 	}
 
 	if (data_len < 0) {
@@ -940,20 +897,20 @@ guint8 qq_proc_login_cmds(PurpleConnecti
 	}
 
 	switch (cmd) {
-		case QQ_CMD_GET_SERVER:
-			ret_8 = qq_process_get_server(gc, data, data_len);
+		case QQ_CMD_TOUCH_SERVER:
+			ret_8 = qq_process_touch_server(gc, data, data_len);
 			if ( ret_8 == QQ_LOGIN_REPLY_OK) {
-				qq_request_token(gc);
-			} else if ( ret_8 == QQ_LOGIN_REPLY_REDIRECT) {
-				return QQ_LOGIN_REPLY_REDIRECT;
+				qq_request_captcha(gc);
+			} else if ( ret_8 == QQ_TOUCH_REPLY_REDIRECT) {
+				return QQ_TOUCH_REPLY_REDIRECT;
 			}
 			break;
-		case QQ_CMD_TOKEN_EX:
-			ret_8 = qq_process_token_ex(gc, data, data_len);
+		case QQ_CMD_CAPTCHA:
+			ret_8 = qq_process_captcha(gc, data, data_len);
 			if (ret_8 == QQ_LOGIN_REPLY_OK) {
-				qq_request_check_pwd(gc);
-			} else if (ret_8 == QQ_LOGIN_REPLY_NEXT_TOKEN_EX) {
-				qq_request_token_ex_next(gc);
+				qq_request_auth(gc);
+			} else if (ret_8 == QQ_LOGIN_REPLY_NEXT_CAPTCHA) {
+				qq_request_captcha_next(gc);
 			} else if (ret_8 == QQ_LOGIN_REPLY_CAPTCHA_DLG) {
 				qq_captcha_input_dialog(gc, &(qd->captcha));
 				g_free(qd->captcha.token);
@@ -961,37 +918,57 @@ guint8 qq_proc_login_cmds(PurpleConnecti
 				memset(&qd->captcha, 0, sizeof(qd->captcha));
 			}
 			break;
-		case QQ_CMD_CHECK_PWD:
-			ret_8 = qq_process_check_pwd(gc, data, data_len);
+		case QQ_CMD_AUTH:
+			ret_8 = qq_process_auth(gc, data, data_len);
 			if (ret_8 != QQ_LOGIN_REPLY_OK) {
 				return ret_8;
 			}
-			if (qd->client_version >= 2008) {
-				qq_request_login_2008(gc);
-			} else {
-				qq_request_login_2007(gc);
+			qq_request_verify_E5(gc);
+			break;
+		case QQ_CMD_VERIFY_E5:
+			ret_8 = qq_process_verify_E5(gc, data, data_len);
+			if (ret_8 != QQ_LOGIN_REPLY_OK) {
+				return ret_8;
+			}
+			qq_request_verify_E3(gc);
+			break;
+		case QQ_CMD_VERIFY_E3:
+			ret_8 = qq_process_verify_E3(gc, data, data_len);
+			if (ret_8 != QQ_LOGIN_REPLY_OK) {
+				return ret_8;
+			}
+			if (qd->client_version >= 2010) {
+				qq_request_login(gc);
 			}
 			break;
 		case QQ_CMD_LOGIN:
-			if (qd->client_version >= 2008) {
-				ret_8 = qq_process_login_2008(gc, data, data_len);
-				if ( ret_8 == QQ_LOGIN_REPLY_REDIRECT) {
-                		qq_request_get_server(gc);
-                		return QQ_LOGIN_REPLY_OK;
-            	}
-			} else if (qd->client_version >= 2007) {
-				ret_8 = qq_process_login_2007(gc, data, data_len);
-				if ( ret_8 == QQ_LOGIN_REPLY_REDIRECT) {
-                		qq_request_get_server(gc);
-                		return QQ_LOGIN_REPLY_OK;
-            	}
+			ret_8 = qq_process_login(gc, data, data_len);
+			if ( ret_8 == QQ_TOUCH_REPLY_REDIRECT) {
+           		qq_request_touch_server(gc);
+				return QQ_LOGIN_REPLY_OK;
+           	}
+			if (ret_8 == QQ_LOGIN_REPLY_OK) {
+				qq_request_login_E9(gc);
 			} else {
-				ret_8 = qq_process_login(gc, data, data_len);
-			}
-			if (ret_8 != QQ_LOGIN_REPLY_OK) {
 				return ret_8;
 			}
 
+			break;
+		case QQ_CMD_LOGIN_E9:
+			qq_request_login_EA(gc);
+			break;
+		case QQ_CMD_LOGIN_EA:
+			qq_request_login_getlist(gc);
+			break;
+		case QQ_CMD_LOGIN_GETLIST:
+			qq_process_login_getlist(gc, data, data_len);
+			qq_request_login_ED(gc);
+			break;
+		case QQ_CMD_LOGIN_EC:
+			break;
+		case QQ_CMD_LOGIN_ED:
+			qq_request_login_EC(gc);
+
 			purple_connection_update_progress(gc, _("Logging in"), QQ_CONNECT_STEPS - 1, QQ_CONNECT_STEPS);
 			purple_debug_info("QQ", "Login replies OK; everything is fine\n");
 			purple_connection_set_state(gc, PURPLE_CONNECTED);
@@ -1006,14 +983,14 @@ guint8 qq_proc_login_cmds(PurpleConnecti
 			qq_update_all(gc, 0);
 			break;
 		default:
-			process_unknow_cmd(gc, _("Unknown LOGIN CMD"), data, data_len, cmd, seq);
+			process_unknown_cmd(gc, _("Unknown LOGIN CMD"), data, data_len, cmd, seq);
 			return QQ_LOGIN_REPLY_ERR;
 	}
 	return QQ_LOGIN_REPLY_OK;
 }
 
 void qq_proc_client_cmds(PurpleConnection *gc, guint16 cmd, guint16 seq,
-		guint8 *rcved, gint rcved_len, UPDCLS update_class, guint32 ship32)
+		guint8 *rcved, gint rcved_len, guint32 update_class, guint32 ship32)
 {
 	qq_data *qd;
 
@@ -1023,7 +1000,7 @@ void qq_proc_client_cmds(PurpleConnectio
 	guint8 ret_8 = 0;
 	guint16 ret_16 = 0;
 	guint32 ret_32 = 0;
-	gboolean is_unknow = FALSE;
+	gboolean is_unknown = FALSE;
 
 	g_return_if_fail(rcved_len > 0);
 
@@ -1073,11 +1050,7 @@ void qq_proc_client_cmds(PurpleConnectio
 			do_im_ack(data, data_len, gc);
 			break;
 		case QQ_CMD_KEEP_ALIVE:
-			if (qd->client_version >= 2008) {
-				qq_process_keep_alive_2008(data, data_len, gc);
-			} else if (qd->client_version >= 2007) {
-				qq_process_keep_alive_2007(data, data_len, gc);
-			} else {
+			if (qd->client_version >= 2010) {
 				qq_process_keep_alive(data, data_len, gc);
 			}
 			break;
@@ -1095,25 +1068,16 @@ void qq_proc_client_cmds(PurpleConnectio
 			qq_process_get_level_reply(data, data_len, gc);
 			break;
 		case QQ_CMD_GET_BUDDIES_LIST:
-			ret_16 = qq_process_get_buddies(data, data_len, gc);
+			ret_16 = qq_process_get_buddies_list(data, data_len, gc);
 			if (ret_16 > 0	&& ret_16 < 0xffff) {
 				purple_debug_info("QQ", "Requesting for more buddies\n");
-				qq_request_get_buddies(gc, ret_16, update_class);
+				qq_request_get_buddies_list(gc, ret_16, update_class);
 				return;
 			}
 			purple_debug_info("QQ", "All buddies received. Requesting buddies' levels\n");
 			break;
-		case QQ_CMD_GET_BUDDIES_AND_ROOMS:
-			ret_32 = qq_process_get_buddies_and_rooms(data, data_len, gc);
-			if (ret_32 > 0 && ret_32 < 0xffffffff) {
-				purple_debug_info("QQ", "Requesting for more buddies and groups\n");
-				qq_request_get_buddies_and_rooms(gc, ret_32, update_class);
-				return;
-			}
-			purple_debug_info("QQ", "All buddies and groups received\n");
-			break;
-		case QQ_CMD_AUTH_CODE:
-			qq_process_auth_code(gc, data, data_len, ship32);
+		case QQ_CMD_AUTH_TOKEN:
+			qq_process_auth_token(gc, data, data_len, update_class, ship32);
 			break;
 		case QQ_CMD_BUDDY_QUESTION:
 			qq_process_question(gc, data, data_len, ship32);
@@ -1130,15 +1094,13 @@ void qq_proc_client_cmds(PurpleConnectio
 		case QQ_CMD_BUDDY_MEMO:
 			purple_debug_info("QQ", "Receive memo from server!\n");
 			qq_process_get_buddy_memo(gc, data, data_len, update_class, ship32);
-			return;
-			purple_debug_info("QQ", "Should NOT be here...\n");
 			break;
 		default:
-			process_unknow_cmd(gc, _("Unknown CLIENT CMD"), data, data_len, cmd, seq);
-			is_unknow = TRUE;
+			process_unknown_cmd(gc, _("Unknown CLIENT CMD"), data, data_len, cmd, seq);
+			is_unknown = TRUE;
 			break;
 	}
-	if (is_unknow)
+	if (is_unknown)
 		return;
 
 	if (update_class == QQ_CMD_CLASS_NONE)
diff -urp libpurple/protocols/qq/qq_process.h libpurple/protocols/qq/qq_process.h
--- libpurple/protocols/qq/qq_process.h	2011-02-07 11:42:12.000000000 +0800
+++ libpurple/protocols/qq/qq_process.h	2011-02-24 17:38:51.943460335 +0800
@@ -39,12 +39,12 @@ enum {
 };
 
 guint8 qq_proc_login_cmds(PurpleConnection *gc,  guint16 cmd, guint16 seq,
-		guint8 *rcved, gint rcved_len, UPDCLS update_class, guint32 ship32);
+		guint8 *rcved, gint rcved_len, guint32 update_class, guint32 ship32);
 void qq_proc_client_cmds(PurpleConnection *gc, guint16 cmd, guint16 seq,
-		guint8 *rcved, gint rcved_len, UPDCLS update_class, guint32 ship32);
+		guint8 *rcved, gint rcved_len, guint32 update_class, guint32 ship32);
 void qq_proc_room_cmds(PurpleConnection *gc, guint16 seq,
 		guint8 room_cmd, guint32 room_id, guint8 *rcved, gint rcved_len,
-		UPDCLS update_class, guint32 ship32);
+		guint32 update_class, guint32 ship32);
 
 void qq_proc_server_cmd(PurpleConnection *gc, guint16 cmd, guint16 seq, guint8 *rcved, gint rcved_len);
 
diff -urp libpurple/protocols/qq/qq_trans.c libpurple/protocols/qq/qq_trans.c
--- libpurple/protocols/qq/qq_trans.c	2011-02-07 11:42:12.000000000 +0800
+++ libpurple/protocols/qq/qq_trans.c	2011-02-24 17:38:52.010127001 +0800
@@ -42,6 +42,25 @@ enum {
 	QQ_TRANS_IS_REPLY = 0x08				/* server command before login*/
 };
 
+struct _qq_transaction {
+	guint8 flag;
+	guint16 seq;
+	guint16 cmd;
+
+	guint8 room_cmd;
+	guint32 room_id;
+
+	guint8 *data;
+	gint data_len;
+
+	gint fd;
+	gint send_retries;
+	gint rcved_times;
+	gint scan_times;
+
+	guint32 update_class;
+	guint32 ship32;
+};
 
 gboolean qq_trans_is_server(qq_transaction *trans)
 {
@@ -88,7 +107,7 @@ guint32 qq_trans_get_ship(qq_transaction
 }
 
 static qq_transaction *trans_create(PurpleConnection *gc, gint fd,
-	guint16 cmd, guint16 seq, guint8 *data, gint data_len, UPDCLS update_class, guint32 ship32)
+	guint16 cmd, guint16 seq, guint8 *data, gint data_len, guint32 update_class, guint32 ship32)
 {
 	qq_transaction *trans;
 
@@ -159,12 +178,12 @@ static qq_transaction *trans_find(Purple
 }
 
 void qq_trans_add_client_cmd(PurpleConnection *gc,
-	guint16 cmd, guint16 seq, guint8 *data, gint data_len, UPDCLS update_class, guint32 ship32)
+	guint16 cmd, guint16 seq, guint8 *data, gint data_len, guint32 update_class, guint32 ship32)
 {
 	qq_data *qd = (qq_data *)gc->proto_data;
 	qq_transaction *trans = trans_create(gc, qd->fd, cmd, seq, data, data_len, update_class, ship32);
 
-	if (cmd == QQ_CMD_TOKEN || cmd == QQ_CMD_LOGIN || cmd == QQ_CMD_KEEP_ALIVE) {
+	if (cmd == QQ_CMD_LOGIN || cmd == QQ_CMD_KEEP_ALIVE) {
 		trans->flag |= QQ_TRANS_IS_IMPORT;
 	}
 	trans->send_retries = qd->resend_times;
@@ -199,7 +218,7 @@ qq_transaction *qq_trans_find_rcved(Purp
 
 void qq_trans_add_room_cmd(PurpleConnection *gc,
 		guint16 seq, guint8 room_cmd, guint32 room_id, guint8 *data, gint data_len,
-		UPDCLS update_class, guint32 ship32)
+		guint32 update_class, guint32 ship32)
 {
 	qq_data *qd = (qq_data *)gc->proto_data;
 	qq_transaction *trans = trans_create(gc, qd->fd, QQ_CMD_ROOM, seq, data, data_len,
diff -urp libpurple/protocols/qq/qq_trans.h libpurple/protocols/qq/qq_trans.h
--- libpurple/protocols/qq/qq_trans.h	2011-02-07 11:42:12.000000000 +0800
+++ libpurple/protocols/qq/qq_trans.h	2011-02-24 17:38:52.010127001 +0800
@@ -28,25 +28,7 @@
 #include <glib.h>
 #include "qq.h"
 
-typedef struct _qq_transaction {
-	guint8 flag;
-	guint16 seq;
-	guint16 cmd;
-
-	guint8 room_cmd;
-	guint32 room_id;
-
-	guint8 *data;
-	gint data_len;
-
-	gint fd;
-	gint send_retries;
-	gint rcved_times;
-	gint scan_times;
-
-	UPDCLS update_class;
-	guint32 ship32;
-} qq_transaction;
+typedef struct _qq_transaction qq_transaction;
 
 qq_transaction *qq_trans_find_rcved(PurpleConnection *gc, guint16 cmd, guint16 seq);
 gboolean qq_trans_is_server(qq_transaction *trans) ;
@@ -57,10 +39,10 @@ guint32 qq_trans_get_class(qq_transactio
 guint32 qq_trans_get_ship(qq_transaction *trans);
 
 void qq_trans_add_client_cmd(PurpleConnection *gc, guint16 cmd, guint16 seq,
-		guint8 *data, gint data_len, UPDCLS update_class, guint32 ship32);
+		guint8 *data, gint data_len, guint32 update_class, guint32 ship32);
 void qq_trans_add_room_cmd(PurpleConnection *gc,
 		guint16 seq, guint8 room_cmd, guint32 room_id,
-		guint8 *data, gint data_len, UPDCLS update_class, guint32 ship32);
+		guint8 *data, gint data_len, guint32 update_class, guint32 ship32);
 void qq_trans_add_server_cmd(PurpleConnection *gc, guint16 cmd, guint16 seq,
 	guint8 *rcved, gint rcved_len);
 void qq_trans_add_server_reply(PurpleConnection *gc, guint16 cmd, guint16 seq,
diff -urp libpurple/protocols/qq/send_file.c libpurple/protocols/qq/send_file.c
--- libpurple/protocols/qq/send_file.c	2011-02-07 11:42:12.000000000 +0800
+++ libpurple/protocols/qq/send_file.c	2011-02-24 17:38:51.943460335 +0800
@@ -278,7 +278,7 @@ gint qq_fill_conn_info(guint8 *raw_data,
 
 /* fill in the common information of file transfer */
 static gint _qq_create_packet_file_header
-(guint8 *raw_data, UID to_uid, guint16 message_type, qq_data *qd, gboolean seq_ack)
+(guint8 *raw_data, guint32 to_uid, guint16 message_type, qq_data *qd, gboolean seq_ack)
 {
 	gint bytes;
 	time_t now;
@@ -430,7 +430,7 @@ static void _qq_xfer_init_socket(PurpleX
 }
 
 /* create the QQ_FILE_TRANS_REQ packet with file infomations */
-static void _qq_send_packet_file_request (PurpleConnection *gc, UID to_uid, gchar *filename, gint filesize)
+static void _qq_send_packet_file_request (PurpleConnection *gc, guint32 to_uid, gchar *filename, gint filesize)
 {
 	qq_data *qd;
 	guint8 *raw_data;
@@ -482,7 +482,7 @@ static void _qq_send_packet_file_request
 }
 
 /* tell the buddy we want to accept the file */
-static void _qq_send_packet_file_accept(PurpleConnection *gc, UID to_uid)
+static void _qq_send_packet_file_accept(PurpleConnection *gc, guint32 to_uid)
 {
 	qq_data *qd;
 	guint8 *raw_data;
@@ -520,7 +520,7 @@ static void _qq_send_packet_file_accept(
 			    packet_len, bytes);
 }
 
-static void _qq_send_packet_file_notifyip(PurpleConnection *gc, UID to_uid)
+static void _qq_send_packet_file_notifyip(PurpleConnection *gc, guint32 to_uid)
 {
 	PurpleXfer *xfer;
 	ft_info *info;
@@ -552,7 +552,7 @@ static void _qq_send_packet_file_notifyi
 }
 
 /* tell the buddy we don't want the file */
-static void _qq_send_packet_file_reject (PurpleConnection *gc, UID to_uid)
+static void _qq_send_packet_file_reject (PurpleConnection *gc, guint32 to_uid)
 {
 	qq_data *qd;
 	guint8 *raw_data;
@@ -576,7 +576,7 @@ static void _qq_send_packet_file_reject
 }
 
 /* tell the buddy to cancel transfer */
-static void _qq_send_packet_file_cancel (PurpleConnection *gc, UID to_uid)
+static void _qq_send_packet_file_cancel (PurpleConnection *gc, guint32 to_uid)
 {
 	qq_data *qd;
 	guint8 *raw_data;
@@ -611,7 +611,7 @@ _qq_xfer_init (PurpleXfer * xfer)
 {
 	PurpleConnection *gc;
 	PurpleAccount *account;
-	UID to_uid;
+	guint32 to_uid;
 	const gchar *filename;
 	gchar *base_filename;
 
@@ -678,7 +678,7 @@ static void _qq_xfer_recv_init(PurpleXfe
 
 /* process reject im for file transfer request */
 void qq_process_recv_file_reject (guint8 *data, gint data_len,
-		UID sender_uid, PurpleConnection *gc)
+		guint32 sender_uid, PurpleConnection *gc)
 {
 	gchar *msg, *filename;
 	qq_data *qd;
@@ -708,7 +708,7 @@ void qq_process_recv_file_reject (guint8
 
 /* process cancel im for file transfer request */
 void qq_process_recv_file_cancel (guint8 *data, gint data_len,
-		UID sender_uid, PurpleConnection *gc)
+		guint32 sender_uid, PurpleConnection *gc)
 {
 	gchar *msg, *filename;
 	qq_data *qd;
@@ -738,7 +738,7 @@ void qq_process_recv_file_cancel (guint8
 }
 
 /* process accept im for file transfer request */
-void qq_process_recv_file_accept(guint8 *data, gint data_len, UID sender_uid, PurpleConnection *gc)
+void qq_process_recv_file_accept(guint8 *data, gint data_len, guint32 sender_uid, PurpleConnection *gc)
 {
 	qq_data *qd;
 	gint bytes;
@@ -764,7 +764,7 @@ void qq_process_recv_file_accept(guint8
 }
 
 /* process request from buddy's im for file transfer request */
-void qq_process_recv_file_request(guint8 *data, gint data_len, UID sender_uid, PurpleConnection * gc)
+void qq_process_recv_file_request(guint8 *data, gint data_len, guint32 sender_uid, PurpleConnection * gc)
 {
 	qq_data *qd;
 	PurpleXfer *xfer;
@@ -874,7 +874,7 @@ static void _qq_xfer_send_notify_ip_ack(
 }
 
 void qq_process_recv_file_notify(guint8 *data, gint data_len,
-		UID sender_uid, PurpleConnection *gc)
+		guint32 sender_uid, PurpleConnection *gc)
 {
 	gint bytes;
 	qq_data *qd;
diff -urp libpurple/protocols/qq/send_file.h libpurple/protocols/qq/send_file.h
--- libpurple/protocols/qq/send_file.h	2011-02-07 11:42:12.000000000 +0800
+++ libpurple/protocols/qq/send_file.h	2011-02-24 17:38:51.986793667 +0800
@@ -29,7 +29,7 @@
 #include "qq.h"
 
 typedef struct _ft_info {
-	UID to_uid;
+	guint32 to_uid;
 	guint16 send_seq;
 	guint8 file_session_key[QQ_KEY_LENGTH];
 	guint8 conn_method;
@@ -67,11 +67,11 @@ typedef struct _ft_info {
 	gboolean use_major;
 } ft_info;
 
-void qq_process_recv_file_accept(guint8 *data, gint data_len, UID sender_uid, PurpleConnection *gc);
-void qq_process_recv_file_reject(guint8 *data, gint data_len, UID sender_uid, PurpleConnection *gc);
-void qq_process_recv_file_cancel(guint8 *data, gint data_len, UID sender_uid, PurpleConnection *gc);
-void qq_process_recv_file_request(guint8 *data, gint data_len, UID sender_uid, PurpleConnection *gc);
-void qq_process_recv_file_notify(guint8 *data, gint data_len, UID sender_uid, PurpleConnection *gc);
+void qq_process_recv_file_accept(guint8 *data, gint data_len, guint32 sender_uid, PurpleConnection *gc);
+void qq_process_recv_file_reject(guint8 *data, gint data_len, guint32 sender_uid, PurpleConnection *gc);
+void qq_process_recv_file_cancel(guint8 *data, gint data_len, guint32 sender_uid, PurpleConnection *gc);
+void qq_process_recv_file_request(guint8 *data, gint data_len, guint32 sender_uid, PurpleConnection *gc);
+void qq_process_recv_file_notify(guint8 *data, gint data_len, guint32 sender_uid, PurpleConnection *gc);
 gboolean qq_can_receive_file(PurpleConnection *gc, const char *who);
 void qq_send_file(PurpleConnection *gc, const char *who, const char *file);
 gint qq_get_conn_info(ft_info *info, guint8 *data);
diff -urp libpurple/protocols/qq/utils.c libpurple/protocols/qq/utils.c
--- libpurple/protocols/qq/utils.c	2011-02-07 11:42:12.000000000 +0800
+++ libpurple/protocols/qq/utils.c	2011-02-24 17:38:51.903460334 +0800
@@ -131,9 +131,9 @@ gchar **split_data(guint8 *data, gint le
 }
 
 /* convert Purple name to original QQ UID */
-UID purple_name_to_uid(const gchar *const name)
+guint32 purple_name_to_uid(const gchar *const name)
 {
-	UID ret;
+	guint32 ret;
 	g_return_val_if_fail(name != NULL, 0);
 
 	ret = strtoul(name, NULL, 10);
@@ -168,7 +168,7 @@ guint8 *str_ip_gen(gchar *str) {
 
 /* convert a QQ UID to a unique name of Purple
  * the return needs to be freed */
-gchar *uid_to_purple_name(UID uid)
+gchar *uid_to_purple_name(guint32 uid)
 {
 	return g_strdup_printf("%u", uid);
 }
@@ -204,7 +204,7 @@ static gchar *strstrip(const gchar *cons
 {
 	GString *stripped;
 	gchar *ret, cur;
-	gint i;
+	guint i;
 
 	g_return_val_if_fail(buffer != NULL, NULL);
 
diff -urp libpurple/protocols/qq/utils.h libpurple/protocols/qq/utils.h
--- libpurple/protocols/qq/utils.h	2011-02-07 11:42:12.000000000 +0800
+++ libpurple/protocols/qq/utils.h	2011-02-24 17:38:51.903460334 +0800
@@ -27,7 +27,6 @@
 
 #include <stdio.h>
 #include <glib.h>
-#include "qq.h"
 
 #include "debug.h"
 
@@ -41,8 +40,8 @@ gchar **split_data(guint8 *data, gint le
 gchar *gen_ip_str(guint8 *ip);
 guint8 *str_ip_gen(gchar *str);
 
-UID purple_name_to_uid(const gchar *name);
-gchar *uid_to_purple_name(UID uid);
+guint32 purple_name_to_uid(const gchar *const name);
+gchar *uid_to_purple_name(guint32 uid);
 
 gchar *try_dump_as_gbk(const guint8 *const data, gint len);
 
@@ -50,7 +49,7 @@ void qq_show_packet(const gchar *desc, c
 void qq_hex_dump(PurpleDebugLevel level, const char *category,
 		const guint8 *pdata, gint bytes,
 		const char *format, ...);
-guint8 *hex_str_to_bytes(const gchar *buf, gint *out_len);
+guint8 *hex_str_to_bytes(const gchar *const buf, gint *out_len);
 
 void qq_filter_str(gchar *str);
 #endif
